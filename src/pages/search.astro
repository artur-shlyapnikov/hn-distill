---
import "../styles/global.css";
import { LANG } from "@config/lang";

const lang = LANG;
const i18n = {
  ru: {
    title: "Поиск",
    qTitle: "Заголовок…",
    qDomain: "Домен…",
    qTags: "Теги (через запятую)",
    from: "С",
    to: "По",
    clear: "Сброс",
    results: "Результатов",
    pageTitle: "Поиск — Hacker News Digest",
    pageDesc: "Поиск по Hacker News Digest: фильтрация по заголовку, домену, тегам и дате.",
  },
  en: {
    title: "Search",
    qTitle: "Title",
    qDomain: "Domain",
    qTags: "Tags (comma separated)",
    from: "From",
    to: "To",
    clear: "Clear",
    results: "Results",
    pageTitle: "Search — Hacker News Digest",
    pageDesc: "Search Hacker News Digest: filter by title, domain, tags, and date.",
  },
} as const;

const t = i18n[lang as "ru" | "en"];
---

<html lang={lang}>
  <head>
    <meta charset="utf-8" />
    <title>{t.pageTitle}</title>
    <meta name="description" content={t.pageDesc} />
    <meta name="robots" content="index,follow" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta property="og:title" content={t.pageTitle} />
    <meta property="og:description" content={t.pageDesc} />
    <meta property="og:url" content={Astro.url.href} />
    <meta property="og:site_name" content="Hacker News Digest" />
    <meta property="og:type" content="website" />
  </head>
  <body>
    <header>
      <h1><a href="/">Hacker News Digest</a></h1>
      <p class="meta">{t.title}</p>
    </header>
    <main>
      <form id="filters" class="filters" autocomplete="off">
        <input id="q-title" placeholder={t.qTitle} />
        <input id="q-domain" placeholder={t.qDomain} />
        <input id="q-tags" placeholder={t.qTags} />
        <input id="q-from" type="date" aria-label={t.from} />
        <input id="q-to" type="date" aria-label={t.to} />
        <button id="q-clear" type="button">{t.clear}</button>
        <span id="count" class="meta" aria-live="polite" style="justify-self: end;"></span>
      </form>
      <ul id="results" class="results"></ul>
    </main>
    <script type="module" define:vars={{ t }}>
      // i18n data is now available as 't' variable

      const els = {
        title: document.getElementById("q-title"),
        domain: document.getElementById("q-domain"),
        tags: document.getElementById("q-tags"),
        from: document.getElementById("q-from"),
        to: document.getElementById("q-to"),
        clear: document.getElementById("q-clear"),
        results: document.getElementById("results"),
        count: document.getElementById("count"),
      };

      // Prefer absolute root path (site uses absolute links); swap to base-aware if needed later.
      const data = await fetch("/data/search.json").then((r) => (r.ok ? r.json() : []));
      const rows = Array.isArray(data) ? data : [];

      const onChange = (() => {
        let t;
        return (immediate = false) => {
          clearTimeout(t);
          if (immediate) {
            apply();
          } else {
            // Adaptive debounce: faster for short queries, slower for complex ones
            const delay = Math.min(
              150,
              Math.max(
                50,
                (els.title.value?.length || 0) + (els.domain.value?.length || 0) + (els.tags.value?.length || 0)
              ) * 10
            );
            t = setTimeout(apply, delay);
          }
        };
      })();

      for (const k of ["title", "domain", "tags", "from", "to"]) els[k].addEventListener("input", onChange);
      els.clear.addEventListener("click", () => {
        for (const k of ["title", "domain", "tags", "from", "to"]) els[k].value = "";
        apply();
      });

      // Improved fuzzy search with stricter relevance
      function fuzzyScore(text, query) {
        if (!query) return { score: 1, matched: true };
        if (!text) return { score: 0, matched: false };

        text = text.toLowerCase();
        query = query.toLowerCase();

        // Exact match gets highest score
        if (text.includes(query)) {
          const exactPos = text.indexOf(query);
          // Strong preference for matches at the beginning
          const positionBonus = Math.max(0, 1 - (exactPos / text.length) * 0.5);
          return { score: 0.95 + positionBonus * 0.05, matched: true };
        }

        // For short queries (1-2 chars), be very strict
        if (query.length <= 2) {
          return { score: 0, matched: false };
        }

        // Word boundary matching - higher priority
        const words = text.split(/\s+/);
        for (const word of words) {
          if (word.startsWith(query) || word.includes(query)) {
            const coverage = query.length / word.length;
            return { score: 0.8 * coverage, matched: true };
          }
        }

        // Fuzzy matching - stricter conditions
        let textIdx = 0;
        let queryIdx = 0;
        let matches = 0;
        let gaps = 0;
        const queryChars = query.split("");

        while (textIdx < text.length && queryIdx < queryChars.length) {
          if (text[textIdx] === queryChars[queryIdx]) {
            matches++;
            queryIdx++;
          } else if (queryIdx > 0) {
            gaps++;
          }
          textIdx++;
        }

        if (matches === queryChars.length) {
          const density = matches / text.length;
          const gapPenalty = Math.max(0, 1 - (gaps / text.length) * 2);
          const lengthRatio = query.length / text.length;

          // Require higher density for shorter texts
          const minDensity = text.length < 20 ? 0.15 : 0.08;

          if (density >= minDensity && lengthRatio >= 0.1) {
            const score = Math.min(0.7, density * 3 + lengthRatio * 0.5) * gapPenalty;
            return { score: Math.max(0.3, score), matched: true };
          }
        }

        return { score: 0, matched: false };
      }

      // Stricter tag matching
      function matchTags(itemTags, queryTags) {
        if (!queryTags.length) return { score: 1, matched: true };

        const tags = Array.isArray(itemTags) ? itemTags.map((t) => String(t).toLowerCase()) : [];
        let totalScore = 0;
        let exactMatches = 0;
        let fuzzyMatches = 0;

        for (const qTag of queryTags) {
          let bestTagScore = 0;
          let isExact = false;

          for (const tag of tags) {
            // Exact match - highest priority
            if (tag === qTag) {
              bestTagScore = 1;
              isExact = true;
              break;
            }
            // Starts with or ends with query
            else if (tag.startsWith(qTag) || tag.endsWith(qTag)) {
              bestTagScore = Math.max(bestTagScore, 0.9);
            }
            // Contains query (but not fuzzy)
            else if (tag.includes(qTag) && qTag.length >= 3) {
              bestTagScore = Math.max(bestTagScore, 0.8);
            }
            // Query contains tag (for abbreviations)
            else if (qTag.includes(tag) && tag.length >= 3) {
              bestTagScore = Math.max(bestTagScore, 0.7);
            }
            // Fuzzy match only for longer strings
            else if (qTag.length >= 4 && tag.length >= 4) {
              const fuzzy = fuzzyScore(tag, qTag);
              if (fuzzy.matched && fuzzy.score > 0.6) {
                bestTagScore = Math.max(bestTagScore, fuzzy.score * 0.5);
              }
            }
          }

          if (bestTagScore > 0) {
            if (isExact) exactMatches++;
            else fuzzyMatches++;
            totalScore += bestTagScore;
          }
        }

        const totalMatches = exactMatches + fuzzyMatches;

        // Stricter requirements: prefer exact matches
        let matched = false;
        if (queryTags.length === 1) {
          matched = totalMatches > 0 && totalScore >= 0.7;
        } else {
          // For multiple tags, require at least 70% match rate with preference for exact
          const matchRate = totalMatches / queryTags.length;
          const exactRate = exactMatches / queryTags.length;
          matched = matchRate >= 0.7 && (exactRate >= 0.3 || totalScore / queryTags.length >= 0.8);
        }

        const score = matched ? totalScore / queryTags.length : 0;
        return { score, matched };
      }

      function apply() {
        // Show loading state
        els.count.textContent = "Поиск...";

        const qTitle = (els.title.value || "").trim();
        const qDomain = (els.domain.value || "").trim();
        const qTags = (els.tags.value || "")
          .split(",")
          .map((s) => s.trim())
          .filter(Boolean);
        const fromMs = els.from.value ? Date.parse(els.from.value + "T00:00:00Z") : -Infinity;
        const toMs = els.to.value ? Date.parse(els.to.value + "T23:59:59Z") : Infinity;

        // Pre-filter by date first (most selective)
        let candidates = rows;
        if (els.from.value || els.to.value) {
          candidates = rows.filter((r) => {
            const t = Date.parse(String(r.timeISO || ""));
            const ts = Number.isFinite(t) ? t : 0;
            return ts >= fromMs && ts <= toMs;
          });
        }

        // Optimized fuzzy search with early filtering
        let scoredResults = [];
        const maxResults = 1500; // Reduced for better performance
        const hasQuery = qTitle || qDomain || qTags.length > 0;

        // If no search terms, return date-sorted results quickly
        if (!hasQuery) {
          scoredResults = candidates.slice(0, maxResults).map((item) => ({
            item,
            relevanceScore: 1,
          }));
        } else {
          // Pre-filter candidates for exact matches first (faster)
          let exactMatches = [];
          let fuzzyMatches = [];

          for (const r of candidates) {
            if (exactMatches.length + fuzzyMatches.length >= maxResults) break;

            let hasExactMatch = false;
            let totalScore = 0;
            let factors = 0;
            let allMatched = true;

            // Title matching
            if (qTitle) {
              const title = String(r.title || "").toLowerCase();
              if (title.includes(qTitle.toLowerCase())) {
                hasExactMatch = true;
              }

              const titleResult = fuzzyScore(String(r.title || ""), qTitle);
              if (!titleResult.matched) {
                allMatched = false;
                continue;
              }
              totalScore += titleResult.score * 4; // Increased title weight
              factors += 4;
            }

            // Domain matching
            if (qDomain) {
              const domain = String(r.domain || "").toLowerCase();
              if (domain.includes(qDomain.toLowerCase())) {
                hasExactMatch = true;
              }

              const domainResult = fuzzyScore(String(r.domain || ""), qDomain);
              if (!domainResult.matched) {
                allMatched = false;
                continue;
              }
              totalScore += domainResult.score * 1;
              factors += 1;
            }

            // Tag matching
            if (qTags.length) {
              const tagResult = matchTags(r.tags, qTags);
              if (!tagResult.matched) {
                allMatched = false;
                continue;
              }
              totalScore += tagResult.score * 3; // Increased tag weight
              factors += 3;
            }

            if (allMatched) {
              const avgScore = factors > 0 ? totalScore / factors : 1;
              // Stronger boost for popular items
              const hnScoreBoost = Math.min(0.15, (r.score || 0) / 800);

              const result = {
                item: r,
                relevanceScore: avgScore + hnScoreBoost,
                hasExactMatch,
              };

              // Prioritize exact matches
              if (hasExactMatch) {
                exactMatches.push(result);
              } else {
                fuzzyMatches.push(result);
              }
            }
          }

          // Combine results: exact matches first, then fuzzy
          scoredResults = [...exactMatches, ...fuzzyMatches];
        }

        // Improved sorting: exact matches first, then by relevance
        scoredResults.sort((a, b) => {
          // Primary: exact matches first
          if (a.hasExactMatch !== b.hasExactMatch) {
            return a.hasExactMatch ? -1 : 1;
          }

          // Secondary: relevance score with better threshold
          const scoreDiff = b.relevanceScore - a.relevanceScore;
          if (Math.abs(scoreDiff) > 0.02) {
            return scoreDiff;
          }

          // Tertiary: HN score for similar relevance
          const hnScoreDiff = (b.item.score || 0) - (a.item.score || 0);
          if (Math.abs(hnScoreDiff) > 50) {
            return hnScoreDiff;
          }

          // Final: date (newer first)
          const ta = Date.parse(String(a.item.timeISO || "")) || 0;
          const tb = Date.parse(String(b.item.timeISO || "")) || 0;
          return tb - ta;
        });

        const out = scoredResults.map((sr) => sr.item);

        els.count.textContent = `${out.length} ${out.length === 1 ? (t.results === "Results" ? "result" : "результат") : t.results.toLowerCase()}`;

        // Render first 1000 for better fuzzy search utility (fuzzy results are pre-sorted by relevance)
        const slice = out.slice(0, 1000);
        els.results.innerHTML = slice
          .map((r) => {
            const date = String(r.timeISO || "").slice(0, 10);
            const dom = r.domain ? ` • ${escapeHtml(String(r.domain))}` : "";
            const score = Number.isFinite(r.score) ? ` • ⭐ ${r.score}` : "";
            const tags = (Array.isArray(r.tags) ? r.tags : [])
              .map((t) => `<a href="/tag/${escapeAttr(String(t))}/" class="tag">#${escapeHtml(String(t))}</a>`)
              .join(" ");
            return `<li class="card">
                    <h2 class="title"><a href="/item/${r.id}/">${escapeHtml(String(r.title || ""))}</a>${
                      r.domain
                        ? `<span class="meta" style="font-weight: normal; margin-left: .5rem;">(${escapeHtml(String(r.domain))})</span>`
                        : ""
                    }</h2>
                    <p class="meta">${date}${dom}${score}</p>
                    ${tags ? `<p class="meta tags">${tags}</p>` : ""}
                  </li>`;
          })
          .join("");
      }

      function escapeHtml(s) {
        return s.replace(
          /[&<>"']/g,
          (c) => ({ "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" })[c]
        );
      }
      function escapeAttr(s) {
        return s.replace(/[^-_.~a-zA-Z0-9]/g, (c) => {
          const code = c.charCodeAt(0).toString(16).toUpperCase();
          return `%${code.length === 1 ? "0" + code : code}`;
        });
      }

      apply();
    </script>
    <style>
      .filters {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr auto auto auto;
        gap: var(--space-sm);
        align-items: center;
      }
      .filters input {
        padding: 0.5rem;
        border: 1px solid var(--color-border);
        border-radius: var(--radius);
      }
      #q-clear {
        padding: 0.5rem 0.75rem;
      }
      .results {
        list-style: none;
        padding: 0;
        margin: var(--space-md) 0;
        display: grid;
        gap: var(--space-md);
      }
      .results .card {
        border: 1px solid var(--color-border);
        border-radius: var(--radius);
        padding: var(--space-md);
      }
      @media (max-width: 768px) {
        .filters {
          grid-template-columns: 1fr 1fr;
        }
      }
    </style>
  </body>
</html>

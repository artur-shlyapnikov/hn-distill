TextKit 2 - the promised land                                            

# [](https://blog.krzyzanowskim.com "Marcin Krzyżanowski")

* * *

[Back](https://blog.krzyzanowskim.com)

*   Friday 15 Aug 2025

# TextKit 2 - the promised land

TextKit 2 ([_NSTextLayoutManager_](https://developer.apple.com/documentation/uikit/nstextlayoutmanager?ref=blog.krzyzanowskim.com)) API was [announced](https://www.youtube.com/watch?v=guAmLgIEvvE&ref=blog.krzyzanowskim.com) publicly during WWDC21, which is over 4 years ago. Before that, it was in private development for a few years and gained widespread adoption in the macOS and iOS frameworks. Promised an easier, faster, overall better API and text layout engine that replaces the aged TextKit 1 ([_NSLayoutManager_](https://developer.apple.com/documentation/uikit/nslayoutmanager?ref=blog.krzyzanowskim.com)) engine.

Over the years, I gained some level of expertise in TextKit 2 and macOS/iOS text processing, which resulted in [STTextView](https://github.com/krzyzanowskim/STTextView?ref=blog.krzyzanowskim.com) - a re-implementation of TextView for macOS (AppKit) and iOS (UIKit) using TextKit 2 framework as a text layout engine, as well as [public speaking praising](https://www.youtube.com/watch?v=mw2gz-UQa1w&ref=blog.krzyzanowskim.com) the new, better engine we've just got to solve all the problems.

Based on my 4 years of experience working with it, I feel like I fell into a trap. It's not a silver bullet. It is arguably an improvement over TextKit 1. I want to discuss certain issues that make the TextKit 2 annoying to use (at best) and not the right tool for the job (at the worst)

## The architecture & implementation

The TextKit2 architecture is good. The abstraction and the components make a lot of sense and deliver on the premise of progressive complexity. BUT the implementation is less so on par with the architecture. On the one side, [NSTextContentManager](https://developer.apple.com/documentation/uikit/nstextcontentmanager?ref=blog.krzyzanowskim.com) provides an abstract interface for the layout engine. [In practice](https://developer.apple.com/forums/thread/747583?ref=blog.krzyzanowskim.com), using anything other than [NSTextContentStorage](https://developer.apple.com/documentation/uikit/nstextcontentstorage?ref=blog.krzyzanowskim.com) is impossible. NSTextContentStorage is one (and the only) provided implementation of the storage that works. That itself is backed by [NSTextStorage](https://developer.apple.com/documentation/uikit/nstextstorage?ref=blog.krzyzanowskim.com), which is an abstract interface for the content storage itself - meaning all the problems I may have with NSTextStorage apply to TextKit 2 as well. In short, [the UITextView/NSTextView won't work with anything other than NSTextContentStorage](https://developer.apple.com/forums/thread/690859?ref=blog.krzyzanowskim.com).

Text content manager operates on a series of [NSTextElement](https://developer.apple.com/documentation/uikit/nstextelement?ref=blog.krzyzanowskim.com) blocks, but again, the only working implementation must inherit from [NSTextParagraph](https://developer.apple.com/documentation/uikit/nstextparagraph?ref=blog.krzyzanowskim.com), or you're in trouble (runtime assertions).

The implementation is inconsistent, and it seems intentional. TextKit2 is implemented to be used by UITextView, and that is quickly obvious. What a waste of a great idea that could have been otherwise.

Bugs in software are expected, and for TextKit 2, it's no exception. [I reported many bugs myself](https://github.com/krzyzanowskim/STTextView?tab=readme-ov-file&ref=blog.krzyzanowskim.com#-textkit-2-bug-reports-list). Some issues are fixed, while others remain unresolved. Many users received no response. Additionally, bugs occur in specific versions, and regressions are common. It is annoying to maintain compatibility, of course. From my perspective, probably the most annoying [bugs are around the "extra line fragment"](https://gist.github.com/krzyzanowskim/510ecf8df259d779e22df8ad13c256c0?ref=blog.krzyzanowskim.com) (the rectangle for the extra line fragment at the end of a document) and its broken layout.

## Viewport is a struggle

Real struggle, though, is around the newly introduced idea of the viewport and how it works. Viewport is a tool that optimizes text layout engine work and minimizes memory footprint by focusing on the visible area, rather than the entire document, all the time. Viewport is a small portion of the visible area that "moves" as the user interacts with different parts of the document (eg, scrolling moves the viewport frame)

[![](https://blog.krzyzanowskim.com/content/images/2025/08/Screenshot-2025-08-14-at-17.48.19.png)](https://youtu.be/guAmLgIEvvE?t=1501&ref=blog.krzyzanowskim.com)

The viewport promise is that I don't have to ensure the layout of the whole document to get the layout of a random fragment of the document, and only layout lazily fragments that are actually important to display. To make this feature work, it requires various caching, managing intervals, invalidating ranges, and other related tasks; the TextKit 2 framework handles all of that.

Here's the stage: imagine you have a window with a text in it. Text scrolls up and down; as you scroll, the visible area displays the layout text. So, a typical text editor/viewer scenario.

![](https://blog.krzyzanowskim.com/content/images/2025/08/Screenshot-2025-08-14-at-22.38.24-1.png)

TextEdit with plain text content. One of the first use of TextKit 2 on macOS.

One of the problems with viewport management is the very same thing that is the feature of the viewport. When ensuring layout only in the viewport (visible area), all other parts of the document are estimated. Specifically, the total height of the document is estimated. The estimation changes frequently as I lay out more/different parts of the document. That happens when I move the viewport while scrolling up/down. TextKit updates the value of [NSTextLayoutManager.usageBoundsForTextContainer](https://developer.apple.com/documentation/appkit/nstextlayoutmanager/usageboundsfortextcontainer?ref=blog.krzyzanowskim.com) whenever the estimates change. The recipe to estimate the total height of the document is

1.  **ensureLayout(for: documentRange.endLocation)** that says, ensure layout of the end of the document, without forcing layout of the whole document. That operation, by definition, results in an estimated size.
2.  Resize the view to match the [usageBoundsForTextContainer](https://developer.apple.com/documentation/appkit/nstextlayoutmanager/usageboundsfortextcontainer?ref=blog.krzyzanowskim.com) value. In a scrollview, this results in an update of the **scroller** to reflect the current document position.

The first problem I notice with this approach is that as I scroll the document and continue to lay out the changing viewport position, the value of usageBoundsForTextContainer is _unstable_. It frequently changes value significantly. In a scrollview, such frequent and significant changes to the height result in "juggery" of the scroller position and size

![](https://blog.krzyzanowskim.com/content/images/2025/08/juggery-1.gif)

scrolling down. as document content moves up, viewport moves downward

The jiggery is super annoying and hard to accept. This is also expected, given that the height is estimated. Works as-designed:

> This is correct and as-designed – The viewport-based layout in TextKit2 doesn't require that the document is fully laid out; it just needs that the part of text to be displayed on screen is laid out, and that is the way it achieves a better scrolling performance.

[![](https://blog.krzyzanowskim.com/content/images/2025/08/Screenshot-2025-08-14-at-23.42.21.png)](https://developer.apple.com/forums/thread/761364?answerId=799739022&ref=blog.krzyzanowskim.com#799739022)

[https://developer.apple.com/forums/thread/761364?answerId=799739022#799739022](https://developer.apple.com/forums/thread/761364?answerId=799739022&ref=blog.krzyzanowskim.com#799739022)

A slightly "better" as a more stable value (from my observation), I receive when asking for the location of the last "layout element", using [enumerateTextLayoutFragments](https://developer.apple.com/documentation/appkit/nstextlayoutmanager/enumeratetextlayoutfragments\(from:options:using:\)?ref=blog.krzyzanowskim.com) and asking for the layout frame of the last, and only last fragment.

```swift
enumerateTextLayoutFragments(from: documentRange.endLocation, options: [.reverse, .ensuresLayout]) {
    layoutFragment in lastLineMaxY = layoutFragment.layoutFragmentFrame.maxY
    return false
}
```

That estimation is also just an estimate, and usually the value is significantly higher than the final, fully laid out document. How do I jump to the end of the document? The answer is:

*   receive an estimated (too big or too small) content height
*   update the view content size with the estimated height
*   enforce layout at the end of the document
*   move (relocate) the viewport to the end of that height (either final or estimated)

And yes, the viewport will display the end of the document, but the total height of the content is still estimated, meaning the scroller is most likely at the wrong position (it is wrong). What's the "fix" to that? The best guess is to artificially and contiusly "adjust" viewport position, meaning: the view scroll to estimated bottom of the document. Still, we ignore that fact and recognize that fact (from the context) and "fake" the viewport to display end of the document at that position, even if that position is way out of bounds of the document size. That operation (more likely, I need more adjustments like this) is fragile, and frankly, not easy to handle in a way that is not noticeable.

For a long time, I thought that I "hold it wrong" and there must be a way (maybe a private API) that addresses these problems, then I realized I'm not wrong. TextEdit app from macOS suffers from the very same issues I do in my implementations:

0:00

/0:06

 1× 

TextEdit and TextKit 2 glitches. if you know where to push button.

0:00

/0:14

 1× 

TextEdit and TextKit 2 glitches. if you know where to push button.

## So, so

Today, I believe that's not me. The TextKit 2 API and its implementation are lacking and unexpectedly difficult to use correctly. While the design is solid, it proved challenging to apply in real-world applications. I wish I had a better or more optimistic summary of my findings, but it is what it is. I've started to think that TextKit 2 might not be the best tool for text layout, especially when it comes to text editing UI. I remain open to suggestions, and hopefully, I will find a way to use TextKit 2 without compromising user experience.

SPONSORED

[![CTA Image](https://blog.krzyzanowskim.com/content/images/2025/08/notepadexe_promo_banner-1.png)](https://notepadexe.com/?ref=blog.krzyzanowskim.com)

[Get Notepad.exe](https://notepadexe.com/?ref=blog.krzyzanowskim.com)

[Back](https://blog.krzyzanowskim.com)

Back to top

*   #### [Marcin Krzyżanowski](https://blog.krzyzanowskim.com/author/krzyzanowskim)
    
*   ##### [http://krzyzanowskim.com](http://krzyzanowskim.com)
    

[Follow @krzyzanowskim](https://twitter.com/krzyzanowskim)

#### Share this:

[Twitter](https://twitter.com/share?text=TextKit 2 - the promised land&url=https://blog.krzyzanowskim.com/2025/08/14/textkit-2-the-promised-land/) [Facebook](https://www.facebook.com/sharer.php?u=https://blog.krzyzanowskim.com/2025/08/14/textkit-2-the-promised-land/) [Google+](https://plus.google.com/share?url=https://blog.krzyzanowskim.com/2025/08/14/textkit-2-the-promised-land/)

*   Subscribe![](https://blog.krzyzanowskim.com/rss/)
*   Twitter[](https://twitter.com/krzyzanowskim)
*   Github[](https://github.com/krzyzanowskim)
*   LinkedIn[](https://pl.linkedin.com/in/marcinkrzyzanowski)

* * *

All content copyright [Marcin Krzyżanowski](/) © 2014-2016 • All rights reserved.
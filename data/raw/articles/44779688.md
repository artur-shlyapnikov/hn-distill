Title: MCCC: Quasi-Monte Carlo

URL Source: https://thenumb.at/QMC/

Published Time: Sun, 03 Aug 2025 22:41:19 GMT

Markdown Content:
Monte Carlo Crash Course
------------------------

*   [Continuous Probability](https://thenumb.at/Probability)
*   [Exponentially Better Integration](https://thenumb.at/Monte-Carlo)
*   [Sampling](https://thenumb.at/Sampling)
*   [Case Study: Rendering](https://thenumb.at/Rendering)
*   **[Quasi-Monte Carlo](https://thenumb.at/QMC)**
*   _Coming Soon…_

* * *

We’ve learned how to define and apply Monte Carlo integration—fundamentally, it’s the only tool we need. In the remaining chapters, we’ll explore ways to reduce variance and successfully sample difficult distributions.

*   [Variance & Correlation](https://thenumb.at/QMC/#variance--correlation)
*   [Stratified Sampling](https://thenumb.at/QMC/#stratified-sampling)
*   [Adaptive Sampling](https://thenumb.at/QMC/#adaptive-sampling)
*   [Latin Hypercube](https://thenumb.at/QMC/#latin-hypercube)
*   [Quasi-Monte Carlo](https://thenumb.at/QMC/#quasi-monte-carlo-1)
*   [Low-Discrepancy Sequences](https://thenumb.at/QMC/#low-discrepancy-sequences)

Variance & Correlation
----------------------

In [chapter two](https://thenumb.at/Monte-Carlo/#escaping-the-curse), we determined that the variance of a Monte Carlo estimator is inversely proportional to its sample count. Empirically, we confirmed that our integrators’ expected error scaled with 1 N\frac{1}{\sqrt{N}} in any dimension.

Although dramatically faster than _exponential_, if we want a very accurate result, 1 N\frac{1}{\sqrt{N}} may still be too slow. In practice, we can only scale sample count quadratically so many times.

![Image 1](https://thenumb.at/QMC/error.svg)

We also assumed that our samples are independent, so their variance is additive. However, our proof that Monte Carlo integration is unbiased didn’t rely on independence—so what if we relaxed that assumption?

V a r[X+Y]=V a r[X]+V a r[Y]+2 C o v[X,Y]\begin{align*} \mathrm{Var}[X + Y] = \mathrm{Var}[X] + \mathrm{Var}[Y] + 2\mathrm{Cov}[X,Y] \end{align*}

If X X and Y Y are _negatively_ correlated, C o v[X,Y]<0\mathrm{Cov}[X,Y] < 0, decreasing the variance of X+Y X+Y. If we can assure that our samples are negatively correlated, our Monte Carlo estimator might converge faster than 1 N\frac{1}{\sqrt{N}}.

### Poisson Disk Sampling

Perceptually, negatively correlated samples look “more random” than uncorrelated samples.

![Image 2](https://thenumb.at/QMC/uncorrelated.svg)

![Image 3](https://thenumb.at/QMC/ncorrelated.svg)

That’s because uncorrelated samples often appear in clusters and may leave significant chunks of the domain entirely unsampled. Negative correlation causes the opposite behavior: the more samples an area contains, the less likely it is to be sampled, and vice versa.

So, how can we generate negatively correlated samples? One approach is rejection sampling: simply discard samples that fall too close to any previous sample. This algorithm is known as _Poisson disk sampling_.[1](https://thenumb.at/QMC/#fn:1)

Proposed:00 1 samples Accepted:00 1 samples\begin{align*} \text{Proposed} : \phantom{00}1\text{ samples} \\ \text{Accepted} : \phantom{00}1\text{ samples}\end{align*}

Poisson disk sampling is useful for pre-generating samples with a minimum separation distance, but isn’t always applicable to Monte Carlo integration, where we need a progressive sampler that eventually covers the entire domain.

Stratified Sampling
-------------------

If we don’t need a minimum separation distance, a faster way to generate negatively correlated samples is _stratified sampling_. Stratification will let us combine the strengths of [quadrature](https://thenumb.at/Monte-Carlo/#bias-and-consistency) and Monte Carlo integration.

Instead of generating N N independent samples of the entire domain, a stratified sampler partitions the domain into M M equal-sized regions and takes N M\frac{N}{M} independent samples of each one. Since no more than N M\frac{N}{M} samples can occur in any particular region, the samples are negatively correlated.[2](https://thenumb.at/QMC/#fn:2)

Let’s consider a Monte Carlo estimator that uses N N stratified samples of Ω\Omega. Grouping samples by region lets us rearrange the estimator into a collection of N M\frac{N}{M}-sample estimators for each region Ω m\Omega_m:

F Stratified=∑n=0 N f(Ω n)p(Ω n)=∑m=0 M∑n=0 N M f(Ω m,n)p(Ω m,n)=∑m=0 M F Ω m\begin{align*} F_\text{Stratified} &= \sum_{n=0}^N \frac{f(\Omega_n)}{p(\Omega_n)}\\ &= \sum_{m=0}^M \sum_{n=0}^\frac{N}{M} \frac{f(\Omega_{m,n})}{p(\Omega_{m,n})}\\ &= \sum_{m=0}^M F_{\Omega_m} \end{align*}

Intuitively, stratification partitions our integral across the regions Ω m\Omega_m and computes an independent N M\frac{N}{M}-sample estimate of each term. Hence, linearity of expectation implies that our stratified estimator is unbiased.

E[F Stratified]=E[F Ω 0+F Ω 1+…]=E[F Ω 0]+E[F Ω 1]+…=∫Ω 0 f(ω)d ω+∫Ω 1 f(ω)d ω+…=∫Ω f(ω)d ω\begin{align*} \mathbb{E}[F_\text{Stratified}] &= \mathbb{E}[F_{\Omega_0} + F_{\Omega_1} + \dots]\\ &= \mathbb{E}[F_{\Omega_0}] + \mathbb{E}[F_{\Omega_1}] + \dots\\ &= \int_{\Omega_0} f(\omega)\, d\omega + \int_{\Omega_1} f(\omega)\, d\omega + \dots\\ &= \int_\Omega f(\omega)\, d\omega \end{align*}

But did stratification reduce variance? Let’s try dividing our familiar circular estimator into M=64 M=64 regions:

∫Ω f(ω)d ω≈3.063\int_\Omega f(\omega)\, d\omega \approx 3.063

We’ll find that the stratified estimator has fairly low error, especially when N N is small.[3](https://thenumb.at/QMC/#fn:3)

Error=0.079\text{Error} =0.079

Precisely how much stratification decreases variance depends on the behavior of f f, but we may prove that stratification at least never _increases_ variance.

### Why Stratify?

Let’s compare an N N-sample uniform estimator on Ω\Omega against a stratified estimator that uniformly samples partitions A A and B B. Recalling [chapter two](https://thenumb.at/Monte-Carlo/#escaping-the-curse), we can compute these estimators’ variances:

V a r[F Uniform]=∣∣Ω∣2 N V a r[f(Ω)]V a r[F Stratified]=V a r[F A]+V a r[F B]=∣Ω∣2 2 N(∣V a r[f(A)]+V a r[f(B)])\begin{align*} \mathrm{Var}[F_\text{Uniform}] &= \vphantom{\Bigg|}\frac{|\Omega|^2}{N}\mathrm{Var}[f(\Omega)]\\ \mathrm{Var}[F_\text{Stratified}] &= \mathrm{Var}[F_A] + \mathrm{Var}[F_B] \tag{$F_A,F_B$ indep.}\\ &= \frac{|\Omega|^2}{2N}\left(\vphantom{\big|}\mathrm{Var}[f(A)]+\mathrm{Var}[f(B)]\right) \end{align*}

V a r[F Uniform]=∣∣Ω∣2 N V a r[f(Ω)]V a r[F Stratified]=V a r[F A]+V a r[F B]=∣Ω∣2 2 N(∣V a r[f(A)]+V a r[f(B)])\begin{align*} \mathrm{Var}[F_\text{Uniform}] &= \vphantom{\Bigg|}\frac{|\Omega|^2}{N}\mathrm{Var}[f(\Omega)]\\ \mathrm{Var}[F_\text{Stratified}] &= \mathrm{Var}[F_A] + \mathrm{Var}[F_B] \\&\tag{$F_A,F_B$ indep.}\\ &= \frac{|\Omega|^2}{2N}\left(\vphantom{\big|}\mathrm{Var}[f(A)]+\mathrm{Var}[f(B)]\right) \end{align*}

To relate these quantities, we may condition V a r[f(Ω)]\mathrm{Var}[f(\Omega)] on the sampled region. We will write μ X\mu_\mathcal{X} to denote the expected value E[f(X)]\mathbb{E}[f(\mathcal{X})].

V a r[f(Ω)]=V a r[f(Ω)∣A]⋅P{A}+V a r[f(Ω)∣B]⋅P{B}=1 2(E[(f(Ω)−μ Ω)2∣A]+E[(f(Ω)−μ Ω)2∣B])=1 2(E[f(A)]2+E[f(B)]2−2(μ A+μ B 2)2)=1 2(E[f(A)]2−μ A 2+E[f(B)]2−μ B 2+1 2(μ A 2−2 μ A μ B+μ B 2))=V a r[f(A)]+V a r[f(B)]2+(μ A−μ B)2 4≥V a r[f(A)]+V a r[f(B)]2\begin{align*} \mathrm{Var}[f(\Omega)] &= \mathrm{Var}[f(\Omega)\ |\ A]\cdot\mathbb{P}\{A\} + \mathrm{Var}[f(\Omega)\ |\ B]\cdot\mathbb{P}\{B\}\\ &= \frac{1}{2}\left(\mathbb{E}[(f(\Omega)-\mu_\Omega)^2\ |\ A] + \mathbb{E}[(f(\Omega)-\mu_\Omega)^2\ |\ B]\right)\\ &= \frac{1}{2}\left(\mathbb{E}[f(A)]^2+\mathbb{E}[f(B)]^2-2\left(\frac{\mu_A+\mu_B}{2}\right)^2\right)\\ &= \frac{1}{2}\left(\mathbb{E}[f(A)]^2-\mu_A^2+\mathbb{E}[f(B)]^2-\mu_B^2+\frac{1}{2}\left(\mu_A^2-2\mu_A\mu_B+\mu_B^2\right)\right)\\ &= \frac{\mathrm{Var}[f(A)]+\mathrm{Var}[f(B)]}{2}+\frac{(\mu_A-\mu_B)^2}{4}\\ &\ge \frac{\mathrm{Var}[f(A)]+\mathrm{Var}[f(B)]}{2}\\ \end{align*}

The squared term is never negative, so we know that V a r[f(A)]+V a r[f(B)]\mathrm{Var}[f(A)] + \mathrm{Var}[f(B)] is at most 2⋅V a r[f(Ω)]2\cdot\mathrm{Var}[f(\Omega)]. Hence, F Stratified F_\text{Stratified} cannot have higher variance than F Uniform F_\text{Uniform}, and has lower variance when μ A≠μ B\mu_A \neq \mu_B.

![Image 4](https://thenumb.at/QMC/avg.svg)

This result makes some intuitive sense—if f f has a different average on A A and B B, samples constrained to A A or B B must have locally lower variance than f f as a whole.

### Dynamic Stratification

So, should we be using stratified sampling everywhere? Often, yes—partitioning the domain can only reduce variance—but note that stratifying across a fixed 64 64 regions did not reduce variance _asymptotically_.

Even when f f is [sufficiently nice](https://en.wikipedia.org/wiki/Bounded_variation), stratification only reduces error in inverse proportion to the regions’ volume. In a d d-dimensional domain, we should expect our estimator to converge with the following expression:[4](https://thenumb.at/QMC/#fn:4)

![Image 5](https://thenumb.at/QMC/curse.svg)

σ Stratified∝1 N M d=N−1 2 M−1 d\begin{align*} \sigma_\text{Stratified} &\propto \frac{1}{\sqrt{N}\sqrt[d]{M}} \\ &= N^{-\frac{1}{2}}M^{-\frac{1}{d}} \end{align*}

That is, M M is subject to the [curse of dimensionality](https://thenumb.at/Monte-Carlo/#the-curse-of-dimensionality). Plus, we can’t use more regions than our sample count, so M≤N M \le N. Nonetheless, we can find an algorithmic improvement by dynamically scaling M∝N M \propto \sqrt{N}:[5](https://thenumb.at/QMC/#fn:5)

σ Stratified∝N−1 2 N−1 d=N−d+1 2 d\begin{align*} \sigma_\text{Stratified} &\propto N^{-\frac{1}{2}}{\sqrt{N}}^{-\frac{1}{d}} \\ &= N^{-\frac{d+1}{2d}} \end{align*}

In one dimension (d=1 d = 1), dynamic stratification produces σ∝N−1\sigma \propto N^{-1}. Back in [chapter two](https://thenumb.at/Monte-Carlo/#quadrature), we used quadrature to integrate x\sqrt{x} with error proportional to N−1 N^{-1}. Using dynamic stratification, we get an _unbiased_ estimator with the same convergence rate!

∫0 1 x d x≈0.655\int_0^1 \sqrt{x}\, dx \approx 0.655

In two dimensions, dynamic stratification results in σ∝N−3 4\sigma \propto N^{-\frac{3}{4}}, which converges faster than naive Monte Carlo, but in higher dimensions, we rapidly approach our existing result of σ∝N−1 2\sigma \propto N^{-\frac{1}{2}}. Hence, dynamic stratification is usually only worthwhile in a small number of dimensions.

Adaptive Sampling
-----------------

Another extension of stratified sampling is _adaptive sampling_. Instead of assigning the same number of samples to each region, adaptive sampling uses more samples in regions with higher variance.

Above, we determined that the variance of a stratified estimator is a weighted sum, where N A+N B=N N_A+N_B=N:

V a r[F Stratified]=V a r[F A]+V a r[F B]∝σ A 2 N A+σ B 2 N B\begin{align*} \mathrm{Var}[F_\text{Stratified}] &= \mathrm{Var}[F_A] + \mathrm{Var}[F_B]\\ &\propto \frac{\sigma_A^2}{N_A} + \frac{\sigma_B^2}{N_B} \end{align*}

We also assumed N A=N B N_A = N_B, but that wasn’t required to show that our stratified estimator was unbiased. So,if σ A 2>σ B 2\sigma_A^2>\sigma_B^2, using N A>N B N_A>N_B would decrease the total. To find the optimal sample distribution, we may minimize this sum using a [Lagrange multiplier](https://en.wikipedia.org/wiki/Lagrange_multiplier):

min⁡N A+N B=N{σ A 2 N A+σ B 2 N B}⟹{∂∂N A(σ A 2 N A+σ B 2 N B−λ(N A+N B−N))=0∂∂N B(σ A 2 N A+σ B 2 N B−λ(N A+N B−N))=0⟹N A=N⋅σ A σ A+σ B N B=N⋅σ B σ A+σ B\begin{align*} &&& \min_{N_A+N_B=N} \left\{\frac{\sigma_A^2}{N_A} + \frac{\sigma_B^2}{N_B}\right\}\\ &\implies&& \begin{cases} \frac{\partial}{\partial N_A}\left(\frac{\sigma_A^2}{N_A} + \frac{\sigma_B^2}{N_B} - \lambda(N_A+N_B-N)\right) = 0 \\ \frac{\partial}{\partial N_B}\left(\frac{\sigma_A^2}{N_A} + \frac{\sigma_B^2}{N_B} - \lambda(N_A+N_B-N)\right) = 0 \end{cases}\\ &\implies&& N_A = N\cdot\frac{\sigma_A}{\sigma_A+\sigma_B} \\ &&& N_B = N\cdot\frac{\sigma_B}{\sigma_A+\sigma_B} \tag{Algebra} \end{align*}

As you might expect, we should partition samples between F A F_A and F B F_B in proportion to their standard deviation. Let’s attempt to implement this improvement in our circular estimator. Intuitively, we should be able to ignore regions where f f is constant (i.e. F F has zero deviation):

![Image 6](https://thenumb.at/QMC/adapt.svg)

However, we can’t assume to know the standard deviation of each region beforehand, so we must estimate it during integration. To guide adaptive sampling, each region Ω m\Omega_m will track its sample count N m N_m, as well as estimates of E[f(Ω m)]\mathbb{E}[f(\Omega_m)] and E[f(Ω m)2]\mathbb{E}[f(\Omega_m)^2].[6](https://thenumb.at/QMC/#fn:6)

σ Ω m=V a r[F Ω m]=E[f(Ω m)2]−E[f(Ω m)]2 N m\begin{align*} \sigma_{\Omega_m} &= \sqrt{\mathrm{Var}[F_{\Omega_m}]} \\ &= \sqrt{\frac{\mathbb{E}[f(\Omega_m)^2] - \mathbb{E}[f(\Omega_m)]^2}{N_m}} \end{align*}

Unfortunately, this estimate can be very imprecise, so using it for adaptive sampling isn’t always easy. One approach is to randomly select the next region to sample weighted by estimated deviation (drawn in red):

∫Ω f(ω)d ω≈0.000\int_\Omega f(\omega)\, d\omega \approx 0.000

This strategy works, but even when a region has zero estimated deviation, we must choose it with non-zero probability, since the true value may not be zero. We can see this situation play out when our estimator discovers that a mostly-covered region actually has non-zero variance.

The core ideas of adaptive sampling and dynamic stratification—assigning samples where they’re needed and progressively refining the sampling pattern—can be combined to form the [multi-level Monte Carlo](https://en.wikipedia.org/wiki/Multilevel_Monte_Carlo_method) method, which we won’t explore in this chapter.

Latin Hypercube
---------------

Any way we slice it, stratified sampling will eventually run up against the curse of dimensionality. In practice, we may need computationally cheaper methods of generating negatively correlated samples. One such method is known as _Latin hypercube_ sampling.[7](https://thenumb.at/QMC/#fn:7)

Instead of attempting to distribute samples across an exponential number of regions, a Latin hypercube sampler stratifies each dimension _independently_. For example, in two dimensions, we start by generating two lists of one-dimensional samples stratified across D D regions:

![Image 7](https://thenumb.at/QMC/indep.svg)
We then shuffle x\mathbf{x} and y\mathbf{y}, randomizing their order. Finally, to produce samples of Ω\Omega, we simply take each pair (x i,y i)(\mathbf{x}_i,\mathbf{y}_i) from the shuffled lists.[8](https://thenumb.at/QMC/#fn:8) This procedure is typically performed in batches of D D samples.[9](https://thenumb.at/QMC/#fn:9)

Since we’re implicitly partitioning Ω\Omega into D d D^d regions, we can think of a Latin hypercube sampler as a sparse approximation of a stratified sampler over this much larger space. However, perfect stratification would require placing at most N D d\frac{N}{D^d} samples in each region, which our sampler does not achieve.

Given any particular region, we know exactly N D\frac{N}{D} samples have a matching position along each dimension, so up to N D\frac{N}{D} samples could occur in this region. This bound is exponentially weaker than full stratification, but still leads to negative correlation.

Note that regardless of correlation, Latin hypercube samples are uniform, and by similar logic as stratified sampling, may be used for Monte Carlo integration.

∫Ω f(ω)d ω≈2.500\int_\Omega f(\omega)\, d\omega \approx 2.500

In our circular estimator, we’ll find that Latin hypercube samples tend to reduce error at small N N, but they’re clearly less effective than stratified samples. Latin hypercube samples become more useful when full stratification is infeasible, e.g. in four or more dimensions.

Error=0.642\text{Error} =0.642

The Latin hypercube approach can also be combined with stratified sampling to create multi-level samplers, such as [correlated multi-jittered sampling](https://graphics.pixar.com/library/MultiJitteredSampling/paper.pdf).

Quasi-Monte Carlo
-----------------

All of the sampling algorithms we’ve examined so far are fundamentally random, but with additional restrictions that introduce negative correlation. Alternatively, if we’re willing to introduce [bias](https://thenumb.at/Monte-Carlo/#bias-and-consistency), we can do away with randomness entirely!

In [chapter three](https://thenumb.at/Sampling/#pseudo-random-numbers), we discussed pseudo-random number generators (PRNGs), which deterministically compute a sequence of samples that “look uniformly random.” Our only source of non-determinism was the seed: given the same initial state, a PRNG always produces the same sequence. Hence, for a **fixed seed**, a PRNG is just a particular sequence of numbers x i x_i—but we can still use it for Monte Carlo integration.

F QMC=1 N∑i=1 N f(x i) F_\text{QMC} = \frac{1}{N} \sum_{i=1}^N f(x_i)

The result is known as a _Quasi-Monte Carlo_ estimator.[10](https://thenumb.at/QMC/#fn:10) QMC estimators are [biased](https://thenumb.at/Monte-Carlo/#bias-and-consistency): they always return the same value, so averaging multiple runs does not increase accuracy. Fortunately, they are also [consistent](https://thenumb.at/Monte-Carlo/#bias-and-consistency): increasing the sample count N N causes the estimator to converge to the exact result.[11](https://thenumb.at/QMC/#fn:11)

![Image 8](https://thenumb.at/QMC/consistent.svg)

### Discrepancy

Empirically, we’ve already confirmed that QMC estimators are consistent—most of the interactive figures use a PRNG with a fixed seed. But what is it about pseudo-random sequences that make QMC work? Lacking the tools of probability, how can we relate the accuracy of an estimator to the quantity and quality of its samples?

This is the purpose of the _Koksma–Hlawka inequality_, which we will present without proof:

∣1 N∑i=1 N f(x i)−∫Ω f(ω)d ω∣≤V(f)D N∗(x 1,…,x N) \Bigg|\, \frac{1}{N}\sum_{i=1}^N f(x_i) - \int_\Omega f(\omega)\, d\omega\, \Bigg| \le V(f) D^*_N(x_1,\dots,x_N)

Here, x i x_i is our sample sequence, f f has [bounded variation](https://en.wikipedia.org/wiki/Bounded_variation)V(f)V(f), and D N∗D^*_N is the “star-discrepancy” of x x. Bounded variation is morally the same constraint that our Monte Carlo estimator for f f had finite variance.

Importantly, our estimator’s error is (at worst) proportional to this property D N∗D^*_N, which only depends on x x.

∣F QMC−∫Ω f(ω)d ω∣∝D N∗(x 1,…,x N) \bigg|\, F_\text{QMC} - \int_\Omega f(\omega)\, d\omega\, \bigg| \propto D^*_N(x_1,\dots,x_N)

Intuitively, we can think of star-discrepancy as a deterministic equivalent of negative correlation. Taking Ω\Omega to be the unit square, D N∗D^*_N is defined as the worst-case difference between the ratio of samples falling inside a rectangle R\mathcal{R} and the volume of R\mathcal{R}. R\mathcal{R} must also include the origin as its bottom-left corner.[12](https://thenumb.at/QMC/#fn:12)

D N∗(x 1,…,x N)=sup⁡R∈Ω∣Samples(R)N−∣∣R∣∣∣ D^*_N(x_1,\dots,x_N) = \sup_{\mathcal{R}\in\Omega} \Bigg|\, \frac{\text{Samples}(\mathcal{R})}{N} - ||\mathcal{R}|| \,\Bigg|

We can see that discrepancy penalizes regions that have more (or fewer) samples than they should:

![Image 9](https://thenumb.at/QMC/discrepancy.svg)

Uniformly random point sets—as well as those produced by PRNGs—have the property that D N∗D^*_N tends to zero with increasing sample count. Hence, using such sequences in a QMC estimator will cause it to converge for all f f with bounded variation.

Low-Discrepancy Sequences
-------------------------

To justify using a biased estimator, it should exhibit a faster convergence rate than unbiased alternatives. But simply fixing a PRNG seed surely doesn’t accelerate convergence, right? Indeed, in d d dimensions, the star-discrepancy of a uniformly random point set only converges with the following expression:

D N∗(Uniform)∝log⁡d N N D^*_N(\text{Uniform}) \propto \sqrt{\frac{\log^dN}{N}}

D N∗=0.000\begin{align*} D_N^* = 0.000\end{align*}

The Koksma–Hlawka inequality therefore doesn’t tell us anything—we already knew uniform Monte Carlo converges with 1 N\frac{1}{\sqrt{N}}. However, there’s no reason we have to use uniformly random points. Instead, we can make use of certain _low-discrepancy sequences_, which provide near-linear convergence.

D N∗(Low-Discrepancy)∝log⁡d N N D^*_N(\text{Low-Discrepancy}) \propto \frac{\log^dN}{N}

While this convergence rate is always asymptotically faster than 1 N\frac{1}{\sqrt{N}}, in high dimensions, the associated constant factor (which depends on d d) can still make the approach impractical.

### The Halton Sequence

There are many low-discrepancy sequences, each making use of different mathematical tools. One popular choice is the [Halton sequence](https://en.wikipedia.org/wiki/Halton_sequence). To compute a one-dimensional Halton sequence g b(n)g_b(n), first choose a base b b and find the base-b b digits of n n:

n=∑k Digit k(n)b k n = \sum_k \text{Digit}_k(n)b^k

Then mirror the digits about the decimal place. In base ten, we would have g 10(1234)=0.4321 g_{10}(1234) = 0.4321.

g b(n)=∑k Digit k(n)b−k−1 g_b(n) = \sum_k \text{Digit}_k(n)b^{-k-1}

This operation is also known as the _radical inverse_ Ψ b(n)\Psi_b(n). To create a d d-dimensional Halton sequence, simply join several one-dimensional sequences with co-prime bases b 1…b d b_1\dots b_d.

g(n)=(g b 1(n),…,g b d(n)) g(n) = (g_{b_1}(n),\dots,g_{b_d}(n))

Halton sequences exhibit star-discrepancy proportional to log⁡d N N\frac{\log^d N}{N}, but proving this result is beyond the scope of this chapter. Instead, let’s examine the two-dimensional (2,3)(2,3) Halton sequence:

D N∗=0.000\begin{align*} D_N^* = 0.000\end{align*}

Naturally, we can use Halton samples in our circular estimator:

∫Ω f(ω)d ω≈3.250\int_\Omega f(\omega)\, d\omega \approx 3.250

We’ll find that convergence is effectively linear, significantly outpacing our earlier estimators.[13](https://thenumb.at/QMC/#fn:13)

Error=0.108\text{Error} =0.108

Does this result imply we should abandon randomness and use low-discrepancy sequences for everything? In few dimensions, QMC can be ideal—but working with high-dimensional low-discrepancy sequences turns out to be difficult.

### Scrambling

By definition, a d d-dimensional Halton sequence uses d d different co-prime bases. To illustrate the difficulties encountered in higher dimensions, let’s consider only the points generated by bases 29 and 31.

g(n)=(…,g 29(n),g 31(n),…) g(n) = (\dots,g_{29}(n),g_{31}(n),\dots)

Note g 29(n),g 31(n)g_{29}(n),g_{31}(n) is also the projection of g(n)g(n) onto the corresponding axes. Although this sequence is still “low-discrepancy,” its absolute discrepancy starts out quite high:

D N∗=0.000\begin{align*} D_N^* = 0.000\end{align*}

Using sequences like (29,31)(29,31) in QMC estimators can be fraught, since reducing bias to an acceptable level requires many samples. This problem gets worse as we increase dimensionality.

Fortunately, there’s another technique (known as _scrambling_) that makes higher-dimensional bases significantly more usable. Scrambling introduces an extra step to the radical inverse:

g b(n)=∑k ρ(Digit k(n))b−k−1 g_b(n) = \sum_k \rho(\text{Digit}_k(n))b^{-k-1}

Where ρ\rho is a permutation of the digits 0…b 0\dots b, typically chosen randomly. Scrambling dramatically reduces discrepancy at low sample counts, making the resulting bias less objectionable.

D N∗=0.000\begin{align*} D_N^* = 0.000\end{align*}

The Halton sequence succinctly exemplifies the benefits and pitfalls of QMC, but it’s certainly not the only useful low-discrepancy sequence. In particular, [Sobol’ sequences](https://pbr-book.org/3ed-2018/Sampling_and_Reconstruction/(0,_2)-Sequence_Sampler) are widely used in practice, as they can achieve a kind of optimal discrepancy while admitting an efficient implementation.

* * *

Footnotes
---------

* * *

1.   Note checking for sample intersection can be done in constant time using a background grid. In fact, generating N N samples can be done in (more or less) [linear work](https://www.cs.ubc.ca/~rbridson/docs/bridson-siggraph07-poissondisk.pdf).[↩︎](https://thenumb.at/QMC/#fnref:1)

2.   Technically, sample i i is positively correlated with sample i+M i+M, but it’s negatively correlated with all of the samples in between, so the overall effect is negative.[↩︎](https://thenumb.at/QMC/#fnref:2)

3.   But not when N N is _too_ small: using fewer than M M samples would result in a biased estimate.[↩︎](https://thenumb.at/QMC/#fnref:3)

4.   Precisely explaining this point is beyond the scope of this chapter, but intuitively, if f f has bounded variation (and is not a constant), there’s some resolution at which f f must have a different average in different regions, and this resolution may be required along every dimension.[↩︎](https://thenumb.at/QMC/#fnref:4)

5.   To see why N\sqrt{N} is a good choice, compute the convergence rate for M=log⁡N M = \log N and M=N M = N.[↩︎](https://thenumb.at/QMC/#fnref:5)

6.   Also known as the first and second moments of f(Ω m)f(\Omega_m). Interestingly, in stochastic optimization problems (such as [inverse rendering](https://rgl.epfl.ch/publications)), the [Adam](https://arxiv.org/pdf/1412.6980) optimizer naturally estimates these moments, which can be used for adaptive sampling.[↩︎](https://thenumb.at/QMC/#fnref:6)

7.   In two dimensions, the Latin hypercube pattern is also known as _N-rooks_: if each batch of samples were rooks on a chessboard, they wouldn’t threaten each other.[↩︎](https://thenumb.at/QMC/#fnref:7)

8.   Joining one sample from each dimension can also be interpreted as picking a vertex of a dimension-d d length-N N lattice, leading to the “hypercube” name. The “Latin” part comes from [Latin squares](https://en.wikipedia.org/wiki/Latin_square).[↩︎](https://thenumb.at/QMC/#fnref:8)

9.   Allowing batch sizes linear in D D is another benefit of Latin hypercube sampling: for full stratification to be unbiased, we must use at least D d D^d samples, which may be infeasible in of itself.[↩︎](https://thenumb.at/QMC/#fnref:9)

10.   Technically, QMC also implies the use of a low-discrepancy sequence, since (outside of pedagogy) it’s not particularly useful to consider PRNG-based estimators part of the QMC framework.[↩︎](https://thenumb.at/QMC/#fnref:10)

11.   This distinction may sound academic, but it also has computational implications. To increase accuracy, we must use additional samples _from the same sequence_, so we can’t easily parallelize sample generation.[↩︎](https://thenumb.at/QMC/#fnref:11)

12.   In other words, D N∗D^*_N measures how well x i x_i integrates all possible rectangular indicator functions.[↩︎](https://thenumb.at/QMC/#fnref:12)

13.   These error plots should be log-log; they’re difficult to interpret otherwise. Maybe they will be someday.[↩︎](https://thenumb.at/QMC/#fnref:13)

Written on August 2, 2025
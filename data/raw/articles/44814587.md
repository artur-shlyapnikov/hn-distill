Consistency Over Availability: How rqlite handles the CAP Theorem – Vallified                         

       [Skip to content](#main)

 

No results

*   [About](https://philipotoole.com/about/)
*   [Popular Posts](https://philipotoole.com/popular/)
*   [Resume](https://philipotoole.com/resume/)
*   [Contact](https://philipotoole.com/contact/)

[Vallified](https://philipotoole.com/)

Philip O'Toole

*   [Popular Posts](https://philipotoole.com/popular/)
    *   [How rqlite is tested](https://philipotoole.com/how-is-rqlite-tested/)
    *   [How I found a bug in SQLite](https://philipotoole.com/how-i-found-a-bug-in-sqlite/)
    *   [The strange economics of open-source software](https://philipotoole.com/the-strange-economics-of-open-source-software/)
    *   [What new development managers should know](https://philipotoole.com/lessons-for-new-development-managers/)
    *   [Software development: it’s got nothing to do with computers](https://philipotoole.com/software-development-got-nothing-computers/)
    *   [7 years of open-source database development: lessons learned](https://philipotoole.com/7-years-of-open-source-database-development-lessons-learned/)
    *   [What I learned from programming databases](https://philipotoole.com/what-i-learned-from-programming-a-database/)
    *   [Coding like it’s 1999](https://philipotoole.com/coding-like-its-1999/)
    *   [400 days of Go](https://philipotoole.com/400-days-of-go/)
    *   [Is node.js just a stopgap?](https://philipotoole.com/is-node-js-just-a-stopgap/)
    *   [Replicating SQLite using Raft Consensus](https://philipotoole.com/replicating-sqlite-using-raft-consensus/)

*   [About](https://philipotoole.com/about/)
*   [Resume](https://philipotoole.com/resume/)
*   [Contact](https://philipotoole.com/contact/)

Search

[Vallified](https://philipotoole.com/)

Philip O'Toole

Menu

# Consistency Over Availability: How rqlite handles the CAP Theorem

*   [![Philip O'Toole](https://secure.gravatar.com/avatar/a1c9c248eeb5239c162a6a32c420209af702076cd0ed07d6ddbe00c269021a98?s=50&d=identicon&r=g)](https://philipotoole.com/author/admin/)[Philip O'Toole](https://philipotoole.com/author/admin/ "Posts by Philip O'Toole")
*   August 6, 2025
*   [Uncategorized](https://philipotoole.com/category/uncategorized/)

[rqlite](https://rqlite.io/)[![](https://philipotoole.com/wp-content/uploads/2019/03/distrib-system-150x150.png)](https://rqlite.io/) is a lightweight, user-friendly, open-source, distributed relational database. It’s written in [Go](https://go.dev/) and uses [SQLite](https://sqlite.org/) as its storage engine.

When it comes to distributed systems the [CAP theorem](https://www.ibm.com/think/topics/cap-theorem) is an essential concept. It states that it’s impossible for a distributed database to simultaneously provide **C**onsistency, **A**vailability, and **P**artition tolerance. The challenge is in the face of a network partition, a database can only be available or consistent, but not both.

Let’s take a look at the CAP theorem and see how rqlite fits into this fundamental trade-off.

### **Understanding Consistency, Availability, and Partition Tolerance**

*   **Consistency (C):** A consistent system ensures that all nodes in a distributed cluster have the same data — or network access to the same data — at the same time. This means any read request will return the most recently written data.
*   **Availability (A):** An available system ensures that every request receives a response, regardless of network issues. The system continues to operate even if some nodes are unreachable. But there’s no guarantee that any read request will return to most recent data, nor is any write request guaranteed to be reflected in a subsequent read.
*   **Partition tolerance (P):** A partition-tolerant system continues to function even when network failures partition the system into isolated groups of nodes.

When [a network partition occurs](https://youtu.be/8XbxQ1Epi5w?t=287), a choice must be made. Do you prioritize consistency by not responding to requests on the “bad” side of the partition, or do you prioritize availability by continuing to serve requests, even if it means potentially serving stale data? This is the core trade-off between **CP** and **AP**.

### **CP vs. AP Systems**

![](https://philipotoole.com/wp-content/uploads/2025/08/L9W8pinRecouZcj-150x150.png?crop=1)A **CP** (Consistency-Partition tolerant) system prioritizes consistency. If a network partition occurs, the system will block writes on the minority side of the cluster to prevent data inconsistencies. This ensures that any data written is consistent, and when the partition is resolved, the system synchronizes without conflicts.

An **AP** (Availability-Partition tolerant) system prioritizes availability. It continues to accept write requests on both sides of a partition, even though it risks data divergence. After the partition is healed, the system must deal with potentially conflicting data.

### **Where rqlite Fits: A CP System**

rqlite is a **CP system**. It’s built on the [Raft consensus protocol](https://raft.github.io/), which inherently prioritizes consistency. If a network partition occurs, an rqlite cluster will remain available only on the side of the partition that contains a **majority of nodes**. The other side — **by default** —  will stop accepting requests.

This design guarantees that any data written to the majority side remains consistent across all available nodes. Once the network partition is resolved, the minority nodes are updated, and the cluster resumes normal, consistent operation. This CP approach ensures data correctness and integrity, making rqlite an important tool for applications where data consistency is a core requirement.

### Read Consistency: Beyond the CAP Theorem

While rqlite is fundamentally a CP system, it gives you fine-grained control over the **C** and **A** trade-off through its [selectable read consistency levels](https://rqlite.io/docs/api/read-consistency/): **weak**, **linearizable**, **strong**, and **none**. These levels allow you to balance performance with data correctness, and choose the best trade-off for your application. You can even choose your consistency level on a per-read-request basis, allowing you to fine-tune consistency to meet application needs.

#### Weak: Great but not Perfect

**Weak** consistency is rqlite’s default and is typically the right choice for most applications. With _weak consistency_ a node receiving a read request checks if it’s the leader — **but only by checking local state** —  and, if it is the leader, reads its local SQLite database. If the node is not the leader it will transparently forward the request to the leader, waiting for the response before returning to the client. The end result is very fast reads, almost always perfectly consistent.

However, with weak consistency, there is a very small window of time where a node may think it’s the leader after it’s been deposed, and a write has taken place, potentially resulting in a stale read. While this risk is minimal in a stable cluster, it’s an important consideration. Interestingly this was [one of the very first issues fixed in rqlite](https://github.com/rqlite/rqlite/issues/5).

#### Strong: A Testing Tool, Not for Production

**Strong** consistency provides the highest level of data freshness by sending the read request through the Raft log itself. This ensures all committed entries are applied before the read is executed. While this removes any doubt about data staleness — every write to the database is guaranteed to precede the read — it comes with a significant performance penalty, making it generally unsuitable for production use. It is primarily useful for certain testing scenarios, and its use is a [key pattern in the rqlite test suite](https://philipotoole.com/how-is-rqlite-tested/).

#### Linearizable: The Best of Both Worlds

[![](https://philipotoole.com/wp-content/uploads/2024/10/linearizable-query-performance-300x186.png)](https://philipotoole.com/faster-reads-same-guarantees-linearizable-consistency-in-rqlite-8-32/linearizable-query-performance/)For applications where up-to-date data is critical but the performance cost of `strong` consistency is too high, _[**linearizable**](https://philipotoole.com/faster-reads-same-guarantees-linearizable-consistency-in-rqlite-8-32/)_ reads are the answer. This method (described in [section 8 of the Raft paper](https://raft.github.io/raft.pdf)) ensures that the data returned is absolutely current by having the leader first confirm its status with a quorum of followers. This provides the same strong consistency guarantees as `strong` reads but with significantly less latency, making it the ideal solution for both performance and data correctness.

#### None: Max Speed, (Almost) Zero Guarantees

With **none** consistency, the node receiving the read request simply queries its local SQLite database without any Leadership or cluster-connection checks. This is the fastest possible read, but there are no guarantees about the data’s freshness. The node could be completely disconnected from the rest of the cluster and still serve the request. This level is particularly effective when used with [read-only nodes](https://rqlite.io/docs/clustering/read-only-nodes/), where you can combine it with `freshness` parameters to add a layer of safety, ensuring a node hasn’t been out of contact with the leader for too long.

### Next Steps

Hopefully this post helped you understand the connection between the CAP Theorem and rqlite. To learn more about rqlite guarantees and Read Consistency levels and how to use them in your projects, visit the rqlite [documentation](https://rqlite.io/docs/) or join the discussion in our [Slack channel](https://www.rqlite.io/join-slack).

Tags

[# database](https://philipotoole.com/tag/database/)[# distributed systems](https://philipotoole.com/tag/distributed-systems/)[# raft](https://philipotoole.com/tag/raft/)[# rqlite](https://philipotoole.com/tag/rqlite/)

[ai](https://philipotoole.com/tag/ai/) [aws](https://philipotoole.com/tag/aws/) [bleve](https://philipotoole.com/tag/bleve/) [book review](https://philipotoole.com/tag/book-review/) [C++](https://philipotoole.com/tag/c/) [cassandra](https://philipotoole.com/tag/cassandra/) [chatgpt](https://philipotoole.com/tag/chatgpt/) [cloud](https://philipotoole.com/tag/cloud/) [conference](https://philipotoole.com/tag/conference/) [database](https://philipotoole.com/tag/database/) [design](https://philipotoole.com/tag/design/) [distributed systems](https://philipotoole.com/tag/distributed-systems/) [docker](https://philipotoole.com/tag/docker/) [ec2](https://philipotoole.com/tag/ec2/) [ekanite](https://philipotoole.com/tag/ekanite/) [elasticsearch](https://philipotoole.com/tag/elasticsearch/) [go](https://philipotoole.com/tag/go/) [google](https://philipotoole.com/tag/google/) [hashicorp](https://philipotoole.com/tag/hashicorp/) [influxdb](https://philipotoole.com/tag/influxdb/) [java](https://philipotoole.com/tag/java/) [kafka](https://philipotoole.com/tag/kafka/) [kubernetes](https://philipotoole.com/tag/kubernetes/) [leadership](https://philipotoole.com/tag/leadership/) [linux](https://philipotoole.com/tag/linux/) [logs](https://philipotoole.com/tag/logs/) [meetups](https://philipotoole.com/tag/meetups/) [node.js](https://philipotoole.com/tag/node-js/) [open-source](https://philipotoole.com/tag/open-source/) [operations](https://philipotoole.com/tag/operations/) [percolate](https://philipotoole.com/tag/percolate/) [podcast](https://philipotoole.com/tag/podcast/) [programming](https://philipotoole.com/tag/programming/) [python](https://philipotoole.com/tag/python/) [quality](https://philipotoole.com/tag/quality/) [raft](https://philipotoole.com/tag/raft/) [rqlite](https://philipotoole.com/tag/rqlite/) [search](https://philipotoole.com/tag/search/) [speaking](https://philipotoole.com/tag/speaking/) [sqlite](https://philipotoole.com/tag/sqlite/) [storm](https://philipotoole.com/tag/storm/) [syslog](https://philipotoole.com/tag/syslog/) [time-series](https://philipotoole.com/tag/time-series/) [video](https://philipotoole.com/tag/video/) [whitepaper](https://philipotoole.com/tag/whitepaper/)

## Leave a Reply[Cancel Reply](/consistency-over-availability-how-rqlite-handles-the-cap-theorem/#respond)

Your email address will not be published. Required fields are marked \*

Name  **\*** 

Email  **\*** 

Website 

Add Comment **\***

Save my name, email, and website in this browser for the next time I comment.

Post Comment  

Δ

Copyright © 2025 Philip O'Toole
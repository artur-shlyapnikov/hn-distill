We Keep Reinventing CSS, but Styling Was Never the Problem — Den Odell   

[![Den Odell logo](/images/logo.avif)](/)

[Journal](/blog) [About](/about) [Books](/books) [Contact](/contact)

 [![Connect on LinkedIn](/images/icons/linked-in.png)](https://www.linkedin.com/in/denodell)[![Connect on GitHub](/images/icons/github.svg)](https://www.github.com/denodell)

 ![A tangled web of wires labelled with different CSS approaches.](/_astro/we-keep-reinventing-css.CfRDnokh_Z2u6Ece.png)

# We Keep Reinventing CSS, but Styling Was Never the Problem

![Den Odell](/_astro/denodell.DblG8bvx_1GVhbp.webp)

Den Odell 6 August 2025 · ⏱️ 3 min read

We’ve been building for the web for decades. CSS has had time to grow up, and in many ways, it has. We’ve got scoped styles, design tokens, cascade layers, even utility-first frameworks that promise to eliminate bikeshedding entirely.

And yet, somehow, every new project still begins with a shrug and the same old question:  
**“So… how are we styling things this time?”**

It’s not that we lack options. It’s that every option comes with trade-offs. None of them quite fit.  
We keep reinventing CSS as if it’s the root cause.  
_It isn’t._

* * *

### CSS Wasn’t Made for This

It’s easy to forget what CSS was originally designed for: documents. You’d write some HTML, style a few headings and paragraphs, maybe float an image to the left, and call it a day. In that world, global styles made sense. The cascade was helpful. Inheritance was elegant.

Fast-forward a couple of decades and we’re building highly interactive, component-based, state-driven, design-system-heavy applications, still with a language meant to style a résumé in the early 2000s.

CSS wasn’t built for encapsulated components. It wasn’t built for dynamic theming or runtime configuration or hydration mismatches. So we’ve spent years bolting on strategies to make it work.

### Every Option Solves One Problem. None Solve All of Them.

What we have now is a landscape of trade-offs.

*   [**BEM**](https://getbem.com) gives you naming predictability, and very verbose selectors.
*   [**CSS Modules**](https://github.com/css-modules/css-modules) give you scoping, unless you need [runtime theming](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_cascading_variables/Using_CSS_custom_properties).
*   **Utility-first CSS** (like [Tailwind](https://tailwindcss.com)) enables fast iteration, but clutters your markup.
*   [**CSS-in-JS**](https://en.wikipedia.org/wiki/CSS-in-JS) offers colocation and flexibility, at the cost of runtime performance and complexity.
*   **[Cascade Layers](https://css-tricks.com/css-cascade-layers/) and [`:where()`](https://developer.mozilla.org/en-US/docs/Web/CSS/:where)** give you more control, if your team is ready to learn them.

Each approach solves something. None solve everything. Yet we keep framing them as silver bullets, not as trade-off tools.

### Maybe It’s Not CSS That’s the Problem

Here’s the uncomfortable truth: _most of our styling pain doesn’t come from CSS itself_.  
It comes from trying to shoehorn CSS into frontend architectures that weren’t designed to support it.

[React](https://react.dev), [Vue](https://vuejs.org), [Svelte](https://svelte.dev). They all put components at the core. Scoped logic. Scoped templates. Scoped state. Then we hand them a stylesheet that’s global, cascading, and inherited by default.

We’ve spent the last decade asking CSS to behave like a module system. It isn’t one.

### The Real Question: Which Pain Are You Willing to Accept?

This isn’t just a tooling choice.  
It’s a question of what trade-offs you’re prepared to live with.

Do you want:

*   Scoped styles with minimal tooling? Use CSS Modules and accept limited runtime flexibility.
*   Predictability and no cascade? Use utility-first CSS and brace for cluttered markup.
*   Dynamic styles colocated with logic? Use CSS-in-JS and monitor your bundle size closely.

There’s no single solution. Just strategies. Just context.

### Accept the Mess. Choose With Your Eyes Open.

Styling the web isn’t solved. It may never be. But it gets easier when we stop pretending there’s a perfect answer just one abstraction away.

Be clear about what matters, and deliberate about what you’re willing to trade.

Because at the end of the day, no one writes perfect CSS.  
_Just CSS that’s good enough to ship._

* * *

💬 Comments? [Join the discussion on Dev.to →](https://dev.to/denodell/we-keep-reinventing-css-but-styling-was-never-the-problem-2e7p#comments)

🔗 Share: [Twitter/X](https://x.com/intent/tweet?url=https://denodell.com/blog/we-keep-reinventing-css?utm_source=twitter&utm_medium=share_button&utm_campaign=keep_reinventing_css_post) · [LinkedIn](https://www.linkedin.com/sharing/share-offsite/?url=https://denodell.com/blog/we-keep-reinventing-css?utm_source=linkedin&utm_medium=share_button&utm_campaign=keep_reinventing_css_post) · Copy link 

* * *

## Related Posts

*    [![Table-based layout structures](/_astro/hacking-layout-before-css-existed.zxNPI2on_Z18oGa1.png)](/blog/hacking-layout-before-css-existed)
    
    [Hacking Layout Before CSS Even Existed](/blog/hacking-layout-before-css-existed) 11 June 2025
    
    The early web had no layout system. No CSS. So we improvised, slicing, stretching, and nesting our way to structure.
    
    [Read more →](/blog/hacking-layout-before-css-existed)
    
*    [![Developer facing off against a robot against a screen of code.](/_astro/ai-is-just-the-latest-frontend-killer.CuGW2uQ2_Z1CVKeW.png)](/blog/ai-is-just-the-latest-frontend-killer)
    
    [AI Is Just the Latest Frontend Killer. Don’t Panic.](/blog/ai-is-just-the-latest-frontend-killer) 9 July 2025
    
    Apparently, frontend developers are about to be made obsolete. This all sounds very familiar.
    
    [Read more →](/blog/ai-is-just-the-latest-frontend-killer)
    

## Enjoyed this? Get more like it to your inbox.

No spam. Just occasional deep dives on frontend engineering and developer experience.

 

© 2025 Den Odell  
Built using [Astro](https://astro.build) & [Tailwind CSS](https://tailwindcss.com)
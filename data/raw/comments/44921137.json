[
  {
    "id": 44922958,
    "by": "alixanderwang",
    "timeISO": "2025-08-16T12:55:02.000Z",
    "textPlain": "> I’m often alone on this. Engineers look at complex systems with many interesting parts and think “wow, a lot of system design is happening here!” In fact, a complex system usually reflects an absence of good design.For any job-hunters, it's important you forget this during interviews.In the past I've made the mistake of trying to convey this in system design interviews.Some hypothetical startup app> Interviewer: \"Well what about backpressure?\">\"That's not really worth considering for this amount of QPS\"> Interviewer: \"Why wouldn't you use a queue here instead of a cron job?\"> \"I don't think it's necessary for what this app is, but here's the tradeoffs.\"> Interviewer: \"How would you choose between sql and nosql db?\"> \"Doesn't matter much. Whatever the team has most expertise in\"These are not the answers they're looking for. You want to fill the whiteboard with boxes and arrows until it looks like you've got Kubernetes managing your Kubernetes.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922384,
    "by": "motorest",
    "timeISO": "2025-08-16T11:44:52.000Z",
    "textPlain": "What a great article. It's always a treat to read this sort of take.I have some remarks though. Taken from the article:> Avoid having five different services all write to the same table. Instead, have four of them send API requests (or emit events) to the first service, and keep the writing logic in that one service.This is not so cut-and-dry. The trade offs are far from obvious or acceptable.If the five services access the database then you are designing a distributed system where the interface being consumed is the database, which you do not need to design or implement, and already supports authorization and access controls out of the box, and you have out-of-the-box support for transactions and custom queries. On the other hand, if you design one service as a high-level interface over a database then you need to implement and manage your own custom interface with your own custom access controls and constrains, and you need to design and implement yourself how to handle transactions and compensation strategies.And what exactly do you buy yourself? More failure modes and a higher micro services tax?Additionally, having five services accessing the same database is a code smell. Odds are that database fused together two or three separate databases. This happens a lot, as most services grow by accretion and adding one more table to a database gets far less resistance than proposing creating an entire new persistence service. And is it possible that those five separate services are actually just one or two services?",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921359,
    "by": "bambax",
    "timeISO": "2025-08-16T08:22:33.000Z",
    "textPlain": "> When querying the database, query the database. It’s almost always more efficient to get the database to do the work than to do it yourself. For instance, if you need data from multiple tables, JOIN them instead of making separate queries and stitching them together in-memory.Oh yes! Never do a join in the application code! But also: use views! (and stored procedures if you can). A view is an abstraction about the underlying data, it's functional by nature, unlikely to break for random reasons in the future, and if done well the underlying SQL code is surprisingly readable and easy to reason about.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44926522,
    "by": "rawgabbit",
    "timeISO": "2025-08-16T20:08:24.000Z",
    "textPlain": "I wonder why the author views CQRS negatively and then later gives this classic CQRS advice:      >What this means in practice is having one service that knows about the state - i.e. it talks to a database - and other services that do stateless things. Avoid having five different services all write to the same table. Instead, have four of them send API requests (or emit events) to the first service, and keep the writing logic in that one service.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922259,
    "by": "nvarsj",
    "timeISO": "2025-08-16T11:20:26.000Z",
    "textPlain": "> Paradoxically, good design is self-effacing: bad design is often more impressive than good.Rings very true. Engineers are rated based on the \"complexity\" of the work they do. This system seems to encourage over-engineered solutions to all problems.I don't think there is enough appreciation for KISS - which I first learned about as an undergrad 20 years ago.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922903,
    "by": "msiyer",
    "timeISO": "2025-08-16T12:48:46.000Z",
    "textPlain": "> Avoid having five different services all write to the same table. Instead, have four of them send API requests (or emit events) to the first service, and keep the writing logic in that one service.The ideal solution: Avoid having five different services all write to the same table.If five different services have to write to the same table, there is a major overlap of logic too. Are the five services really different or one would suffice?Taking practical realities into consideration, we can do what the author says. However, we risk implementing a lot of orchestration logic. We introduce a whole new layer of problems. Is that time not better spent refactoring the services: either give them their own DB tables or merge them into one servic?",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921601,
    "by": "KronisLV",
    "timeISO": "2025-08-16T09:06:18.000Z",
    "textPlain": "> Schema design should be flexible, because once you have thousands or millions of records, it can be an enormous pain to change the schema. However, if you make it too flexible (e.g. by sticking everything in a “value” JSON column, or using “keys” and “values” tables to track arbitrary data) you load a ton of complexity into the application code (and likely buy some very awkward performance constraints). Drawing the line here is a judgment call and depends on specifics, but in general I aim to have my tables be human-readable: you should be able to go through the database schema and get a rough idea of what the application is storing and why.I’m surprised that the drawbacks of EAV or just using JSON in your relational database don’t get called out more.I’d very much rather have like 20 tables with clear purpose than seeing that colleagues have once more created a “classifier” mechanism and are using polymorphic links (without actual foreign keys, columns like “section” and “entity_id”) and are treating it as a grab bag of stuff. One that you also need to read the application code a bunch to even hope to understand.Whenever I see that, I want to change careers. I get that EAV has its use cases, but in most other cases fuck EAV.It’s right up there with N+1 issues, complex dynamically generated SQL when views would suffice and also storing audit data in the same DB and it inevitably having functionality written against it, your audit data becoming a part of the business logic. Oh and also shared database instances and not having the ability to easily bootstrap your own, oh and also working with Oracle in general. And also putting things that’d be better off in the app inside of the DB and vice versa.There are so many ways to decrease your quality of life when it comes to storing and accessing data.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44926391,
    "by": "axpy906",
    "timeISO": "2025-08-16T19:46:31.000Z",
    "textPlain": "It’s under appreciated how many of us fall for over engineering. I’ve been there. Just the other day I had coworker suggest that our startup not use cloud blob storage because it’s unreliable and we should build our own.Maybe it’s just harder to design with something simple that is possible to extend and build on. Maybe I am missing something. That said I agree with the author from my decade of experience.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44926160,
    "by": "UncleFullstack",
    "timeISO": "2025-08-16T19:15:46.000Z",
    "textPlain": "It can be kind of horrifying at times. A couple of years ago I was interviewing for work and ended up talking to a big liquor distributor - their challenge was dealing with a bunch of text files over FTP, and it was comically bad, they had a $300k annual spend on AWS, Kubernetes, the works. And they could have done the whole thing  on a single EC2 instance with a couple of shell scripts. Needless to say I was laughed out of the room.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44926483,
    "by": "YZF",
    "timeISO": "2025-08-16T20:01:40.000Z",
    "textPlain": "It seems that there is no appreciation of a good architecture/system design any more. Nobody cares.Leadership can't tell the difference. If anything the worse designs seem more impressive. Engineers often enjoy a bad design because it creates more work and job security. When there's a lot of work it seems like you're getting things done. Managers enjoy a bad design because it helps empire building, now that there is more work we need to hire more people and do more manager-y things. There are also a lot of inexperienced engineers in the work force who have never seen a well designed system.In an organization running these badly designed system it's a political suicide to argue the design is bad. If the business is successful even more so because everyone will assume that a successful business means well designed software. A successful business will directly reward a bad design.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923630,
    "by": "feyman_r",
    "timeISO": "2025-08-16T14:13:50.000Z",
    "textPlain": "If you want to learn more about good system design at an abstract level (not just online), cannot recommend Systemantics[1] by John Gall enough. I wish all engineers get an opportunity to read it.[1] https://en.m.wikipedia.org/wiki/Systemantics",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921354,
    "by": "ZYbCRq22HbJ2y7",
    "timeISO": "2025-08-16T08:21:50.000Z",
    "textPlain": "> You’re supposed to store timestamps instead, and treat the presence of a timestamp as true. I do this sometimes but not always - in my view there’s some value in keeping a database schema immediately-readable.Seems overly negative of broad advice on a good pattern?    is_on => true\n    on_at => 1023030\n\nSure, that makes sense.     is_a_bear => true\n     a_bear_at => 12312231231\n\nNot so much, as most bears do not become bears at some point after not being a bear.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921252,
    "by": "com",
    "timeISO": "2025-08-16T08:01:37.000Z",
    "textPlain": "The advice about logging and metrics was good.I had been nodding away about state and push/pull, but this section grabbed my attention, since I’ve never seen it do clearly articulated before.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921254,
    "by": "bravesoul2",
    "timeISO": "2025-08-16T08:02:36.000Z",
    "textPlain": "He doesnt seem to mention Conway or team topology which is an important part of system design too.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921584,
    "by": "tetha",
    "timeISO": "2025-08-16T09:02:50.000Z",
    "textPlain": "The distinction of stateful and stateless is one of the main criteria how we're dividing responsibilities between platform-infra and development.I know it's a bit untrue, but you can't do that many things wrong with a stateless application running in a container. And often the answer is \"kill it and deploy it again\". As long as you don't shred your dataset with a bad migration or some bad database code, most bad things at this level can be fixed in a few minutes with a few redeployments.I'm fine having a larger amount of people with a varying degree of experience, time for this, care and diligence working here.With a persistence like a database or a file store, you need some degree of experience of what you have to do around the system so it doesn't become a business risk. Put plainly, a database could be a massive business risk even if it is working perfectly... because no one set backups up.That's why our storages are run by dedicated people who have been doing this for years and years. A bad database loss easily sinks ships.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44925453,
    "by": "maest",
    "timeISO": "2025-08-16T17:43:38.000Z",
    "textPlain": "> But in most cases replication lag can be worked around with simple tricks: for instance, when you update a record but need to use it right after, you can fill in the updated details in-memory instead of immediately re-reading after a write.I get it, but that sounds very finicky code to get right and a good source of hard-to-debug bugs.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922293,
    "by": "thisbeensaid",
    "timeISO": "2025-08-16T11:27:26.000Z",
    "textPlain": "Since the author praises proper use of databases and talks about event bus, background jobs and caching, I highly recommend to check out https://dbos.dev if you have Python or TypeScript backends. DBOS nicely solves common challenges in simple and complex systems and can eliminate the need for running separate services such as Kafka, Redis or Celery. The best: DBOS can be used as a dependency and doesn't require deploying a separate service.Very recently discussed here a week ago: https://news.ycombinator.com/item?id=44840693",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923059,
    "by": "hks0",
    "timeISO": "2025-08-16T13:06:59.000Z",
    "textPlain": "The article starts by criticizing generic rules that come without any context:> Even good system design advice can be kind of bad. I love Designing Data-Intensive Applications, but I don’t think it’s particularly useful for most system design problems engineers will run into.But continues to do the same throughout the rest of its advices. It also says:> ... Drawing the line here is a judgment call and depends on specifics,And immediately mentions:> but in general I aim to have my tables be human-readable ...Which to me reads as \"I'm going to ignore the difference of the context everywhere and instead apply mine for everyone, and I'm going to assume most of the wolrd face the same problems as me\". It's even worse than the book being criticized in the beginning, as the book at least has \"Data-Intensive\" in its title.This is quiet easily fixable. The author can describe the typical scenario they are working with on a day-to-day basis. Do they work with 10 users a day? 100? 10,000,000? What is the traffic? How many engineers? What's the situation of the team/company; do FIXMEs turn into fixes or they become it's a feature? And so on.In the end, without setting a baseline, a lot of engineers will start pointing fingers at each other dismissing the opposite ideas because it doesn't fit their situation. The reasoning might be true, but before that, it is \"irrelevant\", hence any opposition to or defending of it.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923105,
    "by": "lutzh",
    "timeISO": "2025-08-16T13:12:25.000Z",
    "textPlain": "The only thing I know about “good system design” is that it doesn’t exist in the abstract. Asking whether an architecture is good or bad is the wrong question. The real question is: Is it fit for purpose? Does it help you achieve what you actually need to achieve?I could nitpick individual points in the article, but that misses the bigger issue: the premise is off.Don’t chase generic advice about good or bad design. First understand your requirements, then design a system that meets them.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924779,
    "by": "gmm1990",
    "timeISO": "2025-08-16T16:22:32.000Z",
    "textPlain": "I seem to gravitate towards nosql type databases, defining tables in a ddl and then again in the code seems repetitive, and slows down changes. But the idea would be that the code is what defines the table. It'd be nice though to hear some of the drawbacks of this. Maybe for very relational things it makes sense to be able to write join queries so data is completely repeated, but my understanding would be that most data base engines would already compress that repeated info pretty well.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44925452,
    "by": "hn8726",
    "timeISO": "2025-08-16T17:43:32.000Z",
    "textPlain": "What's the best resource to learn those things in practice? Other than _just trying_ yourself? I'm a senior dev in another area who wants to get into the backend development, but unsurprisingly has limited time to spend on learning a completely new thing,",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921824,
    "by": "pelagicAustral",
    "timeISO": "2025-08-16T09:50:11.000Z",
    "textPlain": "I can definitely feel the \"underwhelming\" factor. I've been working for  +10 years on government software and I really know what an underwhelming codebase looks like, first off, it has my fucking name on it.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922886,
    "by": "codr7",
    "timeISO": "2025-08-16T12:46:59.000Z",
    "textPlain": "Replacing booleans with timestamps might be a good idea sometimes, presenting it as The Solution isn't very constructive imo.Adding a separate table where the presence of a record means 'true' allows recording related state without complicating the main table.And sometimes a boolean is exactly what you want.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923896,
    "by": "agentultra",
    "timeISO": "2025-08-16T14:44:01.000Z",
    "textPlain": "Great article. A lot of very standard practices. Or at least… should be.One thing that I often add is the people interacting with the system. They’re a part of it too. Most people don’t operate in an atomically consistent world; a lot of business processes are eventually consistent. But you do need to know where you have to have atomic operations! It depends on where the user expects it.Systems thinking is very useful. From how your software is deployed to how the people using it in their work. Always be thinking about these things.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921325,
    "by": "magnio",
    "timeISO": "2025-08-16T08:16:01.000Z",
    "textPlain": "I think it's a very good article. Even if you disagree with some of the individual points in it, the advice given are very concrete, pragmatic, and IMO tunable to the specifics of each project.On state, in my current project, it is not statefulness that causes trouble, but when you need to synchronize two stateful systems. Every time there's bidirectional information flow, it's gonna be a headache. The solution is of course to maintain a single source of truth, but with UI application this is sometimes quite tricky.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924885,
    "by": "0wis",
    "timeISO": "2025-08-16T16:33:34.000Z",
    "textPlain": "It is exactly what makes the difference between good and bad experience, both for users and engineers. A well designed system is both easy to use and to maintain or improve. It looks simple, but it is not. It’s both leadership and craftsmanship at its peak.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924246,
    "by": "ramon156",
    "timeISO": "2025-08-16T15:23:53.000Z",
    "textPlain": "> I’m often alone on this. Engineers look at complex systems with many interesting parts and think “wow, a lot of system design is happening here!”Whenever I read something like this I feel so confused. Who actually calls themselves an engineer when they have no idea what they're talking about.  Ignorant confidence is such a useless personality trait.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924467,
    "by": "jagged-chisel",
    "timeISO": "2025-08-16T15:47:31.000Z",
    "textPlain": "Lots of comments here decrying unnecessary complexity and the depressing reality of job interviews around the subject.And I’m wondering why investors tolerate the expense: it’s surprising how much you can get done with simplicity and a small focused team.It must be something about perception when they’re ready to sell the company.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923140,
    "by": "vishnugupta",
    "timeISO": "2025-08-16T13:17:20.000Z",
    "textPlain": "I highly recommend Boring Technology[1]. It is an enjoyable read and most of the advices are actionable.[1] https://boringtechnology.club",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922515,
    "by": "nasretdinov",
    "timeISO": "2025-08-16T12:05:05.000Z",
    "textPlain": "I agree with most of the stuff written in the article (quite a rare thing I must admit :)). But one thing I'd say is a bit outdated: in general whether or not to read from replica is the same decision as whether or not to use caching: it's a (pretty significant) tradeoff. Previously you didn't have much of a choice due to hardware being quite limited. Now, however, you can have literally hundreds of CPU cores, so all those CPUs can very much be busy at work doing reads. Writes obviously do have an overhead, _but_ note that all writes are eventually serialised, _and_ replica needs to handle them as well anyway",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924515,
    "by": "firesteelrain",
    "timeISO": "2025-08-16T15:53:20.000Z",
    "textPlain": "As a system architect, software engineer and systems engineer, I see these posts and what is called system design seems to intermix systems design with software design (being that software described herein is a lower level component of the overall system)",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44925468,
    "by": "tra3",
    "timeISO": "2025-08-16T17:45:07.000Z",
    "textPlain": "Lots of good advice that I could’ve used 20 years ago. And like all good advice I would’ve ignored it back then.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924166,
    "by": "QuadrupleA",
    "timeISO": "2025-08-16T15:14:09.000Z",
    "textPlain": "Also be careful not to reach for system design when you only need software design: https://lukerissacher.com/blog/optimizing_your_web_app",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922161,
    "by": "gethly",
    "timeISO": "2025-08-16T11:01:01.000Z",
    "textPlain": "Actually event-sourcing solves most of the pains - events, schema, push/pull, caching, distribution... whatever. The downside is that it is definitely not suitable for small projects and the overhead is substantial(especially during the development stage when you want to ship the product as soon as possible). On the other hand, once you get it going, it's an unstoppable beast.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922310,
    "by": "bubblebeard",
    "timeISO": "2025-08-16T11:30:54.000Z",
    "textPlain": "Very good article, right on point!I do wonder about why the author left out testing, documentation and qa tool design though. To my mind, writing a proper phpcs or whatever to ensure everyone on the team writes code in a consistent way is crucial. Without documentation we end up forgetting why we did certain things. And without tests refactors are a nightmare.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44925090,
    "by": "jpitz",
    "timeISO": "2025-08-16T16:55:06.000Z",
    "textPlain": ">You have two options: fail open and let the request through, or fail closed and block the request with a 429.If the metaphor of a software circuit breaker is meant to emulate an electrical circuit breaker, then it seems to me that these two are inverted. Whenever a physical circuit breaker is open, it is not dangerous and not passing current.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924168,
    "by": "necessary",
    "timeISO": "2025-08-16T15:14:11.000Z",
    "textPlain": "Excellent article. In this vein, are there any books, articles, or other media that we can learn more of these sorts of principles from?",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923893,
    "by": "lysecret",
    "timeISO": "2025-08-16T14:43:51.000Z",
    "textPlain": "The designing data intensive Applications we actually needed (nothing against the original but this one is definitely more practical)",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922110,
    "by": "StevenWaterman",
    "timeISO": "2025-08-16T10:51:04.000Z",
    "textPlain": "What do you call system design, when it's referring to the design of systems in general, and not just computer services?As in:- writing a constitution- designing API for good DX- improving corporate cultureI intuitively want to call all of those system design, because they're all systems in the literal sense. But it seems like everyone else uses \"system design\" to mean distributed computer service design.Any ideas what word or phrase I could use to mean \"applying systems thinking to systems that include humans\"",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921663,
    "by": "dennisy",
    "timeISO": "2025-08-16T09:19:10.000Z",
    "textPlain": "This post has some good concepts, but I do not feel it helps you design good systems. It iterates options and primitives, but good design is when and how you apply them, which the post does not provide.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44925872,
    "by": "voidhorse",
    "timeISO": "2025-08-16T18:39:43.000Z",
    "textPlain": "Good system design is boring, obvious, and completely uninteresting. This is why a lot of flashy or trendy techniques end up leading to bad systems—they rope people in because of their cleverness or intellectual content, which often is interesting, but stuff that's new/intriguing/intellectually stimulating is often not what you want in a system.A good system needs to be as easy to understand and interpret as possible, A good system design is so mind-numbing my simple that a nincompoop can understand it. The only deviations from this policy should stem from other requirements like storage, performance, etc.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922507,
    "by": "mgaunard",
    "timeISO": "2025-08-16T12:04:03.000Z",
    "textPlain": "Seems biased towards websites, which are mostly easy CRUD.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44925551,
    "by": "rekabis",
    "timeISO": "2025-08-16T17:56:04.000Z",
    "textPlain": "> But in most cases replication lag can be worked around with simple tricks: for instance, when you update a record but need to use it right after, you can fill in the updated details in-memory instead of immediately re-reading after a write.I found myself truly confused by this one - does this actually need stating? Do people actually re-read immediately after a write? Provided you got confirmation that a write was successful and the data doesn’t have anything that an SQL trigger would change, what would be the point of an immediate read instead of just using the DB “successfully written” response as a go-ahead to just update the in-memory data?",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922235,
    "by": "mattlondon",
    "timeISO": "2025-08-16T11:14:55.000Z",
    "textPlain": "There was an article here recently about how to write good design docs: the TL;DR for that was basically your design doc should make your design seem obvious. I think that is the same conclusion here - good design is simple, straightforward design with no real surprises.Wholly agree.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44925388,
    "by": "rekabis",
    "timeISO": "2025-08-16T17:34:26.000Z",
    "textPlain": "> you’re a terrible engineer if you ever store booleans in a databaseAnything like this is trivially dismissible as absolute hogwash. It’s a shame that titles like this actually get the clicks needed to encourage more bullshite in the same vein.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923926,
    "by": "robsalasco",
    "timeISO": "2025-08-16T14:46:50.000Z",
    "textPlain": "anyone can recommend me a good book about systems design?",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924085,
    "by": "hungryhobbit",
    "timeISO": "2025-08-16T15:03:59.000Z",
    "textPlain": "This is nonsense masquerading as advice.  \"Add indexes ... but don't add too many\" is a perfect example.  It's 100% correct ... and also 100% something no one can actually change their actions based on ... which means it's also 100% worthless advice.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924351,
    "by": "ninetyninenine",
    "timeISO": "2025-08-16T15:36:55.000Z",
    "textPlain": "A lot of backend engineers are obsessed with infrastructure.I've seen engineers have servers spin up lambdas to do async jobs that are just database calls.So the server essentially waits for lambda which waits for a database. Why? Why can't you just have the server wait for the database?It's like I'm going to pay a person to wait in line for me while I wait for him. Why? You're waiting anyway!? And you just paid to involve an additional person to unnecessarily wait with you for what?When I told the engineer that you can just spin up a coroutine or like maybe you can allocate some cores before you spin up a new server... he looked at me like I was crazy. He said I was doing things so low level it was like assembly language programming. Going to low level and that lambdas were so cheap it was inconsequential.If you're reading this and you're thinking, wow that other engineer is right, well this quote from the article refers to you:\"I’m often alone on this. Engineers look at complex systems with many interesting parts and think “wow, a lot of system design is happening here!” In fact, a complex system usually reflects an absence of good design.\"",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921682,
    "by": "usernamed7",
    "timeISO": "2025-08-16T09:24:06.000Z",
    "textPlain": "One thing i would add, is that a well designed system is often one that is optimized for change. It is rare that a service remains static and unchanging; browsers and libraries are regularly updated, after all. Thus if/when a developer takes on a feature ticket to add or change XYZ, it should be easy to reason about and have predictable side-effects of how that change will impact the system, and ideally be easy to change as well.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922379,
    "by": "whodidntante",
    "timeISO": "2025-08-16T11:44:16.000Z",
    "textPlain": "Never write an article about good system design.In all seriousness, this is an extraordinary subtle and complex area, and there are few rules.For example, \"if you need data from multiple tables, JOIN them instead of making separate queries and stitching them together in-memory\" may be useful in certain circumstances. For  highly scalable consumer systems, the rule of \"avoid joins as much as possible\" can work a lot better.There is also no mention of how important it is to understand the business - usage patterns, the customers, the data, the scale of data, the scale of usage, security, uptime and reliability requirements, reporting requirements, etc.",
    "parent": 44921137,
    "depth": 1
  }
]
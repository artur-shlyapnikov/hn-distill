[
  {
    "id": 44922958,
    "by": "alixanderwang",
    "timeISO": "2025-08-16T12:55:02.000Z",
    "textPlain": "> I’m often alone on this. Engineers look at complex systems with many interesting parts and think “wow, a lot of system design is happening here!” In fact, a complex system usually reflects an absence of good design.For any job-hunters, it's important you forget this during interviews.In the past I've made the mistake of trying to convey this in system design interviews.Some hypothetical startup app> Interviewer: \"Well what about backpressure?\">\"That's not really worth considering for this amount of QPS\"> Interviewer: \"Why wouldn't you use a queue here instead of a cron job?\"> \"I don't think it's necessary for what this app is, but here's the tradeoffs.\"> Interviewer: \"How would you choose between sql and nosql db?\"> \"Doesn't matter much. Whatever the team has most expertise in\"These are not the answers they're looking for. You want to fill the whiteboard with boxes and arrows until it looks like you've got Kubernetes managing your Kubernetes.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922384,
    "by": "motorest",
    "timeISO": "2025-08-16T11:44:52.000Z",
    "textPlain": "What a great article. It's always a treat to read this sort of take.I have some remarks though. Taken from the article:> Avoid having five different services all write to the same table. Instead, have four of them send API requests (or emit events) to the first service, and keep the writing logic in that one service.This is not so cut-and-dry. The trade offs are far from obvious or acceptable.If the five services access the database then you are designing a distributed system where the interface being consumed is the database, which you do not need to design or implement, and already supports authorization and access controls out of the box, and you have out-of-the-box support for transactions and custom queries. On the other hand, if you design one service as a high-level interface over a database then you need to implement and manage your own custom interface with your own custom access controls and constrains, and you need to design and implement yourself how to handle transactions and compensation strategies.And what exactly do you buy yourself? More failure modes and a higher micro services tax?Additionally, having five services accessing the same database is a code smell. Odds are that database fused together two or three separate databases. This happens a lot, as most services grow by accretion and adding one more table to a database gets far less resistance than proposing creating an entire new persistence service. And is it possible that those five separate services are actually just one or two services?",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921359,
    "by": "bambax",
    "timeISO": "2025-08-16T08:22:33.000Z",
    "textPlain": "> When querying the database, query the database. It’s almost always more efficient to get the database to do the work than to do it yourself. For instance, if you need data from multiple tables, JOIN them instead of making separate queries and stitching them together in-memory.Oh yes! Never do a join in the application code! But also: use views! (and stored procedures if you can). A view is an abstraction about the underlying data, it's functional by nature, unlikely to break for random reasons in the future, and if done well the underlying SQL code is surprisingly readable and easy to reason about.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924166,
    "by": "QuadrupleA",
    "timeISO": "2025-08-16T15:14:09.000Z",
    "textPlain": "Also be careful not to reach for system design when you only need software design: https://lukerissacher.com/blog/optimizing_your_web_app",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922903,
    "by": "msiyer",
    "timeISO": "2025-08-16T12:48:46.000Z",
    "textPlain": "> Avoid having five different services all write to the same table. Instead, have four of them send API requests (or emit events) to the first service, and keep the writing logic in that one service.The ideal solution: Avoid having five different services all write to the same table.If five different services have to write to the same table, there is a major overlap of logic too. Are the five services really different or one would suffice?Taking practical realities into consideration, we can do what the author says. However, we risk implementing a lot of orchestration logic. We introduce a whole new layer of problems. Is that time not better spent refactoring the services: either give them their own DB tables or merge them into one servic?",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924168,
    "by": "necessary",
    "timeISO": "2025-08-16T15:14:11.000Z",
    "textPlain": "Excellent article. In this vein, are there any books, articles, or other media that we can learn more of these sorts of principles from?",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921601,
    "by": "KronisLV",
    "timeISO": "2025-08-16T09:06:18.000Z",
    "textPlain": "> Schema design should be flexible, because once you have thousands or millions of records, it can be an enormous pain to change the schema. However, if you make it too flexible (e.g. by sticking everything in a “value” JSON column, or using “keys” and “values” tables to track arbitrary data) you load a ton of complexity into the application code (and likely buy some very awkward performance constraints). Drawing the line here is a judgment call and depends on specifics, but in general I aim to have my tables be human-readable: you should be able to go through the database schema and get a rough idea of what the application is storing and why.I’m surprised that the drawbacks of EAV or just using JSON in your relational database don’t get called out more.I’d very much rather have like 20 tables with clear purpose than seeing that colleagues have once more created a “classifier” mechanism and are using polymorphic links (without actual foreign keys, columns like “section” and “entity_id”) and are treating it as a grab bag of stuff. One that you also need to read the application code a bunch to even hope to understand.Whenever I see that, I want to change careers. I get that EAV has its use cases, but in most other cases fuck EAV.It’s right up there with N+1 issues, complex dynamically generated SQL when views would suffice and also storing audit data in the same DB and it inevitably having functionality written against it, your audit data becoming a part of the business logic. Oh and also shared database instances and not having the ability to easily bootstrap your own, oh and also working with Oracle in general. And also putting things that’d be better off in the app inside of the DB and vice versa.There are so many ways to decrease your quality of life when it comes to storing and accessing data.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922259,
    "by": "nvarsj",
    "timeISO": "2025-08-16T11:20:26.000Z",
    "textPlain": "> Paradoxically, good design is self-effacing: bad design is often more impressive than good.Rings very true. Engineers are rated based on the \"complexity\" of the work they do. This system seems to encourage over-engineered solutions to all problems.I don't think there is enough appreciation for KISS - which I first learned about as an undergrad 20 years ago.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923896,
    "by": "agentultra",
    "timeISO": "2025-08-16T14:44:01.000Z",
    "textPlain": "Great article. A lot of very standard practices. Or at least… should be.One thing that I often add is the people interacting with the system. They’re a part of it too. Most people don’t operate in an atomically consistent world; a lot of business processes are eventually consistent. But you do need to know where you have to have atomic operations! It depends on where the user expects it.Systems thinking is very useful. From how your software is deployed to how the people using it in their work. Always be thinking about these things.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923630,
    "by": "feyman_r",
    "timeISO": "2025-08-16T14:13:50.000Z",
    "textPlain": "If you want to learn more about good system design at an abstract level (not just online), cannot recommend Systemantics[1] by John Gall enough. I wish all engineers get an opportunity to read it.[1] https://en.m.wikipedia.org/wiki/Systemantics",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923105,
    "by": "lutzh",
    "timeISO": "2025-08-16T13:12:25.000Z",
    "textPlain": "The only thing I know about “good system design” is that it doesn’t exist in the abstract. Asking whether an architecture is good or bad is the wrong question. The real question is: Is it fit for purpose? Does it help you achieve what you actually need to achieve?I could nitpick individual points in the article, but that misses the bigger issue: the premise is off.Don’t chase generic advice about good or bad design. First understand your requirements, then design a system that meets them.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921354,
    "by": "ZYbCRq22HbJ2y7",
    "timeISO": "2025-08-16T08:21:50.000Z",
    "textPlain": "> You’re supposed to store timestamps instead, and treat the presence of a timestamp as true. I do this sometimes but not always - in my view there’s some value in keeping a database schema immediately-readable.Seems overly negative of broad advice on a good pattern?    is_on => true\n    on_at => 1023030\n\nSure, that makes sense.     is_a_bear => true\n     a_bear_at => 12312231231\n\nNot so much, as most bears do not become bears at some point after not being a bear.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923893,
    "by": "lysecret",
    "timeISO": "2025-08-16T14:43:51.000Z",
    "textPlain": "The designing data intensive Applications we actually needed (nothing against the original but this one is definitely more practical)",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921252,
    "by": "com",
    "timeISO": "2025-08-16T08:01:37.000Z",
    "textPlain": "The advice about logging and metrics was good.I had been nodding away about state and push/pull, but this section grabbed my attention, since I’ve never seen it do clearly articulated before.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922886,
    "by": "codr7",
    "timeISO": "2025-08-16T12:46:59.000Z",
    "textPlain": "Replacing booleans with timestamps might be a good idea sometimes, presenting it as The Solution isn't very constructive imo.Adding a separate table where the presence of a record means 'true' allows recording related state without complicating the main table.And sometimes a boolean is exactly what you want.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921254,
    "by": "bravesoul2",
    "timeISO": "2025-08-16T08:02:36.000Z",
    "textPlain": "He doesnt seem to mention Conway or team topology which is an important part of system design too.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921584,
    "by": "tetha",
    "timeISO": "2025-08-16T09:02:50.000Z",
    "textPlain": "The distinction of stateful and stateless is one of the main criteria how we're dividing responsibilities between platform-infra and development.I know it's a bit untrue, but you can't do that many things wrong with a stateless application running in a container. And often the answer is \"kill it and deploy it again\". As long as you don't shred your dataset with a bad migration or some bad database code, most bad things at this level can be fixed in a few minutes with a few redeployments.I'm fine having a larger amount of people with a varying degree of experience, time for this, care and diligence working here.With a persistence like a database or a file store, you need some degree of experience of what you have to do around the system so it doesn't become a business risk. Put plainly, a database could be a massive business risk even if it is working perfectly... because no one set backups up.That's why our storages are run by dedicated people who have been doing this for years and years. A bad database loss easily sinks ships.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923140,
    "by": "vishnugupta",
    "timeISO": "2025-08-16T13:17:20.000Z",
    "textPlain": "I highly recommend Boring Technology[1]. It is an enjoyable read and most of the advices are actionable.[1] https://boringtechnology.club",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921824,
    "by": "pelagicAustral",
    "timeISO": "2025-08-16T09:50:11.000Z",
    "textPlain": "I can definitely feel the \"underwhelming\" factor. I've been working for  +10 years on government software and I really know what an underwhelming codebase looks like, first off, it has my fucking name on it.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922515,
    "by": "nasretdinov",
    "timeISO": "2025-08-16T12:05:05.000Z",
    "textPlain": "I agree with most of the stuff written in the article (quite a rare thing I must admit :)). But one thing I'd say is a bit outdated: in general whether or not to read from replica is the same decision as whether or not to use caching: it's a (pretty significant) tradeoff. Previously you didn't have much of a choice due to hardware being quite limited. Now, however, you can have literally hundreds of CPU cores, so all those CPUs can very much be busy at work doing reads. Writes obviously do have an overhead, _but_ note that all writes are eventually serialised, _and_ replica needs to handle them as well anyway",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923059,
    "by": "hks0",
    "timeISO": "2025-08-16T13:06:59.000Z",
    "textPlain": "The article starts by criticizing generic rules that come without any context:> Even good system design advice can be kind of bad. I love Designing Data-Intensive Applications, but I don’t think it’s particularly useful for most system design problems engineers will run into.But continues to do the same throughout the rest of its advices. It also says:> ... Drawing the line here is a judgment call and depends on specifics,And immediately mentions:> but in general I aim to have my tables be human-readable ...Which to me reads as \"I'm going to ignore the difference of the context everywhere and instead apply mine for everyone, and I'm going to assume most of the wolrd face the same problems as me\". It's even worse than the book being criticized in the beginning, as the book at least has \"Data-Intensive\" in its title.This is quiet easily fixable. The author can describe the typical scenario they are working with on a day-to-day basis. Do they work with 10 users a day? 100? 10,000,000? What is the traffic? How many engineers? What's the situation of the team/company; do FIXMEs turn into fixes or they become it's a feature? And so on.In the end, without setting a baseline, a lot of engineers will start pointing fingers at each other dismissing the opposite ideas because it doesn't fit their situation. The reasoning might be true, but before that, it is \"irrelevant\", hence any opposition to or defending of it.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44924085,
    "by": "hungryhobbit",
    "timeISO": "2025-08-16T15:03:59.000Z",
    "textPlain": "This is nonsense masquerading as advice.  \"Add indexes ... but don't add too many\" is a perfect example.  It's 100% correct ... and also 100% something no one can actually change their actions based on ... which means it's also 100% worthless advice.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922293,
    "by": "thisbeensaid",
    "timeISO": "2025-08-16T11:27:26.000Z",
    "textPlain": "Since the author praises proper use of databases and talks about event bus, background jobs and caching, I highly recommend to check out https://dbos.dev if you have Python or TypeScript backends. DBOS nicely solves common challenges in simple and complex systems and can eliminate the need for running separate services such as Kafka, Redis or Celery. The best: DBOS can be used as a dependency and doesn't require deploying a separate service.Very recently discussed here a week ago: https://news.ycombinator.com/item?id=44840693",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921325,
    "by": "magnio",
    "timeISO": "2025-08-16T08:16:01.000Z",
    "textPlain": "I think it's a very good article. Even if you disagree with some of the individual points in it, the advice given are very concrete, pragmatic, and IMO tunable to the specifics of each project.On state, in my current project, it is not statefulness that causes trouble, but when you need to synchronize two stateful systems. Every time there's bidirectional information flow, it's gonna be a headache. The solution is of course to maintain a single source of truth, but with UI application this is sometimes quite tricky.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922310,
    "by": "bubblebeard",
    "timeISO": "2025-08-16T11:30:54.000Z",
    "textPlain": "Very good article, right on point!I do wonder about why the author left out testing, documentation and qa tool design though. To my mind, writing a proper phpcs or whatever to ensure everyone on the team writes code in a consistent way is crucial. Without documentation we end up forgetting why we did certain things. And without tests refactors are a nightmare.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922161,
    "by": "gethly",
    "timeISO": "2025-08-16T11:01:01.000Z",
    "textPlain": "Actually event-sourcing solves most of the pains - events, schema, push/pull, caching, distribution... whatever. The downside is that it is definitely not suitable for small projects and the overhead is substantial(especially during the development stage when you want to ship the product as soon as possible). On the other hand, once you get it going, it's an unstoppable beast.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923926,
    "by": "robsalasco",
    "timeISO": "2025-08-16T14:46:50.000Z",
    "textPlain": "anyone can recommend me a good book about systems design?",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921663,
    "by": "dennisy",
    "timeISO": "2025-08-16T09:19:10.000Z",
    "textPlain": "This post has some good concepts, but I do not feel it helps you design good systems. It iterates options and primitives, but good design is when and how you apply them, which the post does not provide.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922507,
    "by": "mgaunard",
    "timeISO": "2025-08-16T12:04:03.000Z",
    "textPlain": "Seems biased towards websites, which are mostly easy CRUD.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922110,
    "by": "StevenWaterman",
    "timeISO": "2025-08-16T10:51:04.000Z",
    "textPlain": "What do you call system design, when it's referring to the design of systems in general, and not just computer services?As in:- writing a constitution- designing API for good DX- improving corporate cultureI intuitively want to call all of those system design, because they're all systems in the literal sense. But it seems like everyone else uses \"system design\" to mean distributed computer service design.Any ideas what word or phrase I could use to mean \"applying systems thinking to systems that include humans\"",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922235,
    "by": "mattlondon",
    "timeISO": "2025-08-16T11:14:55.000Z",
    "textPlain": "There was an article here recently about how to write good design docs: the TL;DR for that was basically your design doc should make your design seem obvious. I think that is the same conclusion here - good design is simple, straightforward design with no real surprises.Wholly agree.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44921682,
    "by": "usernamed7",
    "timeISO": "2025-08-16T09:24:06.000Z",
    "textPlain": "One thing i would add, is that a well designed system is often one that is optimized for change. It is rare that a service remains static and unchanging; browsers and libraries are regularly updated, after all. Thus if/when a developer takes on a feature ticket to add or change XYZ, it should be easy to reason about and have predictable side-effects of how that change will impact the system, and ideally be easy to change as well.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44922379,
    "by": "whodidntante",
    "timeISO": "2025-08-16T11:44:16.000Z",
    "textPlain": "Never write an article about good system design.In all seriousness, this is an extraordinary subtle and complex area, and there are few rules.For example, \"if you need data from multiple tables, JOIN them instead of making separate queries and stitching them together in-memory\" may be useful in certain circumstances. For  highly scalable consumer systems, the rule of \"avoid joins as much as possible\" can work a lot better.There is also no mention of how important it is to understand the business - usage patterns, the customers, the data, the scale of data, the scale of usage, security, uptime and reliability requirements, reporting requirements, etc.",
    "parent": 44921137,
    "depth": 1
  },
  {
    "id": 44923934,
    "by": "_fat_santa",
    "timeISO": "2025-08-16T14:47:34.000Z",
    "textPlain": "This goes back to \"interviews go both ways\". All those answers you gave are very reasonable and if I was your interviewer I'd pass you with flying colors. On the other hand if you're interviewing at a place that doesn't pass you with flying colors for those responses, that really says more about them than it does about you and may not be a great place to work.But to your point, many times one interviews for a job they don't really have the luxury of getting rejections and need to land somewhere fast so they can keep paying the mortgage. So while yes interviewing is a two way street, there's still quite a bit of calibration to make sure you land on the other person's side of the street so to speak.",
    "parent": 44922958,
    "depth": 2
  },
  {
    "id": 44923560,
    "by": "ramraj07",
    "timeISO": "2025-08-16T14:05:40.000Z",
    "textPlain": "Do you _want_ to work in these places? In my experience, if they expect you to run kube using kube in the interview, thats exactly what they do in their ststems as well.",
    "parent": 44922958,
    "depth": 2
  },
  {
    "id": 44923824,
    "by": "Swizec",
    "timeISO": "2025-08-16T14:36:15.000Z",
    "textPlain": "> These are not the answers they're looking for.These ARE the answers we are looking for. As the system design interview (I’ve done hundreds) I want you to start with these answers then we can layer on complexity if you’ve solved the problem and there’s time left to go into navel gazing mode.Seeing the panic slowly build in mid-level engineers’ eyes as it dawns on them that not every problem can be solved by caching is pretty fun too. “Ok cool you’ve cached it there, now how do you fill the cache without running into the same performance issue?”",
    "parent": 44922958,
    "depth": 2
  },
  {
    "id": 44923924,
    "by": "abound",
    "timeISO": "2025-08-16T14:46:31.000Z",
    "textPlain": "You don't need to entirely forget this. I've made a habit of regularly seeking out job opportunities and interviewing even when I'm entirely happy with my job, which is to say I've done a ton of these kinds of interviews (on both sides of the table).Unless the initial question requirements are insane (build Twitter at Twitter scale), I start with the smallest, dumbest thing that will work. Usually that's a single machine/VM talking to a database (or even just SQLite!). Compute and storage are so fast these days that you could comfortably run your fledgling service on a Raspberry Pi, even serving three or four-digit QPS depending on the workload.Of course, you still have to \"play the game\" in the interview, so make sure to be clear about how you'd change this as requirements changed (higher QPS, more features, etc)",
    "parent": 44922958,
    "depth": 2
  },
  {
    "id": 44922975,
    "by": "dondraper36",
    "timeISO": "2025-08-16T12:58:10.000Z",
    "textPlain": "Yes, and this is exactly why LinkedIn-driven development exists in the first place. Listing a million technologies looks much more impressive on paper to recruiters than describing how you managed to only use a modular monolith and a single Postgres instance to make everything work.",
    "parent": 44922958,
    "depth": 2
  },
  {
    "id": 44924065,
    "by": "jstummbillig",
    "timeISO": "2025-08-16T15:02:32.000Z",
    "textPlain": "If you know that those are not the answers they are looking for, you can reasonably pass by modifying the answer only slightly, while still getting your point across.If you can't, you might be getting interviewed by people you do not what to work with and you should want to know that.",
    "parent": 44922958,
    "depth": 2
  },
  {
    "id": 44923906,
    "by": "Aurornis",
    "timeISO": "2025-08-16T14:45:03.000Z",
    "textPlain": "> > Interviewer: \"Well what about backpressure?\"> > \"That's not really worth considering for this amount of QPS\"There is a good way and a bad way to communicate this in interviews.If an interviewer is asking about back pressure, they’re prompting you to demonstrate your knowledge of back pressure and how and when it would be applied. Treating it as an opening to debate the validity of the question feels like dodging the question or attempting to be contrarian. Explaining when and where you would choose to add back pressure would be good, but then you should go on to answer the question.This question hits close to home for me because I was once working at a small startup that was dealing with a unique problem where back pressure really was the correct way to manage one of our problems, but we had a number of candidates do exactly what you did: Scoff at the idea that such a topic would be relevant at a startup.If we’ve been dealing with a problem for months and a candidate comes in and confidently tells us that problem isn’t something we would experience and dismisses our question, that’s not a positive signal.> > Interviewer: \"How would you choose between sql and nosql db?\"> > \"Doesn't matter much. Whatever the team has most expertise in\"This is basically a softball question. Again, if you provide a non-answer or try to dismiss the question it feels like you’re either dodging the topic or trying to be contrarian. It’s also a warning sign to the interviewer that you might gravitate toward what’s easy for you instead of right for the project.This one also resonates with me because I spent years of my life making MongoDB do things that would have been trivial if earlier developers had used something like SQLite instead. The reason they chose MongoDB? Because the team was familiar with it. It was hell to be locked into years of legacy code built around the wrong tool for the job because some early employees thought it didn’t matter “because startup”As an interviewer, let",
    "parent": 44922958,
    "depth": 2
  },
  {
    "id": 44924033,
    "by": "ozgrakkurt",
    "timeISO": "2025-08-16T14:58:00.000Z",
    "textPlain": "You don’t want to work at a company like this anyway.",
    "parent": 44922958,
    "depth": 2
  },
  {
    "id": 44923802,
    "by": "zellyn",
    "timeISO": "2025-08-16T14:34:46.000Z",
    "textPlain": "I recently had an interview like this. Felt like half the answers I gave were of the form, “You can do scaling/sharding/partitioning thing X here, but once again, for an internal app I’d try really hard to avoid doing any of that”. If you’re interviewing with capable, experienced developers, they’ll appreciate that answer (at least, I got the offer on this one!)",
    "parent": 44922958,
    "depth": 2
  },
  {
    "id": 44923963,
    "by": "santiagobasulto",
    "timeISO": "2025-08-16T14:49:52.000Z",
    "textPlain": "I’ve been in software for 20 years and it’s the first time I hear “back pressure”. Am I too old already?",
    "parent": 44922958,
    "depth": 2
  },
  {
    "id": 44923999,
    "by": "dkarl",
    "timeISO": "2025-08-16T14:53:40.000Z",
    "textPlain": "> And what exactly do you buy yourself?APIs can be evolved much more easily than shared database schemas. Having worked with many instances of each kind of system, I think this outweighs all of the other considerations, and I don't think I'll ever again design a system with multiple services accessing the same database schema.It was maybe a good idea if you were a small company in the early 2000s, when databases were well-understood and services weren't. After that era, I haven't seen a single example of a system where it wasn't a mistake for multiple services to access the same database schema (not counting systems where the read and write path were architecturally distinct components of the same service.)",
    "parent": 44922384,
    "depth": 2
  },
  {
    "id": 44922486,
    "by": "paffdragon",
    "timeISO": "2025-08-16T12:01:15.000Z",
    "textPlain": "> the interface being consumed is the database, which you do not need to design or implementYou absolutely should design and implement it, exactly because it is now your interface. In fact, it will add more constraints to your design, because now you have different consumers and potentially writers all competing for the same resource with potentially different access patterns. Plus the maintenance overhead that migrations of such shared tables come with. And eventually you might have data in this table that are only needed for some of the services, so you now need to implement views and access controls at the DB level.Ideally, if you have a chance to implement it, an API is cleaner and more flexible. The problem in most cases is simply business pushing for faster features which often leads to quick hacks including just giving direct access to some DB table from another service, because the alternative would take more time, and we don't have time, we want features, now.But I agree with your thoughts in the last paragraph. It happens very often that people don't want to undertake the effort of a whole new design or redesign to match the evolving requirements and just patch it by adding a new table to an existing DB, then another,...",
    "parent": 44922384,
    "depth": 2
  },
  {
    "id": 44923757,
    "by": "sgarland",
    "timeISO": "2025-08-16T14:29:16.000Z",
    "textPlain": "> Additionally, having five services accessing the same database is a code smell.Counterpoint (assuming by database you mean database cluster, not a schema): having a separate physical DB for each service means that for most places, your reliability has now gone from N to N^M.",
    "parent": 44922384,
    "depth": 2
  },
  {
    "id": 44922950,
    "by": "Muromec",
    "timeISO": "2025-08-16T12:54:14.000Z",
    "textPlain": ">And what exactly do you buy yourself? More failure modes and a higher micro services tax?Nice boxes in the architectural diagram. Each box is handed to a different team and then, when engineers from those teams don't talk to each other, the system doesn't suddenly fail in an unexpected way.",
    "parent": 44922384,
    "depth": 2
  },
  {
    "id": 44922806,
    "by": "sethammons",
    "timeISO": "2025-08-16T12:40:08.000Z",
    "textPlain": "The goal is to minimize what needs changing when things need changing.When you need to alter the datastore, usually for product or scalability, you have to orchestrate all access to that datastore.Ergo: one only one thing using the datastore means less orchestration.At work, we just updated a datastore. We had to move some tables to their own db. 3 years later, 40+ teams have updated their access. This was a product need. If this was a scale issue, the product would just have died sans some as of yet imagined solution.",
    "parent": 44922384,
    "depth": 2
  },
  {
    "id": 44922460,
    "by": "bubblebeard",
    "timeISO": "2025-08-16T11:57:27.000Z",
    "textPlain": "I think the author meant, in a general way, it’s better to avoid simultaneous writes from different services, because this is an easy way to introduce race conditions.",
    "parent": 44922384,
    "depth": 2
  },
  {
    "id": 44921590,
    "by": "bob1029",
    "timeISO": "2025-08-16T09:03:29.000Z",
    "textPlain": "This is a big part of what makes ORMs a problem.Writing raw SQL views/queries per MVC view in SSR arrangements is one of the most elegant and performant ways to build complex web products. Let the RDBMS do the heavy lifting with the data. There are optimizations in play you can't even recall (because there's so many) if you're using something old and enterprisey like MSSQL or Oracle. The web server should be able to directly interpolate sql result sets into corresponding <table>s, etc. without having to round trip for each row or perform additional in memory join operations.The typical ORM implementation is the exact opposite of this - one strict object model that must be used everywhere. It's about as inflexible as you can get.",
    "parent": 44921359,
    "depth": 2
  }
]
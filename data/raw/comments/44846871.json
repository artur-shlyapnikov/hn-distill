[
  {
    "id": 44849009,
    "by": "ComplexSystems",
    "timeISO": "2025-08-09T18:44:27.000Z",
    "textPlain": "I thought this article was going to be a bunch of security theater nonsense - maybe the relatively bland title - but after reading I found it to be incredibly insightful, particularly this:> MCP discards this lesson, opting for schemaless JSON with optional, non-enforced hints. Type validation happens at runtime, if at all. When an AI tool expects an ISO-8601 timestamp but receives a Unix epoch, the model might hallucinate dates rather than failing cleanly. In financial services, this means a trading AI could misinterpret numerical types and execute trades with the wrong decimal precision. In healthcare, patient data types get coerced incorrectly, potentially leading to wrong medication dosing recommendations. Manufacturing systems lose sensor reading precision during JSON serialization, leading to quality control failures.Having worked with LLMs every day for the past few years, it is easy to see every single one of these things happening.I can practically see it playing out now: there is some huge incident of some kind, in some system or service with an MCP component somewhere, with some elaborate post-mortem revealing that some MCP server somewhere screwed up and output something invalid, the LLM took that output and hallucinated god knows what, its subsequent actions threw things off downstream, etc.It would essentially be a new class of software bug caused by integration with LLMs, and it is almost sure to happen when you combine it with other sources of bug: human error, the total lack of error checking or exception handling that LLMs are prone to (they just hallucinate), a bunch of gung-ho startups \"vibe coding\" new services on top of the above, etc.I foresee this being followed by a slew of Twitter folks going on endlessly about AGI hacking the nuclear launch codes, which will probably be equally entertaining.",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44849159,
    "by": "GeneralMayhem",
    "timeISO": "2025-08-09T19:04:03.000Z",
    "textPlain": "> MCP promises to standardize AI-tool interactions as the “USB-C for AI.”Ironically, it's achieved this - but that's an indictment of USB-C, not an accomplishment of MCP. Just like USB-C, MCP is a nigh-universal connector with very poorly enforced standards for what actually goes across it. MCP's inconsistent JSON parsing and lack of protocol standardization is closely analogous to USB-C's proliferation of cable types (https://en.wikipedia.org/wiki/USB-C#Cable_types); the superficial interoperability is a very leaky abstraction over a much more complicated reality, which IMO is worse than just having explicitly different APIs/protocols.",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44848594,
    "by": "rickcarlino",
    "timeISO": "2025-08-09T17:56:28.000Z",
    "textPlain": "> SOAP, despite its verbosity, understood something that MCP doesn’tUnfortunately, no one understood SOAP back.(Additional context: Maintaining a legacy SOAP system. I have nothing good to say about SOAP and it should serve as a role model for no one)",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44849332,
    "by": "mac-mc",
    "timeISO": "2025-08-09T19:24:47.000Z",
    "textPlain": "You're missing the most significant lesson of all that MCP knew.  That all of those featureful things are way too overcomplicated for most places, so they will gravitate to the simple thing.  It's why JSON over HTTP blobs is king today.I've been on the other side of high-feature serialization protocols, and even at large tech companies, something like migrating to gRPC is a multi-year slog that can even fail a couple of times because it asks so much of you.MCP, at its core, is a standardization of a JSON API contract, so you don't have to do as much post-training to generate various tool calling style tokens for your LLM.",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44848433,
    "by": "zorked",
    "timeISO": "2025-08-09T17:35:57.000Z",
    "textPlain": "CORBA emerged in 1991 with another crucial insight: in heterogeneous environments, you can’t just “implement the protocol” in each language and hope for the best. The OMG IDL generated consistent bindings across C++, Java, Python, and more, ensuring that a C++ exception thrown by a server was properly caught and handled by a Java client. The generated bindings guaranteed that all languages saw identical interfaces, preventing subtle serialization differences.\n\nYes, CORBA was such a success.",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44848489,
    "by": "abtinf",
    "timeISO": "2025-08-09T17:43:53.000Z",
    "textPlain": "I wish someone would write a clear, crisp explanation for why MCP is needed over simply supporting swagger or proto.",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44849477,
    "by": "upghost",
    "timeISO": "2025-08-09T19:42:01.000Z",
    "textPlain": "So I'm in the \"MCP is probably not a great idea\" camp but I couldn't say \"this is how it SHOULD be done\", and the author makes great criticisms but falls short of actual suggestions. I'm assuming the author is not seriously recommending we go back to SOAP and I've never heard of CORBA.  I've heard of gRPC but I can't tell if the author is saying it is good or bad.Also Erlang uses RPCs for pretty much all \"synchronous\" interactions but it's pretty minimal in terms of ceremony. Seems pretty reliable.So this is a serious question because hand rolling \"40 years\" of best practices seems hard, what should we be using for RPC?",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44848323,
    "by": "mockingloris",
    "timeISO": "2025-08-09T17:20:14.000Z",
    "textPlain": "I read this thrice: ...When OpenAI bills $50,000 for last month’s API usage, can you tell which department’s MCP tools drove that cost? Which specific tool calls? Which individual users or use cases?...It seems to be a game of catch up for most things AI. That said, my school of thought is that certain technologies are just too big for them to be figured out early on - web frameworks, blockchain, ...- the gap starts to shrink eventually. With AI, we'll just have to keep sharing ideas and caution like you have here.\nSuch very interesting times we live in.",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44849003,
    "by": "zwaps",
    "timeISO": "2025-08-09T18:43:44.000Z",
    "textPlain": "The author seems to fundamentally misunderstand how MCPs are going to be used and deployed.This is really obvious when they talk about tracing and monitoring, which seem to be the main points of criticism anyway.They bemoan that they cant trace across MCP calls, assuming somehow there would be a person administering all the MCPs.\nOf course each system has tracing in whatever fashion fits its system. \nThey are just not the same system, nor owned by the same people let alone companies.Same as monitoring cost. Oh, you can’t know who racked up the LLM costs? Well of course you can, these systems are already in place and there are a million of ways to do this. It has nothing to do with MCP.Reading this, I think its rather a blessing to start fresh and without the learnings of 40 years of failed protocols or whatever",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44849284,
    "by": "ipython",
    "timeISO": "2025-08-09T19:19:53.000Z",
    "textPlain": "I am torn. I see this argument and intellectually agree with it (that interfaces need to be more explicit). However it seems that every time there is a choice between “better” design and “good enough”, the “good enough” wins handily.Multics vs Unix, xml based soap vs json based rest apis, xhtml’s failure, javascript itself, … I could keep going on.So I’ve resigned myself to admitting that we are doomed to reimplement the “good enough” every time, and continue to apply bandaid after bandaid to gradually fix problems after we rediscover them, slowly.",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44849140,
    "by": "dragonwriter",
    "timeISO": "2025-08-09T19:01:23.000Z",
    "textPlain": "> MCP discards this lesson, opting for schemaless JSON with optional, non-enforced hints.Actually, MCP uses a normative TypeScript schema (and, from that, an autogenerated JSON Schema) for the protocol itself, and the individual tool calls also are specified with JSON Schema.> Type validation happens at runtime, if at all.That's not a consequence of MCP \"opting for schemaless JSON\" (which it factually does not), that's, for tool calls, a consequence of MCP being a discovery protocol where the tools, and thus the applicable schemas,  are discovered aruntime.If you are using MCP as a way to wire up highly-static components, you can do discovery against the servers once they are wired up, statically build the clients around the defined types, and build your toolchain to raise errors if the discovery responses change in the future. But that's not really the world MCP is built for. Yes, that means that the toolchain needs, if it is concerned about schema enforcement, use and apply the relevant schemas at runtime. So, um, do that?",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44849085,
    "by": "BLanen",
    "timeISO": "2025-08-09T18:54:13.000Z",
    "textPlain": "As I've been saying.MCP is not a protocol. It doesn't protocolize anything of use. It's just \"here's some symbols, do with them whatever you want.\", leaving it there but then advertising that as a feature of its universality. It provides almost just as much of a protocol as TCP, but rebuild on 5 OSI layers, again.It's not a security issue, it's a ontological issue.",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44848857,
    "by": "btown",
    "timeISO": "2025-08-09T18:26:29.000Z",
    "textPlain": "If you want the things mentioned in this article, I highly recommend looking at https://github.com/modelcontextprotocol/modelcontextprotocol... and https://modelcontextprotocol.io/community/sep-guidelines and participating in the specification process.Point-by-point for the article's gripes:- distributed tracing/telemetry - open discussion at https://github.com/modelcontextprotocol/modelcontextprotocol...- structured tool annotation for parallelizability/side-effects/idempotence - this actually already exists at https://modelcontextprotocol.io/specification/2025-06-18/sch... but it's not well documented in https://modelcontextprotocol.io/specification/2025-06-18/ser... - someone should contribute to improving this!- a standardized way in which the costs associated with an MCP tool call can be communicated to the MCP Client and reported to central tracking - nothing here I see, but it's a really good idea!- serialization issues e.g. \"the server might report a date in a format unexpected by the client\" - this isn't wrong, but since the consumer of most tool responses is itself an LLM, there's a fair amount of mitigation here. And in theory an MCP Client can use an LLM to detect under-specified/ambiguous tool specifications, and could surface these issues to the integrator.Now, I can't speak to the speed at which Maintainers and Core Maintainers are keeping up with the community's momentum - but I think it's meaningful that the community has momentum for evolving the specification!I see this post in a highly positive light: MCP shows promise because you can iterate on these kinds of structured annotations, in the context of a community that is actively developing their MCP servers. Legacy protocols aren't engaging with these problems in the same way.",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44846960,
    "by": "al2o3cr",
    "timeISO": "2025-08-09T14:51:36.000Z",
    "textPlain": "IMO worrying about type-safety in the protocol when any string field in the reply can prompt-inject the calling LLM feels like putting a band-aid on a decapitation, but YMMV",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44848879,
    "by": "calvinmorrison",
    "timeISO": "2025-08-09T18:29:08.000Z",
    "textPlain": "MCP, aka, WSDL for REST",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44848517,
    "by": "self_awareness",
    "timeISO": "2025-08-09T17:46:46.000Z",
    "textPlain": "What's new?- Electron disregards 40 years of best deployment practices,- Web disregards 40 years of best GUI practices,- Fast CPUs and lots of RAM disregards 40 years of best software optimization techniques,there are probably many more examples.",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44848318,
    "by": "gjsman-1000",
    "timeISO": "2025-08-09T17:19:59.000Z",
    "textPlain": "… or we’ll just invent MCP 2.0.On that note; some of these “best practices” arguably haven’t worked out. “Be conservative with what you send, liberal with what you receive” has turned even decent protocols into a dumpster fire, so why keep the charade going?",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44849232,
    "by": "zombiwoof",
    "timeISO": "2025-08-09T19:13:05.000Z",
    "textPlain": "Basically a bunch of vibe coders at a Anthropic hackathon used Claude to poop out MCP",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44849312,
    "by": "draw_down",
    "timeISO": "2025-08-09T19:22:54.000Z",
    "textPlain": "[dead]",
    "parent": 44846871,
    "depth": 1
  },
  {
    "id": 44849707,
    "by": "hinkley",
    "timeISO": "2025-08-09T20:09:36.000Z",
    "textPlain": "> In healthcare, patient data types get coerced incorrectly, potentially leading to wrong medication dosing recommendations.May have changed, but unlikely. I worked with medical telemetry as a young man and it was impressed upon me thoroughly how important parsing timestamps correctly was. I have a faint memory, possibly false, of this being the first time I wrote unit tests (and without the benefit of a test framework).We even accounted for lack of NTP by recalculating times off of the timestamps I. Their message headers.And the reasons I was given were incident review as well as malpractice cases. A drug administered three seconds before a heart attack starts is a very different situation than one administered eight seconds after the patient crashed. We saw recently with the British postal service how lives can be ruined by bad data, and in medical data a minute is a world of difference.",
    "parent": 44849009,
    "depth": 2
  },
  {
    "id": 44849325,
    "by": "cle",
    "timeISO": "2025-08-09T19:23:52.000Z",
    "textPlain": "I don't understand this criticism by the author. MCP supports JSON Schema, and server responses must conform to the schema. If the schema requires an ISO-8601 timestamp (ex by specifying a \"date\" format in the schema) but the server sends a Unix epoch timestamp, then it is violating the protocol.The author even later says that MCP supports JSON Schema, but also claims \"you can't generate type-safe clients\". Which is plainly untrue, there exist plenty of JSON Schema code generators.",
    "parent": 44849009,
    "depth": 2
  },
  {
    "id": 44849478,
    "by": "cookiengineer",
    "timeISO": "2025-08-09T19:42:05.000Z",
    "textPlain": "Let's put it this way:Before 2023 I always thought that all the bugs and glitches of technology in Star Trek were totally made up and would never happen this way.Post-LLM I am absolutely certain that they will happen exactly that way.I am not sure what LLM integrations have to do with engineering anymore, or why it makes sense to essentially put all your company's infrastructure into external control. And that is not even scratching the surface with the lack of reproducibility at every single step of the way.It \"somehow works\" isn't engineering.",
    "parent": 44849009,
    "depth": 2
  },
  {
    "id": 44849676,
    "by": "avereveard",
    "timeISO": "2025-08-09T20:06:40.000Z",
    "textPlain": "MCP focuses on transport and managing context and doesn't absolve the user for sensibly implementing the interface (i.e. defining a schema and doing schema validation)this is like saying \"HTTP doesn't do json validation\", which, well, yeah.",
    "parent": 44849009,
    "depth": 2
  },
  {
    "id": 44849224,
    "by": "tomrod",
    "timeISO": "2025-08-09T19:12:23.000Z",
    "textPlain": "We already have PEBKAC - problem exists between chair and keyboard.LLMs are basically automating PEBKAC",
    "parent": 44849009,
    "depth": 2
  },
  {
    "id": 44849712,
    "by": "oblio",
    "timeISO": "2025-08-09T20:10:04.000Z",
    "textPlain": "We keep repeating this.When desktop OSes came out, hardware resources were scarce so all the desktop OSes (DOS, Windows, MacOS) forgot all the lessons from Unix: multi user, cooperative multitasking, etc. 10 years later PC hardware was faster than workstations from the 90s yet we're still stuck with OSes riddled with limitations that stopped making sense in the 80s.When smartphones came out there was this gold rush and hardware resources were scarce so OSes (iOS, Android) again forgot all the lessons. 10 years later mobile hardware was faster than desktop hardware from the 00s. We're still stuck with mistakes from the 00s.AI basically does the same thing. It's all lead by very bright 20 and 30 year olds that weren't even born when Windows was first released.Our field is doomed under Teenage Attention Deficit Disorder.",
    "parent": 44849009,
    "depth": 2
  },
  {
    "id": 44849059,
    "by": "throwawaymaths",
    "timeISO": "2025-08-09T18:50:14.000Z",
    "textPlain": "i mean isnt all this stuff up to the mcp author to return a reasonable error to the agent and ask for it to repeat the call with amendments to the json?",
    "parent": 44849009,
    "depth": 2
  },
  {
    "id": 44849636,
    "by": "cnst",
    "timeISO": "2025-08-09T20:01:37.000Z",
    "textPlain": "I'd like to add that the culmination of USB-C failure was Apple's removal of USB-A ports from the latest M4 Mac mini, where an identical port on the exact same device, now has vastly different capabilities, opaque to the final user of the system months past the initial hype on the release date.Previously, you could reasonably expect a USB-C on a desktop/laptop of an Apple Silicon device, to be USB4 40Gbps Thunderbolt, capable of anything and everything you may want to use it for.Now, some of them are USB3 10Gbps.  Which ones?  Gotta look at the specs or tiny icons, I guess?Apple could have chosen to have the self-documenting USB-A ports to signify the 10Gbps limitation of some of these ports (conveniently, USB-A is limited to exactly 10Gbps, making it perfect for the use-case of having a few extra \"low-speed\" ports at very little manufacturing cost), but instead, they've decided to further dilute the USB-C brand.  Pure innovation!With the end user likely still having to use a USB-C to USB-A adapters anyways, because the majority of thumb drives, keyboards and mice, still require a USB-A port — even the USB-C ones that use USB-C on the other end of the USB-A connector.  (But, of course, that's irrelevant for an Apple fan, because you can always spend 10x as much for a USB-C version of any of these devices, and the fact that the USB-C variants are less common or inferior to USB-A, is of course irrelevant when hype and fanaticism are more important than utility, usability and logic.)",
    "parent": 44849159,
    "depth": 2
  },
  {
    "id": 44849641,
    "by": "afeuerstein",
    "timeISO": "2025-08-09T20:02:41.000Z",
    "textPlain": "Yeah, I loughed out loud when I read that line. Mission accomplished, I guess?",
    "parent": 44849159,
    "depth": 2
  },
  {
    "id": 44849381,
    "by": "jchw",
    "timeISO": "2025-08-09T19:29:02.000Z",
    "textPlain": "Agreed. In practice, SOAP was a train wreck. It's amazing how overly complicated they managed to make concepts that should've been simple, all the way down to just XML somehow being radically more complex than it looks to the wacky world of ill-defined standards for things like WSDLs and weird usage of multi-part HTTP and, to top it all off, it was all for nothing, because you couldn't guarantee that a SOAP server written in one language would be interoperable with clients in other languages. (I don't remember exactly what went wrong, but I hit issues trying to use a SOAP API powered by .NET from a Java client. I feel like that should be a pretty good case!)It doesn't take very long for people to start romanticizing things as soon as they're not in vogue. Even when the painfulness is still fresh in memory, people lament over how stupid new stuff is. Well I'm not a fan of schemaless JSON APIs (I'm one of those weird people that likes protobufs and capnp much more) but I will take 50 years of schemaless JSON API work over a month of dealing with SOAP again.",
    "parent": 44848594,
    "depth": 2
  },
  {
    "id": 44849062,
    "by": "pjmlp",
    "timeISO": "2025-08-09T18:50:29.000Z",
    "textPlain": "I have plenty of good stuff to say, especially since REST (really JSON-RPC in practice), and GraphQL, seem to always being catching up to features the whole SOAP and SOA ecosystems already had.Unfortunately as usual when a new technology cycle comes, everything gets thrown away, including the good parts.",
    "parent": 44848594,
    "depth": 2
  },
  {
    "id": 44848671,
    "by": "SoftTalker",
    "timeISO": "2025-08-09T18:06:53.000Z",
    "textPlain": "I have found that any protocol whose name includes the word \"Simple\" is anything but. So waiting for SMCP to appear....",
    "parent": 44848594,
    "depth": 2
  },
  {
    "id": 44849630,
    "by": "ohdeargodno",
    "timeISO": "2025-08-09T20:00:47.000Z",
    "textPlain": "Parsing SOAP responses on memory limited devices is such a fun experiment in just how miserable your life can get.",
    "parent": 44848594,
    "depth": 2
  },
  {
    "id": 44848803,
    "by": "cyberax",
    "timeISO": "2025-08-09T18:21:24.000Z",
    "textPlain": "This is a very hilarious but apt SOAP description: https://harmful.cat-v.org/software/xml/soap/simpleAnd I actually like XML-based technologies. XML Schema is still unparalleled in its ability to compose and verify the format of multiple document types. But man, SOAP was such a beast for no real reason.Instead of a simple spec for remote calls, it turned into a spec that described everything and nothing at the same time. SOAP supported all kinds of transport protocols (SOAP over email? Sure!), RPC with remote handles (like CORBA), regular RPC, self-describing RPC (UDDI!), etc. And nothing worked out of the box, because the nitty-gritty details of authentication, caching, HTTP response code interoperability and other \"boring\" stuff were just left as an exercise to the reader.",
    "parent": 44848594,
    "depth": 2
  },
  {
    "id": 44849399,
    "by": "prerok",
    "timeISO": "2025-08-09T19:31:45.000Z",
    "textPlain": "What are HTTP blobs?I think you meant that is why JSON won instead of XML?",
    "parent": 44849332,
    "depth": 2
  },
  {
    "id": 44848915,
    "by": "cortesoft",
    "timeISO": "2025-08-09T18:33:26.000Z",
    "textPlain": "Yeah, the modern JSON centered API landscape came about as a response to failures of CORBA and SOAP. It didn’t forget the lessons of CORBA, it rejected them.",
    "parent": 44848433,
    "depth": 2
  },
  {
    "id": 44848732,
    "by": "antonymoose",
    "timeISO": "2025-08-09T18:14:09.000Z",
    "textPlain": "To be charitable, you can look at a commercially unsuccessful project and appreciate its technical brilliance.",
    "parent": 44848433,
    "depth": 2
  },
  {
    "id": 44849281,
    "by": "sudhirb",
    "timeISO": "2025-08-09T19:18:59.000Z",
    "textPlain": "I've worked somewhere where CORBA was used very heavily and to great effect - though I suspect the reason for our successful usage was that one of the senior software engineers worked on CORBA directly.",
    "parent": 44848433,
    "depth": 2
  },
  {
    "id": 44848932,
    "by": "cyberax",
    "timeISO": "2025-08-09T18:35:13.000Z",
    "textPlain": "CORBA got a lot of things right. But it was unfortunately a child of the late 80-s telecom networks mixed with OOP-hype.So it baked in core assumptions that the network is transparent, reliable, and symmetric. So you could create an object on one machine, pass a reference to it to another machine, and everything is supposed to just work.Which is not what happens in the real world, with timeouts, retries, congested networks, and crashing computers.Oh, and CORBA C++ bindings had been designed before the STL was standardized. So they are a crawling horror, other languages were better.",
    "parent": 44848433,
    "depth": 2
  },
  {
    "id": 44848678,
    "by": "dragonwriter",
    "timeISO": "2025-08-09T18:07:29.000Z",
    "textPlain": "OpenAPI (or its Swagger predecessor) or Proto (I assume by this you mean protobuf?) don't cover what MCP does. It could have layered over them instead of using JSON-RPC, but I don't see any strong reason why they would be better than JSON-RPC as the basis (Swagger has communication assumptions that don't work well with MCP's local use case; protobuf doesn't cover communication at all and would require additional consideration in the protocol layered over it.)You'd still need basically the entire existing MCP spec to cover the use cases if it replaced JSON-RPC with Swagger or protobuf, plus additional material to cover the gaps and complications that that switch would involve.",
    "parent": 44848489,
    "depth": 2
  },
  {
    "id": 44849311,
    "by": "input_sh",
    "timeISO": "2025-08-09T19:22:39.000Z",
    "textPlain": "\"We couldn't be fucked supporting vastly different APIs so we wrote a new definition of an API that now everyone has to follow if they want to integrate with our tool.\"For what it's worth, IFTTT did the same thing like a decade ago. It started by just using existing API until it became unmaintanable, then they just forced everyone to create a separate API that follows their specific instructions.",
    "parent": 44848489,
    "depth": 2
  }
]
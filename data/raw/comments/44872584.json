[
  {
    "id": 44918793,
    "by": "5pl1n73r",
    "timeISO": "2025-08-16T00:25:36.000Z",
    "textPlain": "Ah, blockchains, where people realize all those \"it doesn't matter bugs\" with 3 layers of indirection due to shaky primitives, actually matter. Other bugs like this could be used to execute arbitrary code on the computer that compiles the software, calling random \"important looking\" stuff into memory (xz backdoor style) to be decoded and executed by the backdoor. Of course, there will never be a day where you can compile untrusted code in Solidity.> The lesson? Always test critical software under multiple compilers and library versions — especially when enabling a new language standard.Don't have giga-complicated language jockey stuff backing software that can't afford to even have one bug.",
    "parent": 44872584,
    "depth": 1
  },
  {
    "id": 44914579,
    "by": "vlovich123",
    "timeISO": "2025-08-15T16:44:46.000Z",
    "textPlain": "All I took away from this is how more and more complicated C++ as a language becomes to make the syntax slightly more convenient.",
    "parent": 44872584,
    "depth": 1
  },
  {
    "id": 44917616,
    "by": "metadat",
    "timeISO": "2025-08-15T21:44:47.000Z",
    "textPlain": "What is the appeal / high utility use-case for the spaceship \"<=>\" operator?  It seems quite unintuitive to me.. too many doodads is a turn off, like a car with excessive modifications.   Does continually adding more then more more more eventually become a stressful nightmare of complexity?For a concrete example of what this looks like, check out the Homer Simpson -designed \"everything\" car.https://media.wired.com/photos/593252a1edfced5820d0fa07/mast...p.s. Fascinating bug!  One of the most interesting cases I've encountered.",
    "parent": 44872584,
    "depth": 1
  },
  {
    "id": 44916544,
    "by": "yjftsjthsd-h",
    "timeISO": "2025-08-15T19:35:18.000Z",
    "textPlain": "Okay, but why  // SPDX-License-Identifier: UNLICENSED\n\non 6 lines of trivial example code? Of all the things to make proprietary...",
    "parent": 44872584,
    "depth": 1
  },
  {
    "id": 44916751,
    "by": "questionaaire",
    "timeISO": "2025-08-15T20:03:11.000Z",
    "textPlain": "My only question is how this operator== override eluded the g++ test suite:https://osec.io/blog/2025-08-11-compiler-bug-causes-compiler...",
    "parent": 44872584,
    "depth": 1
  },
  {
    "id": 44917826,
    "by": "nly",
    "timeISO": "2025-08-15T22:09:45.000Z",
    "textPlain": "Seems like the free comparison function in boost rational should have been constrained to non-rationalsi.e. !is_same_v<rational, U>",
    "parent": 44872584,
    "depth": 1
  },
  {
    "id": 44916907,
    "by": "moonlet",
    "timeISO": "2025-08-15T20:22:49.000Z",
    "textPlain": "I brain-typo’d the title into a 12-year-old girl’s bug taking down Solidity and this, frankly, does not live up to that hype",
    "parent": 44872584,
    "depth": 1
  },
  {
    "id": 44918801,
    "by": "mathiaspoint",
    "timeISO": "2025-08-16T00:26:49.000Z",
    "textPlain": "This is why I quit using eth. They were just way too comfortable with insane complexity.",
    "parent": 44918793,
    "depth": 2
  },
  {
    "id": 44916162,
    "by": "saghm",
    "timeISO": "2025-08-15T18:53:58.000Z",
    "textPlain": "I get as exasperated at C++ as anyone else, but IMO there's another takeaway here, which is that smart contracts are an absolutely terrible idea. Relying on code as the source of truth for a transaction just completely disregards the reality that code is always going to be buggy. For those who might not be aware, this is the same smart contract framework where someone accidentally killed $300 million of transactions because a function in a library for setting the wallet associated with a private key was defined as public instead of private: https://medium.com/cybermiles/i-accidentally-killed-it-and-e...Yes, you can fix issues like this with a \"hard fork\" if you have a large enough consensus, but at that point, does the system of having smart contracts actually improve anything over the one where the software is downstream rather than the source of truth, or are you just replacing one form of \"human intervention required\" with a different but worse one?",
    "parent": 44914579,
    "depth": 2
  },
  {
    "id": 44914866,
    "by": "twoodfin",
    "timeISO": "2025-08-15T17:07:54.000Z",
    "textPlain": "It’s less about convenient syntax and more about simplifying the construction of abstractions.You could argue that the latter is the core drive to evolve the standard.",
    "parent": 44914579,
    "depth": 2
  },
  {
    "id": 44915870,
    "by": "mgaunard",
    "timeISO": "2025-08-15T18:28:24.000Z",
    "textPlain": "Every new version of C++ (and sometimes even new versions of C++ compilers) can break code in subtle ways.You should always do extensive testing before upgrading.",
    "parent": 44914579,
    "depth": 2
  },
  {
    "id": 44915067,
    "by": "immibis",
    "timeISO": "2025-08-15T17:25:10.000Z",
    "textPlain": "It's not slightly, it's substantially more complicated to become substantially more convenient. The leap from C to C++ is similar to the leap from assembly code to C. As you add features, the language becomes more complex. That's just how it is.Most languages deal with this by limiting the features they have - but not C++! (or Scala, which is like Java's C++)",
    "parent": 44914579,
    "depth": 2
  },
  {
    "id": 44918461,
    "by": "DokDidhuAd",
    "timeISO": "2025-08-15T23:29:55.000Z",
    "textPlain": "Yeah, C++ is just batshit insane.> In C++, when you write an expression like a == b, the compiler chooses among available operator== implementations by comparing their match quality. A member function like a.operator==(b) usually has higher priority than a non-member function like operator==(a, b) — unless the types differ too much or are ambiguous.This is the largest foot-bazooka ever. The point of operator overloading is that the operator in a given expression look natural, feel natural, and behave naturally (= function intuitively). If you have multiple possible operators that could apply, for the same syntax, then you're in a worse position than you originally were -- where an operator either did one particular thing, or didn't apply at all. What operator overloading does in practice is introduce ambiguity. Which is self-defeating. You are better off with C-style, named, non-overloaded functions.You will never find this crap in actual math. \"match quality\" my ass.",
    "parent": 44914579,
    "depth": 2
  },
  {
    "id": 44917764,
    "by": "tialaramex",
    "timeISO": "2025-08-15T22:01:43.000Z",
    "textPlain": "The spaceship operator is an attempt to achieve the same thing as Rust's PartialOrd -- to have a single authoritative place to explain the ordering of a type.Historically C++ only had these separate comparison operators, and operator overloading, and so if you want ordering you'd be expected to override all of the operators and do so in a consistent way. Turns out it's easy enough to get that wrong and if you do now your C++ program is often nonsense, it has no defined meaning whatsoever. For example if a < b && b < a then too bad now many built-in library functions might do absolutely anything in say C++ 17.With the spaceship operator you're still screwed if your type provides an incoherent ordering (unlike Rust where that just means the type is less useful) but it's much more likely you'll write something which actually works.",
    "parent": 44917616,
    "depth": 2
  },
  {
    "id": 44918233,
    "by": "maxlybbert",
    "timeISO": "2025-08-15T22:56:51.000Z",
    "textPlain": "When the STL became part of the standard library ( http://www.stlport.org/resources/StepanovUSA.html  ), there was a question of how to handle algorithms that sort containers, or that perform a binary search, or in some other way, need to know whether “a” is less-than, equal-to, or greater-than “b”. The algorithms have to work on primitive types, and user defined types as efficiently as possible. They eventually decided to only require a function for “less-than.” And if “a < b” returns false, and “b < a” also returns false, then “a” and “b” are considered equal.There are times that doesn’t work, so documentation usually has a footnote that (1) certain algorithms require a partial ordering and not necessarily a total ordering, and (2) to use those algorithms, you must implement less-than, but any other comparison operator is ignored by the algorithm; instead, less-than is used to figure out greater-than and equal-to as needed. This was considered better than requiring programmers to implement a collection of comparison operators, and trusting those programmers to make those operators act consistently with each other (e.g., never say that “a” and “b” are both less-than and greater-than each other).The spaceship operator seems to address this specific case ( https://open-std.org/jtc1/sc22/wg21/docs/papers/2017/p0515r0... ). According to Herb Sutter (note that his name is on the proposal), “We added the C++20 spaceship operator to the language, but we also applied it throughout the C++ standard library and that made the library specification nearly 20 pages shorter — a net reduction” ( https://herbsutter.com/2020/12/ ).",
    "parent": 44917616,
    "depth": 2
  },
  {
    "id": 44916665,
    "by": "layer8",
    "timeISO": "2025-08-15T19:51:45.000Z",
    "textPlain": "More importantly, it’s apparently non-conforming: https://opensource.stackexchange.com/a/12412Other than that, simply not specifying any license would be equivalent.",
    "parent": 44916544,
    "depth": 2
  },
  {
    "id": 44919926,
    "by": "sali0",
    "timeISO": "2025-08-16T03:42:03.000Z",
    "textPlain": "Not having this statement results in a compile time error in solidity.",
    "parent": 44916544,
    "depth": 2
  },
  {
    "id": 44917442,
    "by": "tczMUFlmoNk",
    "timeISO": "2025-08-15T21:26:17.000Z",
    "textPlain": "It seems that the Solidity compiler complains if you do not specify one:https://stackoverflow.com/questions/68332228/spdx-license-id...",
    "parent": 44916544,
    "depth": 2
  },
  {
    "id": 44916823,
    "by": "dejj",
    "timeISO": "2025-08-15T20:13:30.000Z",
    "textPlain": "Would the license help to prevent an AI training on the example code?",
    "parent": 44916544,
    "depth": 2
  },
  {
    "id": 44916557,
    "by": "typpilol",
    "timeISO": "2025-08-15T19:36:42.000Z",
    "textPlain": "I saw that too and had to double take lol",
    "parent": 44916544,
    "depth": 2
  },
  {
    "id": 44916852,
    "by": "jeffbee",
    "timeISO": "2025-08-15T20:16:49.000Z",
    "textPlain": "All test suites have coverage gaps. The fixing commit adds tests. https://gcc.gnu.org/cgit/gcc/commit/?id=c1e54c82a9e1855499ef...The better question, in my opinion, is how many other known defects are just sitting there in the GNU buganizer with good reports for more than a decade.",
    "parent": 44916751,
    "depth": 2
  }
]
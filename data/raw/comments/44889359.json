[
  {
    "id": 44891207,
    "by": "paddy_m",
    "timeISO": "2025-08-13T17:23:05.000Z",
    "textPlain": "I have heard multiple people claim that macros are incompatible with strong or static typing and I don't see why.If there were a lisp with optional static typing like typescript, it would seem to me to be completely possible to write macros that write types.  In many cases it woudl do away with the need for generic types (and allow multiple competing syntaxes for dynamic types).  Most interestingly it would allow you to write new generic forms instead of waiting for whatever the language designer gives you.  It would also allow you access to types at runtime (which the typescript language designers took away).Maybe people were telling me that lisp style macros were incompatible with hindley millner typing, but I still don't see how.  The macros would just emit a hindley milmner subset.What am I missing?",
    "parent": 44889359,
    "depth": 1
  },
  {
    "id": 44890850,
    "by": "anentropic",
    "timeISO": "2025-08-13T16:52:41.000Z",
    "textPlain": "Layout is broken on non-maximised window sizes (text overflows off the right edge of the page)EDIT: I'm referring to layout of the blog post in the thread title, the https://coalton.app/ is ok",
    "parent": 44889359,
    "depth": 1
  },
  {
    "id": 44890701,
    "by": "CraigJPerry",
    "timeISO": "2025-08-13T16:40:17.000Z",
    "textPlain": "Is Coalton not more about performance, removing the dynamicism - lisp (at least SBCL) is already type-safe. Or it behaves that way in my limited experience - e.g. i get feedback when i screw up.I'm completely clueless about Coalton, (and almost completely an idiot when it comes to CL more generally - been playing for a couple of years at this point but even so, every day is still a school day...)",
    "parent": 44889359,
    "depth": 1
  },
  {
    "id": 44892229,
    "by": "manoDev",
    "timeISO": "2025-08-13T18:44:50.000Z",
    "textPlain": "OP: You might want to check, a bunch of examples after \"maybe monad\" are broken.",
    "parent": 44889359,
    "depth": 1
  },
  {
    "id": 44891510,
    "by": "reikonomusha",
    "timeISO": "2025-08-13T17:46:41.000Z",
    "textPlain": "As far as your first question is concerned, macros in and of themselves are not incompatible with a typed language. Coalton uses Lisp macros, for example, and they work seamlessly and as expected.But a Coalton macro is typically written in Lisp, not Coalton. This isn't in and of itself a problem---it's very easy and straightforward thus to write Common Lisp-style macros in Coalton. The difficulties arise when the macro must itself be (1) written in a statically typed manner, which gets into having a complete typing on your metalanguage (or your AST), and (2) allowed to access the type environment of the surrounding context in which the expansion is happening. If (2) should be accomplished, then the type-checking machinery must collaborate with the macro-expansion machinery, and that in practice makes both tasks very difficult to specify semantics for and implement.The language Hackett [1] worked toward solving the problem of having true typed and type-aware macros (they call them \"type-aware\" and \"type-directed\" macros [2]). Development unfortunately ceased ~7 years ago.[1] https://github.com/lexi-lambda/hackett[2] I think this video has a good discussion of Lisp, macros, and static types, from the perspective of implementing a Haskell in Racket. https://www.youtube.com/watch?v=5QQdI3P7MdY",
    "parent": 44891207,
    "depth": 2
  },
  {
    "id": 44892193,
    "by": "kscarlet",
    "timeISO": "2025-08-13T18:40:51.000Z",
    "textPlain": "It's easy to just stick them together, but to me (who writes too much Lisp for my own health) this is unsatisfactory.The dream: just like macro can be seen as a (staged) extension mechanism for Lisp evaluator, there should be an extension mechanism for the static type system, which allows me to define new types, define new syntax (like Haskell do-notation) which makes use of typing environment and expected type of current context (return-type polymorphism), etc.The reality: very few environments figure this out. In Coalton Lisp macros do work, but only at the level of untyped S-expr. A Lisp macro can't know about types of the variables in the lexical environment, or expected type of its own context. But it quite possibly works fine for the \"typescript-like\" use case you described.The problem I see: H-M type system isn't designed with extensibility in mind, and it's hopeless to make it extensible. More technical explanation of why it's hard to integrate with Lisp macro is that H-M relies on a unification-based inference stage which execution flow is very different from macro expansion.Possible solution: There's no fundamental reason why static type can't have something as powerful as Lisp macro. However first of all you would need an extensible type system, which seems to still be an open research problem. I think bidirectional type system is hopeful -- it's so different from H-M at a fundamental level though that I think it's hopeless to retrofit into Coalton.",
    "parent": 44891207,
    "depth": 2
  },
  {
    "id": 44890914,
    "by": "anentropic",
    "timeISO": "2025-08-13T16:57:31.000Z",
    "textPlain": "FYI coalton.app \"Type Classes\" example has \"Error: unmatched close parenthesis\" when you run it\"JSON Parser\" example also has errors",
    "parent": 44890850,
    "depth": 2
  },
  {
    "id": 44891094,
    "by": "skulk",
    "timeISO": "2025-08-13T17:11:48.000Z",
    "textPlain": "FWIW, SBCL is pretty good at optimizing away dynamic type checks if\nyou help it out.Here are some examples under:    (declaim (optimize (speed 2)))\n\nFirst example is a generic multiplication. x and y could be _any_ type at all.    (defun fn (x y) (* x y))\n\nIf we disassemble this function, we get the following:    ; disassembly for FN\n    ; Size: 34 bytes. Origin: #x1001868692                        ; FN\n    ; 92:       488975F8 MOV [RBP-8], RSI\n    ; 96:       4C8945F0 MOV [RBP-16], R8\n    ; 9A:       498BD0 MOV RDX, R8\n    ; 9D:       488BFE MOV RDI, RSI\n    ; A0:       FF142540061050 CALL [#x50100640]                ; SB-VM::GENERIC-*\n    ; A7:       4C8B45F0 MOV R8, [RBP-16]\n    ; AB:       488B75F8 MOV RSI, [RBP-8]\n    ; AF:       C9 LEAVE\n    ; B0:       F8 CLC\n    ; B1:       C3 RET\n    ; B2:       CC0F INT3 15                          ; Invalid argument count trap\n\nNote that it calls `GENERIC-*` which probably checks a lot of things and has a decent overhead.Now, if we tell it that x and y are bytes, it's going to give us much simpler code.    (declaim (ftype (function ((unsigned-byte 8) (unsigned-byte 8)) (unsigned-byte 16)) fn-t))\n    (defun fn-t (x y) (* x y))\n\nThe resulting code uses the imul instruction.    ; disassembly for FN-T\n    ; Size: 15 bytes. Origin: #x1001868726                        ; FN-T\n    ; 26:       498BD0 MOV RDX, R8\n    ; 29:       48D1FA SAR RDX, 1\n    ; 2C:       480FAFD7 IMUL RDX, RDI\n    ; 30:       C9 LEAVE\n    ; 31:       F8 CLC\n    ; 32:       C3 RET\n    ; 33:       CC0F INT3 15                          ; Invalid argument count trap*",
    "parent": 44890701,
    "depth": 2
  },
  {
    "id": 44890841,
    "by": "tmtvl",
    "timeISO": "2025-08-13T16:52:20.000Z",
    "textPlain": "In CL you can't declare, for example, a proper-list-of type, which is to say a type which accepts a second type and represents a proper list containing only members of that second type.  (deftype Proper-List-Of (subtype)\n    `(or Null\n         (Cons ,subtype\n               (Proper-List-Of ,subtype))))\n\nDoesn't work (for example). There kind of are ways to work around it to some extent with satisfies and ad-hoc predicate generation, but Coalton is a true value add in that aspect.",
    "parent": 44890701,
    "depth": 2
  },
  {
    "id": 44891834,
    "by": "reikonomusha",
    "timeISO": "2025-08-13T18:10:37.000Z",
    "textPlain": "I think it's three things:1. Bringing abstractions that are only possible with static types, like ad hoc polymorphism via type classes. For example, type classes allow polymorphism on the return type rather than the argument types. Something like    (declare stringify (Into :a String => :a -> :a -> String))\n    (define (stringify a b)\n      (str:concat (into a) (into b)))\n\n    ; COALTON-USER> (coalton (stringify 1 2))\n    ; \"12\"\n\nThe function `into` is not possible in a typical dynamically typed language, at least if we aim for the language to be efficient. It only takes one argument, but what it does depends on what it's expected to return. Here, it's expected to return a string, so it knows to convert the argument type to a string (should knowledge of how to do that be known by the compiler). Common Lisp's closest equivalents would be    (concatenate 'string (coerce a 'string) (coerce b 'string))\n\nwhich, incidentally, won't actually do what we want.2. Making high performance more accessible. It's possible to get very high performance out of Common Lisp, but it usually leads to creating difficult or inextensible abstractions. A lot of very high performance Common Lisp code ends up effectively looking like monomorphic imperative code; it's the most practical way to coax the compiler into producing efficient assembly.Coalton, though, has an optimizing compiler that does (some amount of) heuristic inlining, representation selection, stack allocation, constant folding, call-site optimization, code motion, etc. Common Lisp often can't do certain optimizations because the language must respect the standard, which allows things to be redefined at run-time, for example. Coalton's delineation of \"development\" and \"release\" modes gives the programmer the option to say \"I'm done!\" and let the compiler rip through the code and optimize it.3. Type safety, of course, in the spirit of ML/Haskell/etc.",
    "parent": 44890701,
    "depth": 2
  },
  {
    "id": 44891774,
    "by": "tgbugs",
    "timeISO": "2025-08-13T18:06:27.000Z",
    "textPlain": "I highly recommend watching [0] for an introduction to Coalton in the context of CL. Specifically it provides an excellent example of how the type system makes the language more expressive (by making it more composable) while also improving performance (e.g. because it can prove that certain optimizations are safe and thus can automatically generate the type annotations).0. https://www.youtube.com/watch?v=of92m4XNgrM",
    "parent": 44890701,
    "depth": 2
  },
  {
    "id": 44890838,
    "by": "wild_egg",
    "timeISO": "2025-08-13T16:52:09.000Z",
    "textPlain": "CL is strongly typed but not statically typed. The compiler generally doesn't complain ahead of time that your function is going to do math on a string because it was called incorrectly. Typically a runtime condition will be signalled when it hits that point and you can sort it out from there.Coalton moves that to the compilation step so you get an error back the instant you send the form to the REPL.",
    "parent": 44890701,
    "depth": 2
  },
  {
    "id": 44890792,
    "by": "asplake",
    "timeISO": "2025-08-13T16:48:20.000Z",
    "textPlain": "I’ve looked at it rather than used it, but what it brings is ML-style polymorphism. Type safety is a given in that case, which may or may not be the case with CL (I’ll let others argue that one).",
    "parent": 44890701,
    "depth": 2
  },
  {
    "id": 44892039,
    "by": "bitwize",
    "timeISO": "2025-08-13T18:27:18.000Z",
    "textPlain": "Strong static typing is an absolute must for large scale software engineering. CL code can be made very performant without it, but there are enormous development speed and correctness gains to be had by type-checking programs before they are executed rather than at runtime.It's 2025, people. Dynamic languages for serious projects were a 90s fad, hopefully never to be repeated.",
    "parent": 44890701,
    "depth": 2
  },
  {
    "id": 44895753,
    "by": "agambrahma",
    "timeISO": "2025-08-14T01:16:04.000Z",
    "textPlain": "Fixed now, let me know if you find something broken",
    "parent": 44892229,
    "depth": 2
  },
  {
    "id": 44893487,
    "by": "agambrahma",
    "timeISO": "2025-08-13T20:31:13.000Z",
    "textPlain": "Thanks, I'll take a look and fix them soon",
    "parent": 44892229,
    "depth": 2
  }
]
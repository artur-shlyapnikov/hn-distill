[
  {
    "id": 44865956,
    "by": "Warwolt",
    "timeISO": "2025-08-11T16:14:23.000Z",
    "textPlain": "I found \"A philosophy of software design\" to be a well intended but somewhat frustrating book to read.It seemingly develops a theory of software architecture that is getting at some reasonable stuff, but does so without any reference _at all_ to the already rich theories for describing and modeling things.I find software design highly related to scientific theory development and modeling, and related to mathematical theories like model theory, which give precise accounts of what it means to describe something.Just taking the notion of \"complexity\". Reducing that to _just_ cognitive load seems to be a very poor analysis, when simple/complex ought to deal with the \"size\" of a structure, not how easy it is to understand.The result of this poor theoretical grounding is that what the author of A Philosophy of Software Design presents feels very ad-hoc to me, and I feel like the summary presented in this article similarly feels ad-hoc.",
    "parent": 44864467,
    "depth": 1
  },
  {
    "id": 44868053,
    "by": "brabel",
    "timeISO": "2025-08-11T18:58:27.000Z",
    "textPlain": "I've written code for a couple of decades. The diagrams in this post are absolutely great. If you're just starting out, try to remember what they say and you'll do really well.",
    "parent": 44864467,
    "depth": 1
  },
  {
    "id": 44867135,
    "by": "stereolambda",
    "timeISO": "2025-08-11T17:45:52.000Z",
    "textPlain": "The actual hard question is probably making even 10% of such wisdom and good intentions survive when the program is bombarded by contributor patches, or people taking Jira tickets. TFA talks about it in the context of strategy and tactics.Organizationally enforcing strategy would be the issue. And also that the people most interested in making rules for others in an organization may not be the ones best qualified to program. And automatic tools (linters) by necessity focus on very surface level, local stuff.That's how you get the argument for the small teams productivity camp.",
    "parent": 44864467,
    "depth": 1
  },
  {
    "id": 44868333,
    "by": "debug_forever",
    "timeISO": "2025-08-11T19:20:08.000Z",
    "textPlain": "The complexity in our team's code bases have only gotten worse with AI-integrated agents. Maybe it's the prompts we're using, but it's an ironic twist that these tools that promise so much productivity today ends up dumping more tech debt into our code.It's funny reading the \"key contributors to dependency-complexity\" -- Duplication, Exceptions, Inheritance, Temporal Decomposition -- because those qualities seem like the standard for AI-generated code.",
    "parent": 44864467,
    "depth": 1
  },
  {
    "id": 44869057,
    "by": "rwoerz",
    "timeISO": "2025-08-11T20:26:34.000Z",
    "textPlain": "{\n  \"permissions\": {\n    \"allow\": [\n      \"Human(*)\"\n    ]\n  }\n}?",
    "parent": 44864467,
    "depth": 1
  },
  {
    "id": 44869484,
    "by": "CyberDildonics",
    "timeISO": "2025-08-11T21:07:31.000Z",
    "textPlain": "Good on him for designing software in the large on the regular and on the daily. I saw him give a talk once in the round. Without him I would be in a bad way.",
    "parent": 44864467,
    "depth": 1
  },
  {
    "id": 44866027,
    "by": "runningmike",
    "timeISO": "2025-08-11T16:19:12.000Z",
    "textPlain": "Nice article! Simple gets complex very fast when creating systems for business problems. For anyone interested in tools check some tips in a free cc-by book at https://nocomplexity.com/simplifyit/",
    "parent": 44864467,
    "depth": 1
  },
  {
    "id": 44867126,
    "by": "legorobot",
    "timeISO": "2025-08-11T17:45:21.000Z",
    "textPlain": "> Just taking the notion of \"complexity\". Reducing that to _just_ cognitive load seems to be a very poor analysis, when simple/complex ought to deal with the \"size\" of a structure, not how easy it is to understand.Preface: I'm likely nitpicking here; the use of \"_just_\" is enough for me to mostly agree with your take.Isn't the idea that the bulk of complexity IS in the understanding of how a system works, both how it should work and how it does work? We could take the Quake Fast Inverse Square Root code, which is simple in \"size\" but quite complex on how it actually achieves its outcome. I'd argue it requires comments, tests, and/or clarifications to make sense of what its actually doing.How do we measure that complexity? No idea :) But I like to believe that's why the book takes a philosophical approach to the discussion.I agree the arguments in the book largely \"make sense\" to me but I found myself finding it a little hand-wavey on it actually proving its points without concrete examples. I don't recall there being any metrics or measurements on improvement either, making it a philosophical discussion to me and not a scientific exercise.",
    "parent": 44865956,
    "depth": 2
  },
  {
    "id": 44866628,
    "by": "commandlinefan",
    "timeISO": "2025-08-11T17:03:56.000Z",
    "textPlain": "I haven't read it myself but I probably will because I have a lot of hope for this topic (there must be a better way to do this!)I worry that it doesn't much matter if it's perfect or mediocre, though, because there's a huge contingent of project managers who mock _any_ efforts to improve code and refuse to even acknowledge that there's any point to doing so - and they're still the ones running the asylum.",
    "parent": 44865956,
    "depth": 2
  },
  {
    "id": 44866091,
    "by": "andai",
    "timeISO": "2025-08-11T16:25:22.000Z",
    "textPlain": "That's very interesting. Can you recommended any resources for learning more about this?Also, have you considered writing on this subject yourself? I get the feeling that your perspective here would be valuable to others.",
    "parent": 44865956,
    "depth": 2
  },
  {
    "id": 44867775,
    "by": "01HNNWZ0MV43FF",
    "timeISO": "2025-08-11T18:36:44.000Z",
    "textPlain": "It would be cool to see a linter, or a new language, that makes good architecture easy and bad architecture hard.Like making state machines easier than channels. (Rust is sort-of good at state machines compared to C++ but it has one huge issue because of the ownership model, which makes good SMs a little clumsy)Or making it slightly inconvenient to do I/O buried in the middle of business logic.",
    "parent": 44867135,
    "depth": 2
  },
  {
    "id": 44868513,
    "by": "Jtsummers",
    "timeISO": "2025-08-11T19:35:56.000Z",
    "textPlain": "> but it's an ironic twist that these tools that promise so much productivity today ends up dumping more tech debt into our code.Because long-term productivity was never about the generated lines of code. You can increase your system features through expansion, or by a combination of expansion and contraction.Generating new code without spending time to follow through with the contraction step, or alternatively contracting first as a way of enabling the new expansion, will always make the code more complex and harder to sustain and continue to improve wrt the feature set.",
    "parent": 44868333,
    "depth": 2
  }
]
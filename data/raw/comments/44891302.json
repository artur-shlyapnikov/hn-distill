[
  {
    "id": 44892547,
    "by": "MajesticHobo2",
    "timeISO": "2025-08-13T19:12:02.000Z",
    "textPlain": "Not sure I agree with this part:> Allow all GET, HEAD, or OPTIONS requests.> These are safe methods, and are assumed not to change state at various layers of the stack already.Plenty of apps violate this assumption and do allow GET requests to alter state.",
    "parent": 44891302,
    "depth": 1
  },
  {
    "id": 44892566,
    "by": "akersten",
    "timeISO": "2025-08-13T19:13:31.000Z",
    "textPlain": "I'm not really grokking the explanation in the article of why the SameSite cookie attribute doesn't fix CSRF. I thought that was the whole design intent of SameSite=Secure on an HTTPS cookie, was to fix CSRF. Can someone boil it down?The article seemingly says \"these cookies won't be sent with an unsafe request. But that doesn't fix it!\" And doesn't elaborate?",
    "parent": 44891302,
    "depth": 1
  },
  {
    "id": 44893680,
    "by": "AgentME",
    "timeISO": "2025-08-13T20:50:38.000Z",
    "textPlain": "It's very nice to have an up-to-date writeup like this. I've gotten some odd looks for telling people that classic CSRF tokens are unnecessary work since the Origin header became widely supported, and I'm glad to have a page like this to refer people to.",
    "parent": 44891302,
    "depth": 1
  },
  {
    "id": 44893800,
    "by": "fabian2k",
    "timeISO": "2025-08-13T21:02:29.000Z",
    "textPlain": "So am I understanding it right that you don't need any CSRF tokens anymore to fully protect against CSRF attacks?And if Go is implementing this specific protection, are other ecosystems doing this as well? My specific interest would be .NET/C#, but I am wondering in general how widespread this specific solution is at the moment.",
    "parent": 44891302,
    "depth": 1
  },
  {
    "id": 44892028,
    "by": "nchmy",
    "timeISO": "2025-08-13T18:26:07.000Z",
    "textPlain": "i just discovered the Sec-Fetch stuff recently, due to Go 1.25's changelog. Very excited to start using it in some applications where tokens are currently used - what a hassle to deal with those.",
    "parent": 44891302,
    "depth": 1
  },
  {
    "id": 44892748,
    "by": "dizlexic",
    "timeISO": "2025-08-13T19:30:41.000Z",
    "textPlain": "[flagged]",
    "parent": 44891302,
    "depth": 1
  },
  {
    "id": 44893038,
    "by": "chrisfosterelli",
    "timeISO": "2025-08-13T19:54:51.000Z",
    "textPlain": "IMO apps that do this have a bug, and possibly a security one. This causes issues with prefetching, bot traffic, caching, CSRF, and just plain violates HTTP standards.",
    "parent": 44892547,
    "depth": 2
  },
  {
    "id": 44893810,
    "by": "simonw",
    "timeISO": "2025-08-13T21:03:54.000Z",
    "textPlain": "Those apps are beyond helping already. They need to fix theselves.",
    "parent": 44892547,
    "depth": 2
  },
  {
    "id": 44894318,
    "by": "nchmy",
    "timeISO": "2025-08-13T21:54:59.000Z",
    "textPlain": "The entire WordPress ecosystem says hello",
    "parent": 44892547,
    "depth": 2
  },
  {
    "id": 44892619,
    "by": "MajesticHobo2",
    "timeISO": "2025-08-13T19:18:34.000Z",
    "textPlain": "The problem boils down to the lack of equivalence between a site and an origin. The article explains how https://app.example.com and https://marketing.example.com may sit at very different trust levels, but are considered the same site by the browser. You don't want https://marketing.example.com to be able to make requests to https://app.example.com with your authentication cookies, but SameSite wouldn't prevent that.",
    "parent": 44892566,
    "depth": 2
  },
  {
    "id": 44894487,
    "by": "FiloSottile",
    "timeISO": "2025-08-13T22:12:34.000Z",
    "textPlain": "Same-Site cookies are, well, same-site. Not same-origin. This is already a deal-breaker for many deployments, because they don't trust blog.example.com and partner.example.com as much as admin.example.com (both in the strict sense of trust, and in the senso of not having XSS vulnerabilities the attacker can pivot off).Worse, by the original definition http://foo.example.com and https://admin.example.com are same-site, and unless the site uses HSTS with includeSubDomains, any network attacker controls the former. Chrome changed that with Schemeful Same-Site in 2020, but Firefox and Safari never deployed it.",
    "parent": 44892566,
    "depth": 2
  },
  {
    "id": 44894364,
    "by": "nchmy",
    "timeISO": "2025-08-13T21:59:32.000Z",
    "textPlain": "A few more links that I collected recently on the topichttps://github.com/golang/go/issues/73626https://developer.mozilla.org/en-US/docs/Web/Security/Attack...https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/...https://web.dev/articles/fetch-metadatahttps://appliedgo.net/spotlight/csrf-dont-mess-with-my-site/And some older ones that focused on Origin header rather than sec-fetch-*https://www.sjoerdlangkemper.nl/2019/02/27/prevent-csrf-with...https://www.brandur.org/fragments/originhttps://srungta.github.io/blog/start-right/ui-nonce",
    "parent": 44893680,
    "depth": 2
  },
  {
    "id": 44892210,
    "by": "jerf",
    "timeISO": "2025-08-13T18:43:00.000Z",
    "textPlain": "Cookies have been truly horrible. I check in on them every couple of years, because I don't do a lot of front-end but when I do it's often security-sensitive, and every single time I check in on them there's some new entry in \"SameSite; NoSeriouslySecureHarder; WhoopsTheLastStandardWasNotGoodEnough=BeActuallySecure; AwwShitDidWeGetItRightLastTime=false\" parade of attributes you need to send to get actually secure cookies.No shade on the people implementing this stuff, I understand the backwards compatibility concerns, but I mean, keeping up with this stuff is harder than it should be. And thanks to backwards compatibility most of it still defaults open, though browsers have pecked at that as they can.",
    "parent": 44892028,
    "depth": 2
  }
]
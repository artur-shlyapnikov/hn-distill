[
  {
    "id": 44856660,
    "by": "z_open",
    "timeISO": "2025-08-10T17:18:41.000Z",
    "textPlain": "const still_raw =\n    \\\\const raw =\n    \\\\    \\\\Roses are red\n    \\\\    \\\\  Violets are blue,\n    \\\\    \\\\Sugar is sweet\n    \\\\    \\\\  And so are you.\n    \\\\    \\\\\n    \\\\;\n    \\\\\n;This syntax seems fairly insane to me.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856596,
    "by": "Twey",
    "timeISO": "2025-08-10T17:11:29.000Z",
    "textPlain": "> I think Kotlin nails it: val, var, fun. Note all three are monosyllable, unlike const and fn!At least in my pronunciation, all five of those are monosyllabic! (/kQnst/, /f@n/).(Nice to see someone agree with me on minimizing syllable count, though — I definitely find it easier to chunk[1] fewer syllables.)[1]: https://en.m.wikipedia.org/wiki/Chunking_(psychology)The use of Ruby block parameters for loops in a language without first-class blocks/lambdas is a bit weird to me. I might have preferred a syntax that looks more like normal variable binding.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856243,
    "by": "bscphil",
    "timeISO": "2025-08-10T16:24:53.000Z",
    "textPlain": "> Like Rust, Zig uses 'name' (':' Type)? syntax for ascribing types, which is better than Type 'name'I'm definitely an outlier on this given the direction all syntactically C-like new languages have taken, but I have the opposite preference. I find that the most common reason I go back to check a variable declaration is to determine the type of the variable, and the harder it is to visually find that, the more annoyed I'm going to be. In particular, with statically typed languages, my mental model tends to be \"this is an int\" rather than \"this is a variable that happens to have the type 'int'\".In Rust, in particular, this leads to some awkward syntactic verbosity, because mutable variables are declared with `let mut`, meaning that `let` is used in every declaration. In C or C++ the type would take the place of that unnecessary `let`. And even C (as of C23) will do type inference with the `auto` keyword. My tendency is to use optional type inference in places where needing to know the type isn't important to understand the code, and to specify the type when it would serve as helpful commentary when reading it back.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856611,
    "by": "losvedir",
    "timeISO": "2025-08-10T17:13:27.000Z",
    "textPlain": "> Note all three are monosyllable, unlike const and fn!I'm not sure if I'm parsing this right, but is the implication that \"const\" is not monosyllabic? It certainly is for me. How else do people say it? I get \"fn\" because people might say \"eff enn\" but I don't see what the equivalent for const would be.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856197,
    "by": "pton_xd",
    "timeISO": "2025-08-10T16:18:18.000Z",
    "textPlain": "\"Zig doesn’t have lambdas\"This surprises me (as a C++ guy). I use lambdas everywhere. What's the standard way of say defining a comparator when sorting an array in Zig?",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856126,
    "by": "phplovesong",
    "timeISO": "2025-08-10T16:08:49.000Z",
    "textPlain": "I find Zig syntax noicy. I dont like the @TypeOf (at symbol) and pals, and the weird .{.x} syntax feels off.Zig has some nice things going on but somehow code is really hard to read, admitting its a skill issue as im not that versed in zig.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856377,
    "by": "nromiun",
    "timeISO": "2025-08-10T16:43:17.000Z",
    "textPlain": "I like Zig as well, but I won't call its syntax lovely. Go shows you can do pretty well without ; for line breaks, without : for variable types etc.But sure, if you only compare it with Rust, it is a big improvement.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856590,
    "by": "lvl155",
    "timeISO": "2025-08-10T17:10:55.000Z",
    "textPlain": "Zig is just fun to write. And to me, it’s actually what I wish Rust was like. Rust is a great language, and no one’s going to argue that point but writing Zig for the first time was so refreshing. That said, Rust is now basically default for systems and Zig came too late.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856311,
    "by": "the__alchemist",
    "timeISO": "2025-08-10T16:34:12.000Z",
    "textPlain": "I wish Zig had lovely vector, quaternion, matrix etx syntax. The team's refusal to add operator overloading will prevent this.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856583,
    "by": "WalterBright",
    "timeISO": "2025-08-10T17:09:47.000Z",
    "textPlain": "const x: i32 = 92;\n\nD has less syntax:    const int x = 92;\n\nJust for fun, read each declaration out loud.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856155,
    "by": "MrResearcher",
    "timeISO": "2025-08-10T16:13:32.000Z",
    "textPlain": "It's still not clear to me how you can make two comptime closures with different contents and pass those as a functor into the same function. It needs to have a sort of VTable to invoke the function, and yet since the contents are different, the objects are different, and their deallocation will be different too.\nDefining VTable in zig seems to be a pretty laborious endeavor, with each piece sewn manually.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856219,
    "by": "hardwaregeek",
    "timeISO": "2025-08-10T16:21:39.000Z",
    "textPlain": "Everyone agrees that \"syntax doesn't matter\", but implicit in that is \"syntax doesn't matter, so let's do what I prefer\". So really, syntax does matter. Personally I prefer the Rust/Zig/Go syntax of vaguely C inspired with some nice fixes, as detailed in the post. Judging by the general success of that style, I do wonder if more functional languages should consider an alternative syntax in that style. The Haskell/OCaml concatenative currying style with whitespace is elegant, but sufficiently unfamiliar that I do think it hurts adoption.After all, Rust's big success is hiding the spinach of functional programming in  the brownie of a systems programming language. Why not imitate that?",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856309,
    "by": "pjmlp",
    "timeISO": "2025-08-10T16:33:27.000Z",
    "textPlain": "Having @ and .{ } all over the place is hardly lovely, as is having modules like JavaScript's CJS.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856288,
    "by": "Y_Y",
    "timeISO": "2025-08-10T16:30:33.000Z",
    "textPlain": "> C uses a needlessly confusing spiral ruleLibellous! The \"spiral rule\" for C is an abomination and not part of the language. I happen to find C's type syntax a bit too clever for beginners, but it's marvellously consistent and straightforward. I can read types fine without that spiral nonsense, even if a couple of judicious typedefs are generally a good idea for any fancy function types.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856151,
    "by": "zabzonk",
    "timeISO": "2025-08-10T16:12:43.000Z",
    "textPlain": "In my experience, everyone finds the syntax of their favourite language lovely - I love (mostly) C++.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856429,
    "by": "Western0",
    "timeISO": "2025-08-10T16:50:48.000Z",
    "textPlain": "Love Ruby and Cristal syntax ;-)",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856112,
    "by": "do_not_redeem",
    "timeISO": "2025-08-10T16:06:10.000Z",
    "textPlain": "Since we're talking syntax... it's mildly infuriating that the zig parser is not smart enough to understand expressions like `const x=a()orelse b();`. You have to manually add a space before `orelse` -- but isn't that what `zig fmt` is for? I have RSI and it's maddening having to mash the arrow keys and add/remove whitespace until the parser is happy.I've heard the argument that people might confuse binary operators for prefix/postfix operators, but I don't buy it. Who would think an operator named `orelse` is anything but binary?",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856495,
    "by": "jeffWrld",
    "timeISO": "2025-08-10T16:58:51.000Z",
    "textPlain": "[dead]",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856442,
    "by": "reactordev",
    "timeISO": "2025-08-10T16:52:36.000Z",
    "textPlain": "I’m in the same boat. It’s faster mentally to grok the type of something when it comes first. The name of the thing is less important (but still important!) than the type of the thing and so I prefer types to come before names.From a parser perspective, it’s easier to go name first so you can add it to the AST and pass it off to the type determiner to finish the declaration. So I get it. In typescript I believe it’s this way so parsers can just drop types all together to make it compatible with JavaScript (it’s still trivial to strip typing, though why would you?) without transpiling.In go, well, you have even more crazier conventions. Uppercase vs lowercase public vs private, no inheritance, a gc that shuns away performance minded devs.In the end, I just want a working std library that’s easy to use so I can build applications. I don’t care for:    type Add<A extends number, B extends number> = [\n      …Array<A>,\n      …Array<B>,\n    ][“length”]\n\nThis is the kind of abuse of the type system that drives me bonkers. You don’t have to be clever, just export a function. I don’t need a type to represent every state, I need intent.",
    "parent": 44856243,
    "depth": 2
  },
  {
    "id": 44856339,
    "by": "SkiFire13",
    "timeISO": "2025-08-10T16:38:02.000Z",
    "textPlain": "> In C or C++ the type would take the place of that unnecessary `let`In my opinion the `let` is not so unnecessary. It clearly marks a statement that declares a variable, as opposed to other kind of statements, for example a function call.This is also why C++ need the \"most vexing parse\" ambiguity resolution.",
    "parent": 44856243,
    "depth": 2
  },
  {
    "id": 44856613,
    "by": "erk__",
    "timeISO": "2025-08-10T17:13:29.000Z",
    "textPlain": "Maybe it just have to do with what you are used to, it was one of the things that made me like Rust coming from F# it had the same `name : type` and `let mutable name` that I knew from there.",
    "parent": 44856243,
    "depth": 2
  },
  {
    "id": 44856457,
    "by": "tapirl",
    "timeISO": "2025-08-10T16:54:23.000Z",
    "textPlain": "Normal function declarations.This is indeed a point which makes Zig inflexible.",
    "parent": 44856197,
    "depth": 2
  },
  {
    "id": 44856325,
    "by": "tux1968",
    "timeISO": "2025-08-10T16:36:16.000Z",
    "textPlain": "Same as C, define a named function, and pass a pointer to the sorting function.",
    "parent": 44856197,
    "depth": 2
  },
  {
    "id": 44856203,
    "by": "flohofwoe",
    "timeISO": "2025-08-10T16:20:01.000Z",
    "textPlain": "The dot is just a placeholder for an inferred type, and IMHO that makes a lot of sense. E.g. you can either write this:    const p = Point{ .x = 123, .y = 234 };\n\n...or this:    const p: Point = .{ .x = 123, .y = 234 };\n\nWhen calling a function which expects a Point you can omit the verbose type:    takePoint(.{ .x = 123, .y = 234 });\n\nIn Rust I need to explicitly write the type:    takePoint(Point{ x: 123, y: 234);\n\n...and in nested struct initializations the inferred form is very handy, e.g. Rust requires you to write this (not sure if I got the syntax right):    const x = Rect{\n        top_left: Point{ x: 123, y: 234 },\n        bottom_right: Point{ x: 456, y: 456 },\n    };\n\n...but the compiler already knows that Rect consists of two nested Points, so what's the point of requiring the user to type that out? So in Zig it's just:    const x = Rect{\n        .top_left = .{ .x = 123, .y = 234 },\n        .bottom_right = .{ .x = 456, .y = 456 },\n    };\n\nRequiring the explicit type on everything can get noisy really fast in Rust.Of course the question is whether the leading dot in '.{' could be omitted, and personally I would be in favour of that. Apparently it simplifies the parser, but such implementation details should get in the way of convenience IMHO.And then there's `.x = 123` vs `x: 123`. The Zig form is copied from C99, the Rust form from Javascript. Since I write both a lot of C99 and Typescript I don't either form (and both Zig and Rust are not even close to the flexibility and convenience of the C99 designated initialization syntax unfortunately).Edit: fixed the Rust struct init syntax.",
    "parent": 44856126,
    "depth": 2
  },
  {
    "id": 44856459,
    "by": "nine_k",
    "timeISO": "2025-08-10T16:54:30.000Z",
    "textPlain": "I personally find Go's bare syntax harder to parse when reading, and I spend more time reading code than typing it (even while writing).An excessively terse syntax becomes very unforgiving, when a typo is not noticed by the compiler / language server, but results in another syntactically correct but unexpected program, or registers as a cryptic error much farther downstream. Cases in point: CoffeeScript, J.",
    "parent": 44856377,
    "depth": 2
  },
  {
    "id": 44856407,
    "by": "flohofwoe",
    "timeISO": "2025-08-10T16:48:16.000Z",
    "textPlain": "You don't need operator overloading for vector and matrix math, see pretty much all GPU languages. What Zig is missing is a complete mapping of the Clang Extended Vector and Matrix extensions (instead of the quite limited `@Vector` type):https://clang.llvm.org/docs/LanguageExtensions.html#vectors-...https://clang.llvm.org/docs/LanguageExtensions.html#matrix-t...",
    "parent": 44856311,
    "depth": 2
  },
  {
    "id": 44856640,
    "by": "WalterBright",
    "timeISO": "2025-08-10T17:16:44.000Z",
    "textPlain": "Zig:    fn ArrayListType(comptime T: type) type {\n\nD:    T ArrayListType(T)() {",
    "parent": 44856583,
    "depth": 2
  },
  {
    "id": 44856618,
    "by": "WalterBright",
    "timeISO": "2025-08-10T17:14:06.000Z",
    "textPlain": "Zig:    const std = @import(\"std\");\n\nD:    import std;",
    "parent": 44856583,
    "depth": 2
  },
  {
    "id": 44856577,
    "by": "nromiun",
    "timeISO": "2025-08-10T17:09:07.000Z",
    "textPlain": "That saying never made any sense to me either. After all syntax is your main interface to a language. Anything you do has to go through the syntax.Some people say the syntax just kind of disappears for them after some time. That never seems to happen with me. When I am reading any code the syntax gets even more highlighted.",
    "parent": 44856219,
    "depth": 2
  },
  {
    "id": 44856315,
    "by": "Akronymus",
    "timeISO": "2025-08-10T16:35:18.000Z",
    "textPlain": "It's especially bad on a qwertz keyboard as well.",
    "parent": 44856309,
    "depth": 2
  },
  {
    "id": 44856546,
    "by": "Twey",
    "timeISO": "2025-08-10T17:05:18.000Z",
    "textPlain": "> fancy function typesIf the syntax were straightforward, plain old function types wouldn't be ‘fancy’ :)",
    "parent": 44856288,
    "depth": 2
  },
  {
    "id": 44856303,
    "by": "throwawaymaths",
    "timeISO": "2025-08-10T16:31:31.000Z",
    "textPlain": "It's not context free though.",
    "parent": 44856288,
    "depth": 2
  },
  {
    "id": 44856652,
    "by": "guidopallemans",
    "timeISO": "2025-08-10T17:17:50.000Z",
    "textPlain": "I don't like how Python does lambdas, its indentation-based blocks, how there's both ' and \", I could go on.",
    "parent": 44856151,
    "depth": 2
  },
  {
    "id": 44856405,
    "by": "aeonik",
    "timeISO": "2025-08-10T16:48:14.000Z",
    "textPlain": "Not me!I don't like the syntax of Lisps, with the leading parenthesis to begin every expression.I use it anyway because it's so useful and powerful. And I don't have any better ideas.",
    "parent": 44856151,
    "depth": 2
  },
  {
    "id": 44856238,
    "by": "ben-schaaf",
    "timeISO": "2025-08-10T16:24:14.000Z",
    "textPlain": "As someone who works almost exclusively in C++, the whole \"most vexing parse\" makes the syntax indefensible.",
    "parent": 44856151,
    "depth": 2
  },
  {
    "id": 44856184,
    "by": "jeltz",
    "timeISO": "2025-08-10T16:17:14.000Z",
    "textPlain": "I am an exception then. Rust may be my favourite language but the syntax is pretty awful and one of its biggest weaknesses. I also love Ruby but I am pretty meh about its syntax.",
    "parent": 44856151,
    "depth": 2
  },
  {
    "id": 44856473,
    "by": "darthrupert",
    "timeISO": "2025-08-10T16:56:10.000Z",
    "textPlain": "Absolutely. Kinda of the best of many worlds, because it has what looks like an indentation-based syntax but actually blocks are delimited by start and end keywords. This makes it possible (unlike, say, python) to programmatically derive correct code formatting more reliably.And no pointless semicolons.",
    "parent": 44856429,
    "depth": 2
  },
  {
    "id": 44856569,
    "by": "nateglims",
    "timeISO": "2025-08-10T17:08:24.000Z",
    "textPlain": "The error when you accidentally pass a variable directly instead of in a .{} is also really unclear.",
    "parent": 44856112,
    "depth": 2
  },
  {
    "id": 44856130,
    "by": "hmry",
    "timeISO": "2025-08-10T16:09:39.000Z",
    "textPlain": "\"Read the file, or else!\" The threatening postfix operator",
    "parent": 44856112,
    "depth": 2
  }
]
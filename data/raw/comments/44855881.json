[
  {
    "id": 44857003,
    "by": "n42",
    "timeISO": "2025-08-10T18:02:13.000Z",
    "textPlain": "this is a really, really good article with a lot of nuance and a deep understanding of the tradeoffs in syntax design. unfortunately, it is evoking a lot of knee-jerk reactions from the title and emotional responses to surface level syntax aesthetics.the thing that stands out to me about Zig's syntax that makes it \"lovely\" (and I think matklad is getting at here), is there is both minimalism and consistency to the design, while ruthlessly prioritizing readability. and it's not the kind of surface level \"aesthetically beautiful\" readability that tickles the mind of an abstract thinker; it is brutalist in a way that leaves no room for surprise in an industrial application. it's really, really hard to balance syntax design like this, and Zig has done a lovely and respectable job at doing so.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856243,
    "by": "bscphil",
    "timeISO": "2025-08-10T16:24:53.000Z",
    "textPlain": "> Like Rust, Zig uses 'name' (':' Type)? syntax for ascribing types, which is better than Type 'name'I'm definitely an outlier on this given the direction all syntactically C-like new languages have taken, but I have the opposite preference. I find that the most common reason I go back to check a variable declaration is to determine the type of the variable, and the harder it is to visually find that, the more annoyed I'm going to be. In particular, with statically typed languages, my mental model tends to be \"this is an int\" rather than \"this is a variable that happens to have the type 'int'\".In Rust, in particular, this leads to some awkward syntactic verbosity, because mutable variables are declared with `let mut`, meaning that `let` is used in every declaration. In C or C++ the type would take the place of that unnecessary `let`. And even C (as of C23) will do type inference with the `auto` keyword. My tendency is to use optional type inference in places where needing to know the type isn't important to understand the code, and to specify the type when it would serve as helpful commentary when reading it back.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856660,
    "by": "z_open",
    "timeISO": "2025-08-10T17:18:41.000Z",
    "textPlain": "> Raw or multiline strings are spelled like this:    const still_raw =\n        \\\\const raw =\n        \\\\    \\\\Roses are red\n        \\\\    \\\\  Violets are blue,\n        \\\\    \\\\Sugar is sweet\n        \\\\    \\\\  And so are you.\n        \\\\    \\\\\n        \\\\;\n        \\\\\n    ;\n\nThis syntax seems fairly insane to me.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856126,
    "by": "phplovesong",
    "timeISO": "2025-08-10T16:08:49.000Z",
    "textPlain": "I find Zig syntax noicy. I dont like the @TypeOf (at symbol) and pals, and the weird .{.x} syntax feels off.Zig has some nice things going on but somehow code is really hard to read, admitting its a skill issue as im not that versed in zig.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856731,
    "by": "kcartlidge",
    "timeISO": "2025-08-10T17:26:36.000Z",
    "textPlain": "I much prefer C# 11's raw string literals.  It takes the indentation of the first line and assumes the subsequent ones have the same indentation.  string json = $\"\"\"\n      <h1>{title}</h1>\n      <article>\n          Welcome to {sitename}.\n      </article>\n      \"\"\";\n\nAnd it even allows for using embedded curly braces as real characters:  string json = $$\"\"\"\n      <h1>{{title}}</h1>\n      <article>\n          Welcome to {{sitename}}, which uses the <code>{sitename}</code> syntax.\n      </article>\n      \"\"\";\n\nThe $ (meaning to interpolate curly braces) appears twice, which switches interpolation to two curly braces, leaving the single ones untouched.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856377,
    "by": "nromiun",
    "timeISO": "2025-08-10T16:43:17.000Z",
    "textPlain": "I like Zig as well, but I won't call its syntax lovely. Go shows you can do pretty well without ; for line breaks, without : for variable types etc.But sure, if you only compare it with Rust, it is a big improvement.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856197,
    "by": "pton_xd",
    "timeISO": "2025-08-10T16:18:18.000Z",
    "textPlain": "\"Zig doesn’t have lambdas\"This surprises me (as a C++ guy). I use lambdas everywhere. What's the standard way of say defining a comparator when sorting an array in Zig?",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856311,
    "by": "the__alchemist",
    "timeISO": "2025-08-10T16:34:12.000Z",
    "textPlain": "I wish Zig had lovely vector, quaternion, matrix etx syntax. The team's refusal to add operator overloading will prevent this.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856596,
    "by": "Twey",
    "timeISO": "2025-08-10T17:11:29.000Z",
    "textPlain": "> I think Kotlin nails it: val, var, fun. Note all three are monosyllable, unlike const and fn!At least in my pronunciation, all five of those are monosyllabic! (/kQnst/, /f@n/).(Nice to see someone agree with me on minimizing syllable count, though — I definitely find it easier to chunk[1] fewer syllables.)[1]: https://en.m.wikipedia.org/wiki/Chunking_(psychology)The use of Ruby block parameters for loops in a language without first-class blocks/lambdas is a bit weird to me. I might have preferred a syntax that looks more like normal variable binding.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44857220,
    "by": "culebron21",
    "timeISO": "2025-08-10T18:33:57.000Z",
    "textPlain": "I've been seeing articles on Zig for the last 2 years, and was interested, but it seems the language community is too far from my area of interest -- data and geospatial, and the tools in my sphere in Zig aren't mature enough. E.g. to parse a CSV, you have to use very simple packages or just use a tokenizer and parse the tokens yourself.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856219,
    "by": "hardwaregeek",
    "timeISO": "2025-08-10T16:21:39.000Z",
    "textPlain": "Everyone agrees that \"syntax doesn't matter\", but implicit in that is \"syntax doesn't matter, so let's do what I prefer\". So really, syntax does matter. Personally I prefer the Rust/Zig/Go syntax of vaguely C inspired with some nice fixes, as detailed in the post. Judging by the general success of that style, I do wonder if more functional languages should consider an alternative syntax in that style. The Haskell/OCaml concatenative currying style with whitespace is elegant, but sufficiently unfamiliar that I do think it hurts adoption.After all, Rust's big success is hiding the spinach of functional programming in  the brownie of a systems programming language. Why not imitate that?",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44857140,
    "by": "melodyogonna",
    "timeISO": "2025-08-10T18:21:17.000Z",
    "textPlain": "Very interesting, Zig seems really nice. There was a severe lack of resources when I tried to get into it few years ago, it is nice to see that situation improving in real time.The part about integer literal  is similar to Mojo, with a comp-time type that has to be materialized to another type at runtime. In Mojo though this can be done implicitly so you don't need explicit casting.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856611,
    "by": "losvedir",
    "timeISO": "2025-08-10T17:13:27.000Z",
    "textPlain": "> Note all three are monosyllable, unlike const and fn!I'm not sure if I'm parsing this right, but is the implication that \"const\" is not monosyllabic? It certainly is for me. How else do people say it? I get \"fn\" because people might say \"eff enn\" but I don't see what the equivalent for const would be.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856941,
    "by": "ww520",
    "timeISO": "2025-08-10T17:53:42.000Z",
    "textPlain": "Zig is great. I have fun writing in it. But there’re a few things bug me.- Difficult to return a value from a block. Rust treats the value of the last expression of a block as the return value of the block. Have to jump through hoops in Zig to do it with label.- Unable to chain optional checks, e.g. a?.b?.c.  Support for monadic types would be great so general chaining operations are supported.- Lack of lambda support. Function blocks are already supported in a number of places, i.e. the for-loop block and the catch block.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856155,
    "by": "MrResearcher",
    "timeISO": "2025-08-10T16:13:32.000Z",
    "textPlain": "It's still not clear to me how you can make two comptime closures with different contents and pass those as a functor into the same function. It needs to have a sort of VTable to invoke the function, and yet since the contents are different, the objects are different, and their deallocation will be different too.\nDefining VTable in zig seems to be a pretty laborious endeavor, with each piece sewn manually.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856151,
    "by": "zabzonk",
    "timeISO": "2025-08-10T16:12:43.000Z",
    "textPlain": "In my experience, everyone finds the syntax of their favourite language lovely - I love (mostly) C++.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856583,
    "by": "WalterBright",
    "timeISO": "2025-08-10T17:09:47.000Z",
    "textPlain": "const x: i32 = 92;\n\nD has less syntax:    const int x = 92;\n\nJust for fun, read each declaration out loud.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856590,
    "by": "lvl155",
    "timeISO": "2025-08-10T17:10:55.000Z",
    "textPlain": "Zig is just fun to write. And to me, it’s actually what I wish Rust was like. Rust is a great language, and no one’s going to argue that point but writing Zig for the first time was so refreshing. That said, Rust is now basically default for systems and Zig came too late.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856288,
    "by": "Y_Y",
    "timeISO": "2025-08-10T16:30:33.000Z",
    "textPlain": "> C uses a needlessly confusing spiral ruleLibellous! The \"spiral rule\" for C is an abomination and not part of the language. I happen to find C's type syntax a bit too clever for beginners, but it's marvellously consistent and straightforward. I can read types fine without that spiral nonsense, even if a couple of judicious typedefs are generally a good idea for any fancy function types.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856309,
    "by": "pjmlp",
    "timeISO": "2025-08-10T16:33:27.000Z",
    "textPlain": "Having @ and .{ } all over the place is hardly lovely, as is having modules like JavaScript's CJS.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856721,
    "by": "IshKebab",
    "timeISO": "2025-08-10T17:25:34.000Z",
    "textPlain": "> As Zig has only line-commentsSuch a good decision. There's no reason to use block comments in 2025.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856777,
    "by": "yegle",
    "timeISO": "2025-08-10T17:31:37.000Z",
    "textPlain": "> As Zig has only line-comments, this means that \\n is always whitespace.Do I read this correctly that it replaces `\\n` at the end of the line with a whitespace? CJK users probably won't be happy with the additional whitespaces.",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856684,
    "by": "qcnguy",
    "timeISO": "2025-08-10T17:21:16.000Z",
    "textPlain": "Weird the author finds it lovely and compares to Kotlin, but doesn't find Kotlin superior. Kotlin invested heavily in a really nice curly brace syntax. It is actually the nicest out there. In every point the author makes, it feels like Kotlin did it the same or better. For example:1. Integer literals. \"var a = 1\" doesn't work, seems absurd. In Kotlin literals do have strong types, but coercion is allowed when defining variables so \"var a = 1\" works, and \"var a: Long = 1\" works even though you can write a literal long as 1L. This means you can write numbers to function parameters naturally.2. Multi-line string literals. OK this is a neat idea, but what about copy/paste? In Kotlin you can just write \"\"\" .. \"\"\".trimIndent() and then copy paste some arbitrary text into the string, the indent will be removed for you. The IDE will also help with this by adding | characters which looks more natural than \\\\ and can be removed using .trimMargin(), only downside is the trimming is done at runtime but that could easily be fixed without changing the language.3. Record literals. This syntax is called lovely because it's designed for grep, a properly funded language like Kotlin just uses named kwargs to constructors which is more natural. There's no need to design the syntax for grep because Kotlin is intended to be used with a good IDE that can answer this query instantly and precisely.4. Function syntax. \"fn foo(a: i32) i32 {}\" seems weird. If the thing that has a type and the type are normally separated by a : then why not here? Kotlin does \"fun foo(a: Int): Int {}\" which is more consistent.5. Locals. Agree with author that Kotlin nails it.6. Not using && or ||, ok this one Zig wins, the Zig way is more consistent and reads better. Kotlin does have `and` and `or` as infix operator functions, but they are for the bitwise operations :(7. Explicit returns. Kotlin supports blocks that return values and also doesn't need semicolons, so not quite sure what the tradeoff here is suppo",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856429,
    "by": "Western0",
    "timeISO": "2025-08-10T16:50:48.000Z",
    "textPlain": "Love Ruby and Cristal syntax ;-)",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856112,
    "by": "do_not_redeem",
    "timeISO": "2025-08-10T16:06:10.000Z",
    "textPlain": "Since we're talking syntax... it's mildly infuriating that the zig parser is not smart enough to understand expressions like `const x=a()orelse b();`. You have to manually add a space before `orelse` -- but isn't that what `zig fmt` is for? I have RSI and it's maddening having to mash the arrow keys and add/remove whitespace until the parser is happy.I've heard the argument that people might confuse binary operators for prefix/postfix operators, but I don't buy it. Who would think an operator named `orelse` is anything but binary?",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44856495,
    "by": "jeffWrld",
    "timeISO": "2025-08-10T16:58:51.000Z",
    "textPlain": "[dead]",
    "parent": 44855881,
    "depth": 1
  },
  {
    "id": 44857133,
    "by": "Twey",
    "timeISO": "2025-08-10T18:19:59.000Z",
    "textPlain": "> it's not the kind of surface level \"aesthetically beautiful\" readability that tickles the mind of an abstract thinkerRather, the sort of beauty it's going for here is exactly the type of beauty that requires a bit of abstraction to appreciate: it's not that the concrete syntax is visually beautiful per se so much as that it's elegantly exposing the abstract syntax, which is inherently more regular and unambiguous than the concrete syntax. It's the same reason S-exprs won over M-exprs: consistently good often wins over special-case great because the latter imposes the mental burden of trying to fit into the special case, while the former allows you to forget that the problem ever existed. To see a language do the opposite of this, look at C++: the syntax has been designed with many, many special cases that make specific constructs nicer to write, but the cost of that is that now you have to remember all of them (and account for all of them, if templating — hence the ‘new’ uniform initialization syntax[1]).[1]: https://xkcd.com/927/This trade-off happens all the time in language design: you're looking for language that makes all the special cases nice _as a consequence of_ the general case, because _just_ being simple and consistent leads you to the Turing tarpit: you simplify the language by pushing all the complexity onto the programmer.",
    "parent": 44857003,
    "depth": 2
  },
  {
    "id": 44857460,
    "by": "MoltenMan",
    "timeISO": "2025-08-10T19:11:01.000Z",
    "textPlain": "I much prefer Pascal typing because it1. Allows type inference without a hacky 'auto' workaround like c++ and\n2. Is less ambiguous parsing wise. I.e. when you read 'MyClass x', MyClass could be a variable (in which case this is an error) or a type; it's impossible to know without context!",
    "parent": 44856243,
    "depth": 2
  },
  {
    "id": 44856339,
    "by": "SkiFire13",
    "timeISO": "2025-08-10T16:38:02.000Z",
    "textPlain": "> In C or C++ the type would take the place of that unnecessary `let`In my opinion the `let` is not so unnecessary. It clearly marks a statement that declares a variable, as opposed to other kind of statements, for example a function call.This is also why C++ need the \"most vexing parse\" ambiguity resolution.",
    "parent": 44856243,
    "depth": 2
  },
  {
    "id": 44856442,
    "by": "reactordev",
    "timeISO": "2025-08-10T16:52:36.000Z",
    "textPlain": "I’m in the same boat. It’s faster mentally to grok the type of something when it comes first. The name of the thing is less important (but still important!) than the type of the thing and so I prefer types to come before names.From a parser perspective, it’s easier to go name first so you can add it to the AST and pass it off to the type determiner to finish the declaration. So I get it. In typescript I believe it’s this way so parsers can just drop types all together to make it compatible with JavaScript (it’s still trivial to strip typing, though why would you?) without transpiling.In go, well, you have even more crazier conventions. Uppercase vs lowercase public vs private, no inheritance, a gc that shuns away performance minded devs.In the end, I just want a working std library that’s easy to use so I can build applications. I don’t care for:    type Add<A extends number, B extends number> = [\n      …Array<A>,\n      …Array<B>,\n    ][“length”]\n\nThis is the kind of abuse of the type system that drives me bonkers. You don’t have to be clever, just export a function. I don’t need a type to represent every state, I need intent.",
    "parent": 44856243,
    "depth": 2
  },
  {
    "id": 44856613,
    "by": "erk__",
    "timeISO": "2025-08-10T17:13:29.000Z",
    "textPlain": "Maybe it just have to do with what you are used to, it was one of the things that made me like Rust coming from F# it had the same `name : type` and `let mutable name` that I knew from there.",
    "parent": 44856243,
    "depth": 2
  },
  {
    "id": 44856810,
    "by": "AnimalMuppet",
    "timeISO": "2025-08-10T17:36:09.000Z",
    "textPlain": "I, too, go back up the code to find the type of a variable.  But I see the opposite problem:  if the type is first, then it becomes harder to find the line that declares the variable I'm interested in, because the variable name isn't first.  It's after the type, and the type could be \"int\" or it could be \"struct Frobnosticator\".  That is, the variable name is after a variable-length type, so I have to keep bouncing left to right to find the start of the variable name.",
    "parent": 44856243,
    "depth": 2
  },
  {
    "id": 44856686,
    "by": "Quekid5",
    "timeISO": "2025-08-10T17:21:19.000Z",
    "textPlain": "> I find that the most common reason I go back to check a variable declaration is to determine the type of the variable,Hover the mouse cursor over it. Any reasonable editor will show the type.> In Rust, in particular, this leads to some awkward syntactic verbosity, because mutable variables are declared with `let mut`, meaning that `let` is used in every declaration.Rust is very verbose for strange implementation reasons... namely to avoid parse ambiguities.> In C or C++ the type would take the place of that unnecessary `let`.OTOH, that means you can't reliably grep for declarations of a variable/function called \"foo\". Also consider why some people like using    auto foo(int blah) -> bool\n\nstyle. This was introduced because of template nonsense (how to declare a return type before the type parameters were known), but it makes a lot of sense and makes code more greppable. Generic type parameters make putting the return type at the front very weird -- reading order wise.Anyhoo...",
    "parent": 44856243,
    "depth": 2
  },
  {
    "id": 44856748,
    "by": "IshKebab",
    "timeISO": "2025-08-10T17:28:16.000Z",
    "textPlain": "Maybe if you've never tried formatting a traditional multiline string (e.g. in Python, C++ or Rust) before.If it isn't obvious, the problem is that you can't indent them properly because the indentation becomes part of the string itself.Some languages have magical \"removed the indent\" modes for strings (e.g. YAML) but they generally suck and just add confusion. This syntax is quite clear (at least with respect to indentation; not sure about the trailing newline - where does the string end exactly?).",
    "parent": 44856660,
    "depth": 2
  },
  {
    "id": 44856911,
    "by": "n42",
    "timeISO": "2025-08-10T17:49:23.000Z",
    "textPlain": "Zig does not really try to appeal to window shoppers. this is one of those controversial decisions that, once you become comfortable with the language by using it, you learn to appreciate.spoken as someone who found the syntax offensive when I first learned it.",
    "parent": 44856660,
    "depth": 2
  },
  {
    "id": 44857435,
    "by": "rybosome",
    "timeISO": "2025-08-10T19:07:23.000Z",
    "textPlain": "Visually I dislike the \\\\, but I see this solves the problem of multiline literals and indentation in a handy, unambiguous way. I’m not actually aware of any other language which solves this problem without a function.",
    "parent": 44856660,
    "depth": 2
  },
  {
    "id": 44856866,
    "by": "hardwaregeek",
    "timeISO": "2025-08-10T17:44:13.000Z",
    "textPlain": "My immediate thought was hmm, that's weird but pretty nice. The indentation problem indeed sucks and with a halfway decent syntax highlighter you can probably de-emphasize the `//` and make it less visually cluttered.",
    "parent": 44856660,
    "depth": 2
  },
  {
    "id": 44856952,
    "by": "throw10920",
    "timeISO": "2025-08-10T17:55:10.000Z",
    "textPlain": "It seems very reasonable and comes with several technical  and cognitive advantages. I think you're just having a knee-jerk emotional reaction because it's different than what you're used to, not because it's actually bad.",
    "parent": 44856660,
    "depth": 2
  },
  {
    "id": 44857028,
    "by": "conorbergin",
    "timeISO": "2025-08-10T18:04:58.000Z",
    "textPlain": "I think everyone has this reaction until they start using it, then it makes perfect sense, especially when using editors that have multiple cursors and can operate on selections.",
    "parent": 44856660,
    "depth": 2
  },
  {
    "id": 44856957,
    "by": "steveklabnik",
    "timeISO": "2025-08-10T17:55:57.000Z",
    "textPlain": "I had the exact opposite reaction.",
    "parent": 44856660,
    "depth": 2
  },
  {
    "id": 44857042,
    "by": "klas_segeljakt",
    "timeISO": "2025-08-10T18:07:09.000Z",
    "textPlain": "When I first read it I thought it was line comments.",
    "parent": 44856660,
    "depth": 2
  },
  {
    "id": 44856707,
    "by": "fcoury",
    "timeISO": "2025-08-10T17:24:07.000Z",
    "textPlain": "I really like zig but that syntax is indeed insane.",
    "parent": 44856660,
    "depth": 2
  },
  {
    "id": 44856203,
    "by": "flohofwoe",
    "timeISO": "2025-08-10T16:20:01.000Z",
    "textPlain": "The dot is just a placeholder for an inferred type, and IMHO that makes a lot of sense. E.g. you can either write this:    const p = Point{ .x = 123, .y = 234 };\n\n...or this:    const p: Point = .{ .x = 123, .y = 234 };\n\nWhen calling a function which expects a Point you can omit the verbose type:    takePoint(.{ .x = 123, .y = 234 });\n\nIn Rust I need to explicitly write the type:    takePoint(Point{ x: 123, y: 234);\n\n...and in nested struct initializations the inferred form is very handy, e.g. Rust requires you to write this (not sure if I got the syntax right):    const x = Rect{\n        top_left: Point{ x: 123, y: 234 },\n        bottom_right: Point{ x: 456, y: 456 },\n    };\n\n...but the compiler already knows that Rect consists of two nested Points, so what's the point of requiring the user to type that out? So in Zig it's just:    const x = Rect{\n        .top_left = .{ .x = 123, .y = 234 },\n        .bottom_right = .{ .x = 456, .y = 456 },\n    };\n\nRequiring the explicit type on everything can get noisy really fast in Rust.Of course the question is whether the leading dot in '.{' could be omitted, and personally I would be in favour of that. Apparently it simplifies the parser, but such implementation details should get in the way of convenience IMHO.And then there's `.x = 123` vs `x: 123`. The Zig form is copied from C99, the Rust form from Javascript. Since I write both a lot of C99 and Typescript I don't either form (and both Zig and Rust are not even close to the flexibility and convenience of the C99 designated initialization syntax unfortunately).Edit: fixed the Rust struct init syntax.",
    "parent": 44856126,
    "depth": 2
  },
  {
    "id": 44857130,
    "by": "Metasyntactic",
    "timeISO": "2025-08-10T18:19:46.000Z",
    "textPlain": "Just a minor correction (as I'm the author of c#'s raw string literal feature).The indentation of the final `       \"\"\"` line is what is removed from all other lines. Not the indentation of the first line. This allows the first line to be indented as well.Cheers, and I'm glad you like it. I thought we did a really good job with that feature :-)",
    "parent": 44856731,
    "depth": 2
  },
  {
    "id": 44856459,
    "by": "nine_k",
    "timeISO": "2025-08-10T16:54:30.000Z",
    "textPlain": "I personally find Go's bare syntax harder to parse when reading, and I spend more time reading code than typing it (even while writing).An excessively terse syntax becomes very unforgiving, when a typo is not noticed by the compiler / language server, but results in another syntactically correct but unexpected program, or registers as a cryptic error much farther downstream. Cases in point: CoffeeScript, J.",
    "parent": 44856377,
    "depth": 2
  },
  {
    "id": 44856766,
    "by": "IshKebab",
    "timeISO": "2025-08-10T17:30:30.000Z",
    "textPlain": "Removing stuff doesn't necessarily make the syntax better, otherwise we'd all use Lisp and the space bar wouldn't exist: https://en.wikipedia.org/wiki/Scriptio_continua",
    "parent": 44856377,
    "depth": 2
  },
  {
    "id": 44856457,
    "by": "tapirl",
    "timeISO": "2025-08-10T16:54:23.000Z",
    "textPlain": "Normal function declarations.This is indeed a point which makes Zig inflexible.",
    "parent": 44856197,
    "depth": 2
  },
  {
    "id": 44856706,
    "by": "jmull",
    "timeISO": "2025-08-10T17:23:57.000Z",
    "textPlain": "You can declare an anonymous struct that has a function and reference that function inline (if you want).There's a little more syntax than a dedicated language feature, but not a lot more.What's \"missing\" in zig that lambda implementations normally have is capturing. In zig that's typically accomplished with a context parameter, again typically a struct.",
    "parent": 44856197,
    "depth": 2
  },
  {
    "id": 44856325,
    "by": "tux1968",
    "timeISO": "2025-08-10T16:36:16.000Z",
    "textPlain": "Same as C, define a named function, and pass a pointer to the sorting function.",
    "parent": 44856197,
    "depth": 2
  },
  {
    "id": 44856407,
    "by": "flohofwoe",
    "timeISO": "2025-08-10T16:48:16.000Z",
    "textPlain": "You don't need operator overloading for vector and matrix math, see pretty much all GPU languages. What Zig is missing is a complete mapping of the Clang Extended Vector and Matrix extensions (instead of the quite limited `@Vector` type):https://clang.llvm.org/docs/LanguageExtensions.html#vectors-...https://clang.llvm.org/docs/LanguageExtensions.html#matrix-t...",
    "parent": 44856311,
    "depth": 2
  }
]
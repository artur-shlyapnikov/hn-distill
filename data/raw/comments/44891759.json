[
  {
    "id": 44892713,
    "by": "noelwelsh",
    "timeISO": "2025-08-13T19:27:29.000Z",
    "textPlain": "I saw a talk by someone from Google about their experiences using Rust in the Android team. Two points stuck out: they migrated many projects from Python, so performance can't have been that much of a concern, and in their surveys the features people liked most were basics like pattern matching and ADTs. My conclusion is that for a lot of tasks the benefit from Rust came from ML cicra 1990, not lifetimes etc. I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1] it could have been Rust. Unfortunately it fell into the gap between what academia could justify working on and what industry was willing to do.[1]: Practically speaking, the 31-bit Ints are annoying if you're trying to do any bit bashing, but aesthetically the double semicolons are an abomination and irk me far more.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44895652,
    "by": "birdfood",
    "timeISO": "2025-08-14T00:58:59.000Z",
    "textPlain": "OCaml is probably my favourite language.The most involved project I did with it was a CRUD app for organising Writer's Festivals.The app was 100% OCaml (ReasonML so I could get JSX) + Dream + HTMX + DataTables. I used modules to get reusable front end templates. I loved being able to make a change to one of my data models and have the compiler tell me almost instantly where the change broke the front end. The main value of the app was getting data out of excel into a structured database, but I was also able to provide templated and branded itineraries in .odt format, create in memory zipped downloads so that I didn't need to touch the server disk. I was really impressed by how much I could achieve with the ecosystem.But having to write all my database queries in strings and then marshal the data through types was tiring (and effectively not compile time type checked) and I had to roll my own auth. I often felt like I was having to work on things that were not core to the product I was trying to build.I've spent a few years bouncing around different languages and I think my take away is that there is no perfect language. They all suck in their own special way.Now I'm building an app just for me and I'm using Rails. Pretty much everything I've wanted to reach for has a good default answer. I really feel like I'm focused on what is relevant to the product I'm building and I'm thinking about things unrelated to language like design layout and actually shipping the thing.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44898287,
    "by": "JaggerJo",
    "timeISO": "2025-08-14T08:56:35.000Z",
    "textPlain": "DarkLang which was initially written in OCaml eventually switched to F#. From what I remember the main reasons were the library ecosystem and concurrency.I'm know .NET in and out, so I might be biased. Most of the boring parts have multiple good solutions that I can pick from. I don't have to spend time on things that are not essential to the problem I actually want to solve.I've used F# professionally for multiple years and maintain a quite popular UI library written in it. But even with .NET there still are gaps because of the smaller F# language ecosystem. Not everything \"just works\" between CLR languages - sometimes it's a bit more complicated.The main point I'm trying to make is that going off the beaten path (C#) for example also comes with a cost. That cost might or might not be offset by the more expressive language. It's important to know this so you are not surprised by it.With OCaml it's similar I'd say. You get a really powerful language, but you're off the beaten path. Sure, there are a few companies using it in production - but their use case might be different than yours. On Jane Streets Threads and Signals podcast they often talk about their really specific use cases.1: https://blog.darklang.com/new-backend-fsharp/",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44894751,
    "by": "pmahoney",
    "timeISO": "2025-08-13T22:43:19.000Z",
    "textPlain": "I tried to like OCaml for a few years. The things that hold me back the most are niggling things that are largely solved in more \"modern\" langs, the biggest being the inability to \"print\" arbitrary objects.There are ppx things that can automatically derive \"to string\" functions, but it's a bit of effort to set up, it's not as nice to use as what's available in Rust, and it can't handle things like Set and Map types without extra work, e.g. [1] (from 2021 so situation may have changed).Compare to golang, where you can just use \"%v\" and related format strings to print nearly anything with zero effort.[1] https://discuss.ocaml.org/t/ppx-deriving-implementation-for-...",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892053,
    "by": "_mu",
    "timeISO": "2025-08-13T18:28:17.000Z",
    "textPlain": "I haven't worked in OCaml but I have worked a bit in F# and found it to be a pleasant experience.One thing I am wondering about in the age of LLMs is if we should all take a harder look at functional languages again. My thought is that if FP languages like OCaml / Haskell / etc. let us compress a lot of information into a small amount of text, then that's better for the context window.Possibly we might be able to put much denser programs into the model and one-shot larger changes than is achievable in languages like Java / C# / Ruby / etc?",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892977,
    "by": "garbthetill",
    "timeISO": "2025-08-13T19:49:43.000Z",
    "textPlain": "What a brilliant article, it really puts to rest for me, the whole “why not use F#?” argument. In almost every OCaml thread, someone suggests F# as a way to sidestep OCaml’s tooling.I’ve always been curious about OCaml, especially since some people call it “Go with types” and I’m not a fan of writing Rust. But I’m still not sold on OCaml as a whole, its evangelists just don’t win me over the way the Erlang, Ruby, Rust, or Zig folks do. I just cant see the vision",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44893525,
    "by": "jasperry",
    "timeISO": "2025-08-13T20:34:36.000Z",
    "textPlain": "Question about terminology: Is it common to call higher-order function types \"exponential types\" as the article does? I know what higher-order functions are, but am having trouble grasping why the types would be called \"exponential\".",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44897845,
    "by": "tempodox",
    "timeISO": "2025-08-14T07:48:27.000Z",
    "textPlain": "The best bird's eye overview of OCaml I've seen yet.  As a long-time OCaml user, I find it entirely fair.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892051,
    "by": "ackfoobar",
    "timeISO": "2025-08-13T18:28:14.000Z",
    "textPlain": "> Sum types: For example, Kotlin and Java (and de facto C#) use a construct associated with inheritance relations called sealing.This has the benefit of giving you the ability to refer to a case as its own type.> the expression of sums verbose and, in my view, harder to reason about.You declare the sum type once, and use it many times. Slightly more verbose sum type declaration is worth it when it makes using the cases cleaner.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892829,
    "by": "nine_k",
    "timeISO": "2025-08-13T19:37:21.000Z",
    "textPlain": "I wish somebody with this amount of experience would compare the benefits / shortcomings of using the ReasonML syntax. (The article mentions it once, in passing.)",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892121,
    "by": "raphinou",
    "timeISO": "2025-08-13T18:34:37.000Z",
    "textPlain": "Some years ago I also wanted to make ocaml my primary language, but rapidly encountered problems: difficulty to install (on Linux due to the requirement of a very unusual tool which name and function I forgot), no response from community regarding how to solve that problem, no solid postgresql driver, ....Wanting to use a functional language I pivoted to fsharp, which was not the expected choice for me as I use Linux exclusively. I have been happy with this choice, it has even become my preferred language. The biggest problem for me was the management of the fsharp community, the second class citizen position of fsharp in the DotNet ecosystem, and Microsoft's action screwing the goodwill of the dev community (eg hot reload episode). I feel this hampered the growth of the fsharp community.I'm now starting to use rust, and the contrast on these points couldn't be bigger.Edit: downvoters, caring to share why? I thought sharing my experience would have been appreciated. Would like to know why I was wrong.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44895588,
    "by": "chris_armstrong",
    "timeISO": "2025-08-14T00:46:40.000Z",
    "textPlain": "As someone who uses OCaml for hobby projects, I appreciate how little the language gets in your way when you want to just “get shit done”, despite the language’s origins in academia and industrial uses.The type system usually means that I might take longer to get my code to compile, but that I won’t spend much (if any) time debugging it once I’m done.I’m in the middle of pulling together bits of a third party library and refactoring them over several days work, and I’m pretty confident that most of the issues I’ll face when done will be relatively obvious runtime ones.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44896063,
    "by": "rybosome",
    "timeISO": "2025-08-14T02:15:31.000Z",
    "textPlain": "I’d have liked to see the use of dependency injection via the effects system expanded upon. The idea that the example program could use pattern matching to bind to either test values or production ones is interesting, but I can’t conceptualize what that would look like with the verbal description alone.Also, I had no idea that the module system had its own type system, that’s wild.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44893872,
    "by": "zem",
    "timeISO": "2025-08-13T21:09:28.000Z",
    "textPlain": "ocaml is one of my favourite languages too, but I've found myself being drawn towards rust for my latest project due to its major superpower - you can write a rust library that looks like a c library from the outside, and can be called from other languages via their existing c ffi mechanisms. I feel like by writing the library in ocaml I would have a better experience developing it, but be giving up on that free interop.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44893365,
    "by": "manoDev",
    "timeISO": "2025-08-13T20:21:00.000Z",
    "textPlain": "I'm sure there's merit to the language, but the syntax seems absolutely alien to me. Some attempt to look like verbose imperative code, a bunch of semicolons, and for some strange reason, hate of parenthesis.Real life sample:    let print_expr exp =\n        (* Local function definitions *)\n        let open_paren prec op_prec =\n          if prec > op_prec then print_string \"(\" in\n        let close_paren prec op_prec =\n          if prec > op_prec then print_string \")\" in\n        let rec print prec exp =     (* prec is the current precedence *)\n          match exp with\n            Const c -> print_float c\n          | Var v -> print_string v\n          | Sum(f, g) ->\n              open_paren prec 0;\n              print 0 f; print_string \" + \"; print 0 g;\n              close_paren prec 0\n          | Diff(f, g) ->\n              open_paren prec 0;\n              print 0 f; print_string \" - \"; print 1 g;\n              close_paren prec 0\n          | Prod(f, g) ->\n              open_paren prec 2;\n              print 2 f; print_string \" * \"; print 2 g;\n              close_paren prec 2\n          | Quot(f, g) ->\n              open_paren prec 2;\n              print 2 f; print_string \" / \"; print 3 g;\n              close_paren prec 2\n        in print 0 exp;;\n\nA function is defined as:    let print_expr exp =\n\nThat seems pretty hard to read at a glance, and easy to mistype as a definition.Also, you need to end the declaration with `in`?Then, semicolons...    open_paren prec 0;\n    print 0 f; print_string \" + \"; print 0 g;\n\n... and even double semicolons ...    print 0 exp;;\n\nThat looks like a language you really want an IDE helping you with.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892513,
    "by": "loxs",
    "timeISO": "2025-08-13T19:08:48.000Z",
    "textPlain": "I migrated from OCaml to Rust around 2020, haven't looked back. Although Rust is quite a lot less elegant and has some unpleasant deficiencies (lambdas, closures, currying)... and I end up having to close one one eye sometimes and clone some large data-structure to make my life easier... But regardless, its huge ecosystem and great tooling allows me to build things comparatively so easily, that OCaml has no chance. As a bonus, the end result is seriously faster - I know because I rewrote one of my projects and for some time I had feature parity between the OCaml and Rust versions.Nevertheless, I have fond memories of OCaml and a great amount of respect for the language design. Haven't checked on it since, probably should. I hope part of the problems have been solved.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44898040,
    "by": "sparkie",
    "timeISO": "2025-08-14T08:17:26.000Z",
    "textPlain": "> At present, I don’t know anyone who has seriously used languages like OCaml or Haskell and was happy to return to languages with less sophisticated type systems (though an interesting project can sometimes justify such a technological regression).Recovered typeaholic here. I still occasionally use OCaml and I primarily wrote F# and Haskell for years. I've been quite deep down the typing rabbit hole, and I used to scorn at dynamically typed languages.Now I love dynamic typing - but not the Python kind - I prefer the Scheme kind - latent typing. More specifically, the Kernel[1] kind, which is incredibly powerful.> I think the negative reputation of static type checking usually stems from a bad experience.I think this goes two ways. Most people's experience with dynamic typing is the Python kind, and not the Kernel kind.To be clear, I am not against static typing, and I love OCaml - but there are clear cases where static typing is the wrong tool - or rather, no static typing system is sufficient to express problems that are trivial to write correctly with the right dynamic types.Moreover, some problems are inherently dynamic. Take for example object-capabilities (aka, security done right). Capabilities can be revoked at any time. It makes no sense to try and encode capabilities into a static type system - but I had such silly thoughts when I was a typeaholic, and I regularly see people making the same mistake. Wouldn't it be better to have a type system which can express things which are dynamic by nature?And this is my issue with purely statically typed systems: They erase the types! I don't want to erase the types - I want the types to be available at runtime so that I can do things with them that I couldn't do at compile time - without me having to write a whole new interpreter.My preference is for Gradual Typing[2], which lets us use both worlds. Gradual typing is static typing with a `dynamic` type in the type system, and sensible rules for converting between dy",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892046,
    "by": "shortrounddev2",
    "timeISO": "2025-08-13T18:27:50.000Z",
    "textPlain": "OCaml is a great language without great tooling. Desperately needs a good LSP implementation to run breakpoints and other debugging tools on VSCode or other LSP-aware IDEs. I know there ARE tools available but there isn't great support for them and they don't work well",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44894835,
    "by": "vram22",
    "timeISO": "2025-08-13T22:53:38.000Z",
    "textPlain": "Is OCaml somewhat suitable for desktop GUI app programming?I saw this in the OP:>For example, creating a binding with the Tk libraryand had also been thinking about this separately a few days ago, hence the question.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44897950,
    "by": "amelius",
    "timeISO": "2025-08-14T08:05:48.000Z",
    "textPlain": "Do they have a decent GUI library / binding yet?",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892537,
    "by": "FrustratedMonky",
    "timeISO": "2025-08-13T19:11:15.000Z",
    "textPlain": "In F# comparison.  Modules \"my opinion, strongly justify preferring one over the other\".Strong stance on Modules.  My ignorance, what do they do that provides that much benefit.  ??",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44894915,
    "by": "pshirshov",
    "timeISO": "2025-08-13T23:03:55.000Z",
    "textPlain": "Extremely dated. No HKTs, no typeclasses (modules are not a good substitute), no call-site expansion.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892011,
    "by": "moi2388",
    "timeISO": "2025-08-13T18:25:03.000Z",
    "textPlain": "If I wanted to program in OCaml, id program in F# instead",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44898511,
    "by": "StopDisinfo910",
    "timeISO": "2025-08-14T09:34:43.000Z",
    "textPlain": "> I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1]OCaml had its act together. It was significantly nicer than Python when I used it professionally in 2010. Just look at what JaneStreet achieved with it.The main impediment to OCaml was always that it was not American nor mainly developed from the US.People like to believe there is some technical merit to language popularity but the reality it’s all fashion based. Rust is popular because they did a ton of outreach. They used to pay someone full time to mostly toot their horn.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892960,
    "by": "nine_k",
    "timeISO": "2025-08-13T19:48:26.000Z",
    "textPlain": "I'd say that Google strives to have a reasonably short list of languages approved for production-touching code. Rust can replace / complement C++, while OCaml cannot (it could replace Go instead... fat chance!). So I suspect that the team picked Rust because it was the only blessed language with ADTs, not because they won't like something with faster compile times.No way OCaml could have stolen the Rust's thunder: we have a number of very decent and performant GC-based languages, from Go to Haskell; we only had one bare-metal-worthy expressive language in 2010, C++, and it was pretty terrible (still is, but before C++11 and C++17 it was even more terrible).",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44898293,
    "by": "IshKebab",
    "timeISO": "2025-08-14T08:58:09.000Z",
    "textPlain": "I agree. If OCaml had solved some of its bigger paper cuts it could have been a real player. Compilation time is much better than Rust too:* OPAM is quite buggy and extremely confusing.* Windows support is very bad. If you ever tried to use Perl on Windows back in the day... it's worse than that.* Documentation is terse to the point of uselessness.* The syntax style is quite hard to mentally parse and also not very recoverable. If you miss some word or character the error can be \"the second half of the file has a syntax error\". Not very fun. Rust's more traditional syntax is much easier to deal with.Rust basically has none of those issues. Really the only advantage I can see with OCaml today is compile time, which is important, but it's definitely not important enough to make me want to use OCaml.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44897574,
    "by": "pjmlp",
    "timeISO": "2025-08-14T07:08:18.000Z",
    "textPlain": "That is why if I feel like doing ML style programing I rather reach out for Kotlin, Scala or F# than Rust, and even then Java and C# have gotten enough inspiration that I can also feel at home while using them.I am no strage to ML type systems, my first one was Caml Light, OCaml was still known as Objective Caml, and Mirada was still something being discussed on programming language lectures on my university.From what I see, I also kind of find the same, too many people rush out for Rust thinking that ML type systems is something new introduced by Rust, without having the background where all comes from.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44895407,
    "by": "gerdesj",
    "timeISO": "2025-08-14T00:11:12.000Z",
    "textPlain": "\"I feel if OCaml had got its act together ...\"The great thing is we have choice.  We have a huge number of ways to express ideas and ... do them!I might draw a parallel with the number of spoken languages extent in the UK (only ~65M people).  You are probably familiar with English.  There are rather a lot more languages here.  Irish, Scottish, Welsh - these are the thriving Brythonic languages (and they probably have some sub-types).  Cornish formally died out in the sixties (the last two sisters that spoke it natively, passed away) but it has been revived by some locals and given that living people who could communicate with relos with first hand experience, I think we can count that a language that is largely saved.  Cumbric ... counting still used by shepherds - something like: yan, tan, tithera toe.I am looking at OCAML because I'm the next generation to worry about genealogy in my family and my uncle has picked Geneweb to store the data, taking over from TMG - a Windows app.  His database contains roughly 140,000 individuals.  Geneweb is programmed in OCAML.If you think that programming languages are complicated ... have a go at genealogy.  You will soon discover something called GEDCOM and then you will weep!",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892798,
    "by": "unstruktured",
    "timeISO": "2025-08-13T19:34:43.000Z",
    "textPlain": "There is absolutely no reason to use double semicolons in practice. The only place you really should see it is when using the repl.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44894630,
    "by": "yodsanklai",
    "timeISO": "2025-08-13T22:28:47.000Z",
    "textPlain": "> aesthetically the double semicolons are an abomination and irk me far more.I think they have been optional for like 20 years, except in the top-level interactive environment to force execution.That being said, I still don't get why people are so much upset with the syntax. You'll integrate it after a week writing OCaml code.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44896362,
    "by": "shpongled",
    "timeISO": "2025-08-14T03:08:59.000Z",
    "textPlain": "As someone who loves SML/OCaml and has written primarily Rust over the past ~10 years, I totally agree - I use it as a modern and ergonomic ML with best-in-class tooling, libraries, and performance. Lifetimes are cool, and I use them when needed, but they aren't the reason I use Rust at all. I would use Rust with a GC instead of lifetimes too.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44894357,
    "by": "munificent",
    "timeISO": "2025-08-13T21:58:33.000Z",
    "textPlain": "> I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1] it could have been Rust. Arguably, that could have been Scala and for a while it seemed like it would be Scala but then it kind of just... didn't.I suspect some of that was that the programming style of some high profile Scala packages really alienated people by pushing the type system and operator overloading much farther than necessary.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44899939,
    "by": "le-mark",
    "timeISO": "2025-08-14T13:08:57.000Z",
    "textPlain": "The way ocaml mashes the object syntax into sml was always most annoying to me. It was also pretty weak on the systems programming side (threads, sockets, signals, fork) 20-30 years ago iirc. That’s probably changed by now. Multi core; not many runtimes handle this today so that’s not much of a hindrance IME.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44898212,
    "by": "ubercore",
    "timeISO": "2025-08-14T08:42:52.000Z",
    "textPlain": "I've only forayed into rust a bit, but I agree. I would happily take a language like Rust that sacrifices some speed for simpler semantics around ownership/lifetimes.Just Arc, clone and panic your way to success! :)",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44900381,
    "by": "ezst",
    "timeISO": "2025-08-14T13:52:50.000Z",
    "textPlain": "I feel that whatever \"OCaml - the good parts\" might be, it lives through Scala today. It's syntactically familiar/pleasing, it deals equally well with your high throughput (JVM), low-footprint (scala-native), web (scala-js/scala-wasm), small script to large monolith needs equally well, and its tooling/community support is orders of magnitude better than the other functional-first \"popular\" languages (OCaml, Haskell, Clojure, …).",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44897444,
    "by": "omcnoe",
    "timeISO": "2025-08-14T06:47:33.000Z",
    "textPlain": "The issue regarding academia is that functional programming is treated as an afterthought/sideshow that is mainly of interest for research. Almost no-one is teaching FP concepts to undergrads.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44896729,
    "by": "rtpg",
    "timeISO": "2025-08-14T04:27:13.000Z",
    "textPlain": "I think people like ADTs and pattern matching that Rust gives, but really the way that Rust becomes even more pleasant is that you have _so many_ trait methods on standard library objects that offer succinct answers to common patterns.Haskell of course has some of this, but immutability means that Haskell doesn't have to have answers for lots of things. And you want pattern matching as your basic building block, but at the end of the day most of your code won't have pattern matching and will instead rely on higher level patterns (that can build off of ADTs providing some degree of certainty on totality etc)",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44893725,
    "by": "the__alchemist",
    "timeISO": "2025-08-13T20:55:45.000Z",
    "textPlain": "I'm with you. I think some of the nicest parts of rust have nothing to do with memory safety; they're ways to structure your program as you mention.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892853,
    "by": "garbthetill",
    "timeISO": "2025-08-13T19:39:01.000Z",
    "textPlain": "doesnt rust still have the advantage of having no gc? I dont like writing rust, but the selling point of being able to write performative code with memory safety guarantees has always stuck with me",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44897606,
    "by": "fulafel",
    "timeISO": "2025-08-14T07:12:50.000Z",
    "textPlain": "Anyone have a link to the Android talk?\nI wonder if it was backend code or on-device code. On device you could probably justify the compromises of a no-GC language better.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44895808,
    "by": "lmm",
    "timeISO": "2025-08-14T01:26:15.000Z",
    "textPlain": "> I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1] it could have been Rust.No, that wouldn't have made the difference. No-one didn't pick up OCaml because it didn't have multicore or they were annoyed by the semicolons.People don't switch languages because the new language is \"old language but better\". They switch languages because a) new language does some unique thing that the old language didn't do, even if the unique thing is useless and irrelevant, b) new language has a bigger number than old language on benchmarks, even if the benchmark is irrelevant to your use case, or c) new language claims to have great interop with old language, even if this is a lie.There is no way OCaml could have succeeded in the pop culture that is programming language popularity. Yes, all of the actual reasons to use Rust apply just as much to OCaml and if our industry operated on technical merit we would have migrated to OCaml decades ago. But it doesn't so we didn't.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44896760,
    "by": "sanderjd",
    "timeISO": "2025-08-14T04:34:11.000Z",
    "textPlain": "Yeah I was initially drawn to rust because I loved ocaml but wished it were more practical.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44895592,
    "by": "77pt77",
    "timeISO": "2025-08-14T00:47:46.000Z",
    "textPlain": "> I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1] it could have been RustThat's about the time-frame where I got into OCaml so I followed this up close.The biggest hindrance in my opinion is/was boxed types.Too much overhead for low level stuff, although there was a guy from oxbridge doing GL stuff with it.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44893511,
    "by": "troupo",
    "timeISO": "2025-08-13T20:33:12.000Z",
    "textPlain": "OCaml also needed the brief but bright ReasonML moment to add/fix/improve some of the syntax IIRC and work on user-friendly error messages. But this should've definitely happened much much earlier than it did.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892839,
    "by": "benreesman",
    "timeISO": "2025-08-13T19:37:52.000Z",
    "textPlain": "[flagged]",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44896751,
    "by": "throwaway127482",
    "timeISO": "2025-08-14T04:33:11.000Z",
    "textPlain": "Go's %v leaves a lot to be desired, even when using %+#v to print even more info. I wish there was a format string to deeply traverse into pointers. Currently I have to import go-spew for that, which is a huge annoyance.Python does it best from what I've seen so far, with its __repr__ method.",
    "parent": 44894751,
    "depth": 2
  },
  {
    "id": 44892596,
    "by": "jappgar",
    "timeISO": "2025-08-13T19:15:39.000Z",
    "textPlain": "That was my optimistic take before I started working on a large Haskell code base.Aside from the obvious problem that there's not enough FP in the training corpus, it seems like terser languages don't work all that well with LLMs.My guess is that verbosity actually helps the generation self-correct... if it predicts some \"bad\" tokens it can pivot more easily and still produce working code.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892249,
    "by": "gf000",
    "timeISO": "2025-08-13T18:46:41.000Z",
    "textPlain": "My completely non-objective experiment of writing a simple CLI game in C++ and Haskell shows that the lines of code were indeed less in case of Haskell.. but the number of words were roughly the same, meaning the Haskell code just \"wider\" instead of \"higher\".And then I didn't even make this \"experiment\" with Java or another managed, more imperative language which could have shed some weight due to not caring about manual memory management.So not sure how much truth is in there - I think it differs based on the given program: some lend itself better for an imperative style, others prefer a more functional one.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44895176,
    "by": "Buttons840",
    "timeISO": "2025-08-13T23:38:33.000Z",
    "textPlain": "If LLMs get a little better at writing code, we might want to use really powerful type systems and effect systems to limit what they can do and ensure it is correct.For instance, dependent types allow us to say something like \"this function will return  a sorted list\", or even \"this function will return a valid Sudoku solution\", and these things will be checked at compile time--again, at compile time.Combine this with an effect system and we can suddenly say things like \"this function will return a valid Sudoku solution, and it will not access the network or filesystem\", and then you let the LLM run wild. You don't even have to review the LLM output, if it produces code that compiles, you know it works, and you know it doesn't access the network or filesystem.Of course, if LLMs get a lot better, they can probably just do all this in Python just as well, but if they only get a little better, then we might want to build better deterministic systems around the unreliable LLMs to make them reliable.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44897793,
    "by": "gylterud",
    "timeISO": "2025-08-14T07:40:55.000Z",
    "textPlain": "I have found that Haskell has two good things going for it when it comes to LLM code generation. Both have to do with correctness.The expressive type system catches a lot of mistakes, and the fact that they are compile errors which can be fed right into the LLM again means that incorrect code is caught early.The second is property based testing. With it I have had the LLM generate amazingly efficient, correct code, by iteratively making it more and more efficient – running quickcheck on each pass. The LLM is not super good at writing the tests, but if you add some yourself, you quickly root out any mistakes in the generated code.",
    "parent": 44892053,
    "depth": 2
  }
]
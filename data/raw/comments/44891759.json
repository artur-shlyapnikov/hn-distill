[
  {
    "id": 44892053,
    "by": "_mu",
    "timeISO": "2025-08-13T18:28:17.000Z",
    "textPlain": "I haven't worked in OCaml but I have worked a bit in F# and found it to be a pleasant experience.One thing I am wondering about in the age of LLMs is if we should all take a harder look at functional languages again. My thought is that if FP languages like OCaml / Haskell / etc. let us compress a lot of information into a small amount of text, then that's better for the context window.Possibly we might be able to put much denser programs into the model and one-shot larger changes than is achievable in languages like Java / C# / Ruby / etc?",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892121,
    "by": "raphinou",
    "timeISO": "2025-08-13T18:34:37.000Z",
    "textPlain": "Some years ago I also wanted to make ocaml my primary language, but rapidly encountered problems: difficulty to install (on Linux due to the requirement of a very unusual tool which name and function I forgot), no response from community regarding how to solve that problem, no solid postgresql driver, ....Wanting to use a functional language I pivoted to fsharp, which was not the expected choice for me as I use Linux exclusively. I have been happy with this choice, it has even become my preferred language. The biggest problem for me was the management of the fsharp community, the second class citizen position of fsharp in the DotNet ecosystem, and Microsoft's action screwing the goodwill of the dev community (eg hot reload episode). I feel this hampered the growth of the fsharp community.I'm now starting to use rust, and the contrast on these points couldn't be bigger.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892051,
    "by": "ackfoobar",
    "timeISO": "2025-08-13T18:28:14.000Z",
    "textPlain": "> Sum types: For example, Kotlin and Java (and de facto C#) use a construct associated with inheritance relations called sealing.This has the benefit of giving you the ability to refer to a case as its own type.> the expression of sums verbose and, in my view, harder to reason about.You declare the sum type once, and use it many times. Slightly more verbose sum type declaration is worth it when it makes using the cases cleaner.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892537,
    "by": "FrustratedMonky",
    "timeISO": "2025-08-13T19:11:15.000Z",
    "textPlain": "In F# comparison.  Modules \"my opinion, strongly justify preferring one over the other\".Strong stance on Modules.  My ignorance, what do they do that provides that much benefit.  ??",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892046,
    "by": "shortrounddev2",
    "timeISO": "2025-08-13T18:27:50.000Z",
    "textPlain": "OCaml is a great language without great tooling. Desperately needs a good LSP implementation to run breakpoints and other debugging tools on VSCode or other LSP-aware IDEs. I know there ARE tools available but there isn't great support for them and they don't work well",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892513,
    "by": "loxs",
    "timeISO": "2025-08-13T19:08:48.000Z",
    "textPlain": "I migrated from OCaml to Rust around 2020, haven't looked back. Although Rust is quite a lot less elegant and has some unpleasant deficiencies (lambdas, closures, currying)... and I end up having to close one one eye sometimes and clone some large data-structure to make my life easier... But regardless, its huge ecosystem and great tooling allows me to build things comparatively so easily, that OCaml has no chance. As a bonus, the end result is seriously faster - I know because I rewrote one of my projects and for some time I had feature parity between the OCaml and Rust versions.Nevertheless, I have fond memories of OCaml and a great amount of respect for the language design. Haven't checked on it since, probably should. I hope part of the problems have been solved.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892011,
    "by": "moi2388",
    "timeISO": "2025-08-13T18:25:03.000Z",
    "textPlain": "If I wanted to program in OCaml, id program in F# instead",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892596,
    "by": "jappgar",
    "timeISO": "2025-08-13T19:15:39.000Z",
    "textPlain": "That was my optimistic take before I started working on a large Haskell code base.Aside from the obvious problem that there's not enough FP in the training corpus, it seems like terser languages don't work all that well with LLMs.My guess is that verbosity actually helps the generation self-correct... if it predicts some \"bad\" tokens it can pivot more easily and still produce working code.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892249,
    "by": "gf000",
    "timeISO": "2025-08-13T18:46:41.000Z",
    "textPlain": "My completely non-objective experiment of writing a simple CLI game in C++ and Haskell shows that the lines of code were indeed less in case of Haskell.. but the number of words were roughly the same, meaning the Haskell code just \"wider\" instead of \"higher\".And then I didn't even make this \"experiment\" with Java or another managed, more imperative language which could have shed some weight due to not caring about manual memory management.So not sure how much truth is in there - I think it differs based on the given program: some lend itself better for an imperative style, others prefer a more functional one.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892175,
    "by": "d4mi3n",
    "timeISO": "2025-08-13T18:39:14.000Z",
    "textPlain": "I think this is putting the cart before the horse. Programs are generally harder to read than they are to write, so optimizing for concise output to benefit the tool at the potential expense of the human isn't a trade I'd personally make.Granted, this may just be an argument for being more comfortable reading/writing code in a particular style, but even without the advantages of LLMs adoption of functional paradigms and tools has been a struggle.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892134,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:35:22.000Z",
    "textPlain": "To be completely honest, I currently only use LLMs to assist me in writing documentation (and translating articles), but I know that other people are looking into it: https://anil.recoil.org/wiki?t=%23projects",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892280,
    "by": "esafak",
    "timeISO": "2025-08-13T18:49:33.000Z",
    "textPlain": "I think LLMs benefit from training examples, static typing, and an LSP implementation more than terseness.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892232,
    "by": "johnisgood",
    "timeISO": "2025-08-13T18:45:19.000Z",
    "textPlain": "> difficulty to installUse opam: https://opam.ocaml.org or https://opam.ocaml.org/doc/Install.html.Additionally, see: https://ocaml.org/install#linux_mac_bsd and https://ocaml.org/docs/set-up-editor.It is easy to set up with Emacs, for example. VSCodium has OCaml extension as well.All you need for the OCaml compiler is opam, it handles all the packages and the compiler.For your project, use dune: https://dune.readthedocs.io/en/stable/quick-start.html.",
    "parent": 44892121,
    "depth": 2
  },
  {
    "id": 44892214,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:43:59.000Z",
    "textPlain": "In the specific case of OCaml, this is also possible using indexing and GADTs or polymorphic variants. But generally, referencing as its own type serves different purposes. From my point of view, distinguishing between sum branches often tends to result in code that is difficult to reason about and difficult to generalise due to concerns about variance and loss of type equality.",
    "parent": 44892051,
    "depth": 2
  },
  {
    "id": 44892151,
    "by": "wiseowise",
    "timeISO": "2025-08-13T18:36:36.000Z",
    "textPlain": "> Slightly more verbose sum type declaration is worth it *when it makes using the cases cleaner.*Correct. This is not the case when you talk about Java/Kotlin. Just ugliness and typical boilerplate heavy approach of JVM languages.",
    "parent": 44892051,
    "depth": 2
  },
  {
    "id": 44892562,
    "by": "debugnik",
    "timeISO": "2025-08-13T19:13:21.000Z",
    "textPlain": "[delayed]",
    "parent": 44892046,
    "depth": 2
  },
  {
    "id": 44892077,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:30:51.000Z",
    "textPlain": "Indeed, efforts should be made in terms of DAP (https://microsoft.github.io/debug-adapter-protocol//), extending the following experimentation: https://lambdafoo.com/posts/2024-03-25-ocaml-debugging-with-.... However, I find the assertion about tooling a bit exaggerated, don't you?",
    "parent": 44892046,
    "depth": 2
  },
  {
    "id": 44892114,
    "by": "dismalaf",
    "timeISO": "2025-08-13T18:34:08.000Z",
    "textPlain": "??  OCaml has had a completion engine for as long as I can remember (definitely over a decade) and it powers their LSP these days.  I do know however that the community focuses mostly on Vim and Emacs.",
    "parent": 44892046,
    "depth": 2
  },
  {
    "id": 44892040,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:27:18.000Z",
    "textPlain": "Hi! Thank you for your interest (and for potentially reading this).Yes, F# is a very nice language, however, it seems to me that I am making a somewhat forced comparison between OCaml and F# in the following section: https://xvw.lol/en/articles/why-ocaml.html#ocaml-and-f",
    "parent": 44892011,
    "depth": 2
  }
]
[
  {
    "id": 44892713,
    "by": "noelwelsh",
    "timeISO": "2025-08-13T19:27:29.000Z",
    "textPlain": "I saw a talk by someone from Google about their experiences using Rust in the Android team. Two points stuck out: they migrated many projects from Python, so performance can't have been that much of a concern, and in their surveys the features people liked most were basics like pattern matching and ADTs. My conclusion is that for a lot of tasks the benefit from Rust came from ML cicra 1990, not lifetimes etc. I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1] it could have been Rust. Unfortunately it fell into the gap between what academia could justify working on and what industry was willing to do.[1]: Practically speaking, the 31-bit Ints are annoying if you're trying to do any bit bashing, but aesthetically the double semicolons are an abomination and irk me far more.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44894751,
    "by": "pmahoney",
    "timeISO": "2025-08-13T22:43:19.000Z",
    "textPlain": "I tried to like OCaml for a few years. The things that hold me back the most are niggling things that are largely solved in more \"modern\" langs, the biggest being the inability to \"print\" arbitrary objects.There are ppx things that can automatically derive \"to string\" functions, but it's a bit of effort to set up, it's not as nice to use as what's available in Rust, and it can't handle things like Set and Map types without extra work, e.g. [1] (from 2021 so situation may have changed).Compare to golang, where you can just use \"%v\" and related format strings to print nearly anything with zero effort.[1] https://discuss.ocaml.org/t/ppx-deriving-implementation-for-...",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44895652,
    "by": "birdfood",
    "timeISO": "2025-08-14T00:58:59.000Z",
    "textPlain": "OCaml is probably my favourite language.The most involved project I did with it was a CRUD app for organising Writer's Festivals.The app was 100% OCaml (ReasonML so I could get JSX) + Dream + HTMX + DataTables. I used modules to get reusable front end templates. I loved being able to make a change to one of my data models and have the compiler tell me almost instantly where the change broke the front end. The main value of the app was getting data out of excel into a structured database, but I was also able to provide templated and branded itineraries in .odt format, create in memory zipped downloads so that I didn't need to touch the server disk. I was really impressed by how much I could achieve with the ecosystem.But having to write all my database queries in strings and then marshal the data through types was tiring (and effectively not compile time type checked) and I had to roll my own auth. I often felt like I was having to work on things that were not core to the product I was trying to build.I've spent a few years bouncing around different languages and I think my take away is that there is no perfect language. They all suck in their own special way.Now I'm building an app just for me and I'm using Rails. Pretty much everything I've wanted to reach for has a good default answer. I really feel like I'm focused on what is relevant to the product I'm building and I'm thinking about things unrelated to language like design layout and actually shipping the thing.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892053,
    "by": "_mu",
    "timeISO": "2025-08-13T18:28:17.000Z",
    "textPlain": "I haven't worked in OCaml but I have worked a bit in F# and found it to be a pleasant experience.One thing I am wondering about in the age of LLMs is if we should all take a harder look at functional languages again. My thought is that if FP languages like OCaml / Haskell / etc. let us compress a lot of information into a small amount of text, then that's better for the context window.Possibly we might be able to put much denser programs into the model and one-shot larger changes than is achievable in languages like Java / C# / Ruby / etc?",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892977,
    "by": "garbthetill",
    "timeISO": "2025-08-13T19:49:43.000Z",
    "textPlain": "What a brilliant article, it really puts to rest for me, the whole “why not use F#?” argument. In almost every OCaml thread, someone suggests F# as a way to sidestep OCaml’s tooling.I’ve always been curious about OCaml, especially since some people call it “Go with types” and I’m not a fan of writing Rust. But I’m still not sold on OCaml as a whole, its evangelists just don’t win me over the way the Erlang, Ruby, Rust, or Zig folks do. I just cant see the vision",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44893525,
    "by": "jasperry",
    "timeISO": "2025-08-13T20:34:36.000Z",
    "textPlain": "Question about terminology: Is it common to call higher-order function types \"exponential types\" as the article does? I know what higher-order functions are, but am having trouble grasping why the types would be called \"exponential\".",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892051,
    "by": "ackfoobar",
    "timeISO": "2025-08-13T18:28:14.000Z",
    "textPlain": "> Sum types: For example, Kotlin and Java (and de facto C#) use a construct associated with inheritance relations called sealing.This has the benefit of giving you the ability to refer to a case as its own type.> the expression of sums verbose and, in my view, harder to reason about.You declare the sum type once, and use it many times. Slightly more verbose sum type declaration is worth it when it makes using the cases cleaner.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892829,
    "by": "nine_k",
    "timeISO": "2025-08-13T19:37:21.000Z",
    "textPlain": "I wish somebody with this amount of experience would compare the benefits / shortcomings of using the ReasonML syntax. (The article mentions it once, in passing.)",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44895588,
    "by": "chris_armstrong",
    "timeISO": "2025-08-14T00:46:40.000Z",
    "textPlain": "As someone who uses OCaml for hobby projects, I appreciate how little the language gets in your way when you want to just “get shit done”, despite the language’s origins in academia and industrial uses.The type system usually means that I might take longer to get my code to compile, but that I won’t spend much (if any) time debugging it once I’m done.I’m in the middle of pulling together bits of a third party library and refactoring them over several days work, and I’m pretty confident that most of the issues I’ll face when done will be relatively obvious runtime ones.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44896063,
    "by": "rybosome",
    "timeISO": "2025-08-14T02:15:31.000Z",
    "textPlain": "I’d have liked to see the use of dependency injection via the effects system expanded upon. The idea that the example program could use pattern matching to bind to either test values or production ones is interesting, but I can’t conceptualize what that would look like with the verbal description alone.Also, I had no idea that the module system had its own type system, that’s wild.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892121,
    "by": "raphinou",
    "timeISO": "2025-08-13T18:34:37.000Z",
    "textPlain": "Some years ago I also wanted to make ocaml my primary language, but rapidly encountered problems: difficulty to install (on Linux due to the requirement of a very unusual tool which name and function I forgot), no response from community regarding how to solve that problem, no solid postgresql driver, ....Wanting to use a functional language I pivoted to fsharp, which was not the expected choice for me as I use Linux exclusively. I have been happy with this choice, it has even become my preferred language. The biggest problem for me was the management of the fsharp community, the second class citizen position of fsharp in the DotNet ecosystem, and Microsoft's action screwing the goodwill of the dev community (eg hot reload episode). I feel this hampered the growth of the fsharp community.I'm now starting to use rust, and the contrast on these points couldn't be bigger.Edit: downvoters, caring to share why? I thought sharing my experience would have been appreciated. Would like to know why I was wrong.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44893365,
    "by": "manoDev",
    "timeISO": "2025-08-13T20:21:00.000Z",
    "textPlain": "I'm sure there's merit to the language, but the syntax seems absolutely alien to me. Some attempt to look like verbose imperative code, a bunch of semicolons, and for some strange reason, hate of parenthesis.Real life sample:    let print_expr exp =\n        (* Local function definitions *)\n        let open_paren prec op_prec =\n          if prec > op_prec then print_string \"(\" in\n        let close_paren prec op_prec =\n          if prec > op_prec then print_string \")\" in\n        let rec print prec exp =     (* prec is the current precedence *)\n          match exp with\n            Const c -> print_float c\n          | Var v -> print_string v\n          | Sum(f, g) ->\n              open_paren prec 0;\n              print 0 f; print_string \" + \"; print 0 g;\n              close_paren prec 0\n          | Diff(f, g) ->\n              open_paren prec 0;\n              print 0 f; print_string \" - \"; print 1 g;\n              close_paren prec 0\n          | Prod(f, g) ->\n              open_paren prec 2;\n              print 2 f; print_string \" * \"; print 2 g;\n              close_paren prec 2\n          | Quot(f, g) ->\n              open_paren prec 2;\n              print 2 f; print_string \" / \"; print 3 g;\n              close_paren prec 2\n        in print 0 exp;;\n\nA function is defined as:    let print_expr exp =\n\nThat seems pretty hard to read at a glance, and easy to mistype as a definition.Also, you need to end the declaration with `in`?Then, semicolons...    open_paren prec 0;\n    print 0 f; print_string \" + \"; print 0 g;\n\n... and even double semicolons ...    print 0 exp;;\n\nThat looks like a language you really want an IDE helping you with.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44894915,
    "by": "pshirshov",
    "timeISO": "2025-08-13T23:03:55.000Z",
    "textPlain": "Extremely dated. No HKTs, no typeclasses (modules are not a good substitute), no call-site expansion.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44894835,
    "by": "vram22",
    "timeISO": "2025-08-13T22:53:38.000Z",
    "textPlain": "Is OCaml somewhat suitable for desktop GUI app programming?I saw this in the OP:>For example, creating a binding with the Tk libraryand had also been thinking about this separately a few days ago, hence the question.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44893872,
    "by": "zem",
    "timeISO": "2025-08-13T21:09:28.000Z",
    "textPlain": "ocaml is one of my favourite languages too, but I've found myself being drawn towards rust for my latest project due to its major superpower - you can write a rust library that looks like a c library from the outside, and can be called from other languages via their existing c ffi mechanisms. I feel like by writing the library in ocaml I would have a better experience developing it, but be giving up on that free interop.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892513,
    "by": "loxs",
    "timeISO": "2025-08-13T19:08:48.000Z",
    "textPlain": "I migrated from OCaml to Rust around 2020, haven't looked back. Although Rust is quite a lot less elegant and has some unpleasant deficiencies (lambdas, closures, currying)... and I end up having to close one one eye sometimes and clone some large data-structure to make my life easier... But regardless, its huge ecosystem and great tooling allows me to build things comparatively so easily, that OCaml has no chance. As a bonus, the end result is seriously faster - I know because I rewrote one of my projects and for some time I had feature parity between the OCaml and Rust versions.Nevertheless, I have fond memories of OCaml and a great amount of respect for the language design. Haven't checked on it since, probably should. I hope part of the problems have been solved.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892046,
    "by": "shortrounddev2",
    "timeISO": "2025-08-13T18:27:50.000Z",
    "textPlain": "OCaml is a great language without great tooling. Desperately needs a good LSP implementation to run breakpoints and other debugging tools on VSCode or other LSP-aware IDEs. I know there ARE tools available but there isn't great support for them and they don't work well",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892537,
    "by": "FrustratedMonky",
    "timeISO": "2025-08-13T19:11:15.000Z",
    "textPlain": "In F# comparison.  Modules \"my opinion, strongly justify preferring one over the other\".Strong stance on Modules.  My ignorance, what do they do that provides that much benefit.  ??",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892011,
    "by": "moi2388",
    "timeISO": "2025-08-13T18:25:03.000Z",
    "textPlain": "If I wanted to program in OCaml, id program in F# instead",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44897574,
    "by": "pjmlp",
    "timeISO": "2025-08-14T07:08:18.000Z",
    "textPlain": "That is why if I feel like doing ML style programing I rather reach out for Kotlin, Scala or F# than Rust, and even then Java and C# have gotten enough inspiration that I can also feel at home while using them.I am no strage to ML type systems, my first one was Caml Light, OCaml was still known as Objective Caml, and Mirada was still something being discussed on programming language lectures on my university.From what I see, I also kind of find the same, too many people rush out for Rust thinking that ML type systems is something new introduced by Rust, without having the background where all comes from.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892960,
    "by": "nine_k",
    "timeISO": "2025-08-13T19:48:26.000Z",
    "textPlain": "I'd say that Google strives to have a reasonably short list of languages approved for production-touching code. Rust can replace / complement C++, while OCaml cannot (it could replace Go instead... fat chance!). So I suspect that the team picked Rust because it was the only blessed language with ADTs, not because they won't like something with faster compile times.No way OCaml could have stolen the Rust's thunder: we have a number of very decent and performant GC-based languages, from Go to Haskell; we only had one bare-metal-worthy expressive language in 2010, C++, and it was pretty terrible (still is, but before C++11 and C++17 it was even more terrible).",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44897606,
    "by": "fulafel",
    "timeISO": "2025-08-14T07:12:50.000Z",
    "textPlain": "Anyone have a link to the Android talk?\nI wonder if it was backend code or on-device code. On device you could probably justify the compromises of a no-GC language better.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44897444,
    "by": "omcnoe",
    "timeISO": "2025-08-14T06:47:33.000Z",
    "textPlain": "The issue regarding academia is that functional programming is treated as an afterthought/sideshow that is mainly of interest for research. Almost no-one is teaching FP concepts to undergrads.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44896362,
    "by": "shpongled",
    "timeISO": "2025-08-14T03:08:59.000Z",
    "textPlain": "As someone who loves SML/OCaml and has written primarily Rust over the past ~10 years, I totally agree - I use it as a modern and ergonomic ML with best-in-class tooling, libraries, and performance. Lifetimes are cool, and I use them when needed, but they aren't the reason I use Rust at all. I would use Rust with a GC instead of lifetimes too.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44895407,
    "by": "gerdesj",
    "timeISO": "2025-08-14T00:11:12.000Z",
    "textPlain": "\"I feel if OCaml had got its act together ...\"The great thing is we have choice.  We have a huge number of ways to express ideas and ... do them!I might draw a parallel with the number of spoken languages extent in the UK (only ~65M people).  You are probably familiar with English.  There are rather a lot more languages here.  Irish, Scottish, Welsh - these are the thriving Brythonic languages (and they probably have some sub-types).  Cornish formally died out in the sixties (the last two sisters that spoke it natively, passed away) but it has been revived by some locals and given that living people who could communicate with relos with first hand experience, I think we can count that a language that is largely saved.  Cumbric ... counting still used by shepherds - something like: yan, tan, tithera toe.I am looking at OCAML because I'm the next generation to worry about genealogy in my family and my uncle has picked Geneweb to store the data, taking over from TMG - a Windows app.  His database contains roughly 140,000 individuals.  Geneweb is programmed in OCAML.If you think that programming languages are complicated ... have a go at genealogy.  You will soon discover something called GEDCOM and then you will weep!",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892798,
    "by": "unstruktured",
    "timeISO": "2025-08-13T19:34:43.000Z",
    "textPlain": "There is absolutely no reason to use double semicolons in practice. The only place you really should see it is when using the repl.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44894630,
    "by": "yodsanklai",
    "timeISO": "2025-08-13T22:28:47.000Z",
    "textPlain": "> aesthetically the double semicolons are an abomination and irk me far more.I think they have been optional for like 20 years, except in the top-level interactive environment to force execution.That being said, I still don't get why people are so much upset with the syntax. You'll integrate it after a week writing OCaml code.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44894357,
    "by": "munificent",
    "timeISO": "2025-08-13T21:58:33.000Z",
    "textPlain": "> I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1] it could have been Rust. Arguably, that could have been Scala and for a while it seemed like it would be Scala but then it kind of just... didn't.I suspect some of that was that the programming style of some high profile Scala packages really alienated people by pushing the type system and operator overloading much farther than necessary.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44896729,
    "by": "rtpg",
    "timeISO": "2025-08-14T04:27:13.000Z",
    "textPlain": "I think people like ADTs and pattern matching that Rust gives, but really the way that Rust becomes even more pleasant is that you have _so many_ trait methods on standard library objects that offer succinct answers to common patterns.Haskell of course has some of this, but immutability means that Haskell doesn't have to have answers for lots of things. And you want pattern matching as your basic building block, but at the end of the day most of your code won't have pattern matching and will instead rely on higher level patterns (that can build off of ADTs providing some degree of certainty on totality etc)",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44893725,
    "by": "the__alchemist",
    "timeISO": "2025-08-13T20:55:45.000Z",
    "textPlain": "I'm with you. I think some of the nicest parts of rust have nothing to do with memory safety; they're ways to structure your program as you mention.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892853,
    "by": "garbthetill",
    "timeISO": "2025-08-13T19:39:01.000Z",
    "textPlain": "doesnt rust still have the advantage of having no gc? I dont like writing rust, but the selling point of being able to write performative code with memory safety guarantees has always stuck with me",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44896760,
    "by": "sanderjd",
    "timeISO": "2025-08-14T04:34:11.000Z",
    "textPlain": "Yeah I was initially drawn to rust because I loved ocaml but wished it were more practical.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44895808,
    "by": "lmm",
    "timeISO": "2025-08-14T01:26:15.000Z",
    "textPlain": "> I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1] it could have been Rust.No, that wouldn't have made the difference. No-one didn't pick up OCaml because it didn't have multicore or they were annoyed by the semicolons.People don't switch languages because the new language is \"old language but better\". They switch languages because a) new language does some unique thing that the old language didn't do, even if the unique thing is useless and irrelevant, b) new language has a bigger number than old language on benchmarks, even if the benchmark is irrelevant to your use case, or c) new language claims to have great interop with old language, even if this is a lie.There is no way OCaml could have succeeded in the pop culture that is programming language popularity. Yes, all of the actual reasons to use Rust apply just as much to OCaml and if our industry operated on technical merit we would have migrated to OCaml decades ago. But it doesn't so we didn't.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44893511,
    "by": "troupo",
    "timeISO": "2025-08-13T20:33:12.000Z",
    "textPlain": "OCaml also needed the brief but bright ReasonML moment to add/fix/improve some of the syntax IIRC and work on user-friendly error messages. But this should've definitely happened much much earlier than it did.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44895592,
    "by": "77pt77",
    "timeISO": "2025-08-14T00:47:46.000Z",
    "textPlain": "> I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1] it could have been RustThat's about the time-frame where I got into OCaml so I followed this up close.The biggest hindrance in my opinion is/was boxed types.Too much overhead for low level stuff, although there was a guy from oxbridge doing GL stuff with it.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892839,
    "by": "benreesman",
    "timeISO": "2025-08-13T19:37:52.000Z",
    "textPlain": "[flagged]",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44896751,
    "by": "throwaway127482",
    "timeISO": "2025-08-14T04:33:11.000Z",
    "textPlain": "Go's %v leaves a lot to be desired, even when using %+#v to print even more info. I wish there was a format string to deeply traverse into pointers. Currently I have to import go-spew for that, which is a huge annoyance.Python does it best from what I've seen so far, with its __repr__ method.",
    "parent": 44894751,
    "depth": 2
  },
  {
    "id": 44892596,
    "by": "jappgar",
    "timeISO": "2025-08-13T19:15:39.000Z",
    "textPlain": "That was my optimistic take before I started working on a large Haskell code base.Aside from the obvious problem that there's not enough FP in the training corpus, it seems like terser languages don't work all that well with LLMs.My guess is that verbosity actually helps the generation self-correct... if it predicts some \"bad\" tokens it can pivot more easily and still produce working code.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892249,
    "by": "gf000",
    "timeISO": "2025-08-13T18:46:41.000Z",
    "textPlain": "My completely non-objective experiment of writing a simple CLI game in C++ and Haskell shows that the lines of code were indeed less in case of Haskell.. but the number of words were roughly the same, meaning the Haskell code just \"wider\" instead of \"higher\".And then I didn't even make this \"experiment\" with Java or another managed, more imperative language which could have shed some weight due to not caring about manual memory management.So not sure how much truth is in there - I think it differs based on the given program: some lend itself better for an imperative style, others prefer a more functional one.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44895176,
    "by": "Buttons840",
    "timeISO": "2025-08-13T23:38:33.000Z",
    "textPlain": "If LLMs get a little better at writing code, we might want to use really powerful type systems and effect systems to limit what they can do and ensure it is correct.For instance, dependent types allow us to say something like \"this function will return  a sorted list\", or even \"this function will return a valid Sudoku solution\", and these things will be checked at compile time--again, at compile time.Combine this with an effect system and we can suddenly say things like \"this function will return a valid Sudoku solution, and it will not access the network or filesystem\", and then you let the LLM run wild. You don't even have to review the LLM output, if it produces code that compiles, you know it works, and you know it doesn't access the network or filesystem.Of course, if LLMs get a lot better, they can probably just do all this in Python just as well, but if they only get a little better, then we might want to build better deterministic systems around the unreliable LLMs to make them reliable.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44894006,
    "by": "dkarl",
    "timeISO": "2025-08-13T21:21:14.000Z",
    "textPlain": "In Scala, I've had excellent luck using LLMs to speed up development when I'm using cats-effect, an effects library.My experience in the past with something like cats-effect has been that there are straightforward things that aren't obvious, and if you haven't been using it recently, and maybe even if you've been using it but haven't solved a similar problem recently, you can get stuck trawling through the docs squinting at type signatures looking for what turns out to be, in hindsight, an elegant and simple solution. LLMs have vastly reduced this kind of friction. I just ask, \"In cats-effect, how do I...?\" and 80% of the time the answer gets me immediately unstuck. The other 20% of the time I provide clarifying context or ask a different LLM.I haven't done enough maintenance coding yet to know if this will radically shift my view of the cost/benefit of functional programming with effects, but I'm very excited. Writing cats-effect code has always been satisfying and frustrating in equal measure, and so far, I'm getting the confidence and correctness with a fraction of the frustration.I haven't unleashed Claude Code on any cats-effect code yet. I'm curious to see how well it will do.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892773,
    "by": "sshine",
    "timeISO": "2025-08-13T19:32:31.000Z",
    "textPlain": "> My thought is that if FP languages like OCaml / Haskell / etc. let us compress a lot of information into a small amount of text, then that's better for the context window.Claude Code’s Haskell style is very verbose; if-then-elsey, lots of nested case-ofs, do-blocks at multiple levels of intension, very little naming things at top-level.Given a sample of a simple API client, and a request to do the same but for another API, it did very well.I concluded that I just have more opinions about Haskell than Java or Rust. If it doesn’t look nice, why even bother with Haskell.I reckon that you could seed it with style examples that take up very little context space. Also, remind it to not enable language pragmas per file when they’re already in .cabal, and similar.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892280,
    "by": "esafak",
    "timeISO": "2025-08-13T18:49:33.000Z",
    "textPlain": "I think LLMs benefit from training examples, static typing, and an LSP implementation more than terseness.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892175,
    "by": "d4mi3n",
    "timeISO": "2025-08-13T18:39:14.000Z",
    "textPlain": "I think this is putting the cart before the horse. Programs are generally harder to read than they are to write, so optimizing for concise output to benefit the tool at the potential expense of the human isn't a trade I'd personally make.Granted, this may just be an argument for being more comfortable reading/writing code in a particular style, but even without the advantages of LLMs adoption of functional paradigms and tools has been a struggle.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892134,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:35:22.000Z",
    "textPlain": "To be completely honest, I currently only use LLMs to assist me in writing documentation (and translating articles), but I know that other people are looking into it: https://anil.recoil.org/wiki?t=%23projects",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44893514,
    "by": "seprov",
    "timeISO": "2025-08-13T20:33:40.000Z",
    "textPlain": "Procedures can be much more concise in functional/ML syntax, but many things are not -- dependency injection in languages like C# for example are able to be much less verbose because of really excellent DI libraries and (arguably more sane) instance constructor syntax.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44893123,
    "by": "debugnik",
    "timeISO": "2025-08-13T20:01:57.000Z",
    "textPlain": "Funny, I moved to OCaml to sidestep F# tooling. At least last time I used F#: Slow compiler, increasingly C#-only ecosystem, weak and undocumented MSBuild (writing custom tasks would otherwise be nice!), Ionide crashes, Fantomas is unsound...But OCaml sadly can't replace F# for all my use cases. F# does get access to many performance-oriented features that the CLR supports and OCaml simply can't, such as value-types. Maybe OxCaml can fix that long term, but I'm currently missing a performant ML-like with a simple toolchain.",
    "parent": 44892977,
    "depth": 2
  },
  {
    "id": 44893570,
    "by": "joshmarlow",
    "timeISO": "2025-08-13T20:40:21.000Z",
    "textPlain": "It's been a few years since I've touched OCaml - the ecosystem just wasn't what I wanted - but the core language is still my favorite.And the best way I can describe why is that my code generally ends up with a few heavy functions that do too much; I can fix it once I notice it, but that's the direction my code tends to go in.In my OCaml code, I would look for the big function and... just not find it. No single workhorse that does a lot - for some reason it was just easier for me to write good code.Now I do Rust for side projects because I like the type system - but I would prefer OCaml.I keep meaning to checkout F# though for all of these reasons.",
    "parent": 44892977,
    "depth": 2
  },
  {
    "id": 44893545,
    "by": "nukifw",
    "timeISO": "2025-08-13T20:36:59.000Z",
    "textPlain": "Usually we speaking only about sum and product (because article usually refers to ADT, so Algebraic Data type). A function is not really Data, so it is not included. But you can use the same tricks (ie: a -> b has arity b^a) to compute the number of potential inhabitant",
    "parent": 44893525,
    "depth": 2
  },
  {
    "id": 44895725,
    "by": "xigoi",
    "timeISO": "2025-08-14T01:12:11.000Z",
    "textPlain": "ackfoobar has already given a good reason why function types are called exponential, but there is an even deeper reason: function types interact algebraically the same way as exponents.The type A → (B → C) is isomorphic to (A × B) → C (via currying). This is analogous to the rule (cᵇ)ᵃ = cᵇ˙ᵃ.The type (A + B) → C is isomorphic to (A → C) × (B → C) (a function with a case expression can be replaced with a pair of functions). This is analogous to the rule cᵃ⁺ᵇ = cᵃ·cᵇ.",
    "parent": 44893525,
    "depth": 2
  }
]
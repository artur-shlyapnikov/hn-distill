[
  {
    "id": 44892713,
    "by": "noelwelsh",
    "timeISO": "2025-08-13T19:27:29.000Z",
    "textPlain": "I saw a talk by someone from Google about their experiences using Rust in the Android team. Two points stuck out: they migrated many projects from Python, so performance can't have been that much of a concern, and in their surveys the features people liked most were basics like pattern matching and ADTs. My conclusion is that for a lot of tasks the benefit from Rust came from ML cicra 1990, not lifetimes etc. I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1] it could have been Rust. Unfortunately it fell into the gap between what academia could justify working on and what industry was willing to do.[1]: Practically speaking, the 31-bit Ints are annoying if you're trying to do any bit bashing, but aesthetically the double semicolons are an abomination and irk me far more.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892053,
    "by": "_mu",
    "timeISO": "2025-08-13T18:28:17.000Z",
    "textPlain": "I haven't worked in OCaml but I have worked a bit in F# and found it to be a pleasant experience.One thing I am wondering about in the age of LLMs is if we should all take a harder look at functional languages again. My thought is that if FP languages like OCaml / Haskell / etc. let us compress a lot of information into a small amount of text, then that's better for the context window.Possibly we might be able to put much denser programs into the model and one-shot larger changes than is achievable in languages like Java / C# / Ruby / etc?",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892977,
    "by": "garbthetill",
    "timeISO": "2025-08-13T19:49:43.000Z",
    "textPlain": "What a brilliant article, it really puts to rest for me, the whole “why not use F#?” argument. In almost every OCaml thread, someone suggests F# as a way to sidestep OCaml’s tooling.I’ve always been curious about OCaml, especially since some people call it “Go with types” and I’m not a fan of writing Rust. But I’m still not sold on OCaml as a whole, its evangelists just don’t win me over the way the Erlang, Ruby, Rust, or Zig folks do. I just cant see the vision",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44893525,
    "by": "jasperry",
    "timeISO": "2025-08-13T20:34:36.000Z",
    "textPlain": "Question about terminology: Is it common to call higher-order function types \"exponential types\" as the article does? I know what higher-order functions are, but am having trouble grasping why the types would be called \"exponential\".",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44893872,
    "by": "zem",
    "timeISO": "2025-08-13T21:09:28.000Z",
    "textPlain": "ocaml is one of my favourite languages too, but I've found myself being drawn towards rust for my latest project due to its major superpower - you can write a rust library that looks like a c library from the outside, and can be called from other languages via their existing c ffi mechanisms. I feel like by writing the library in ocaml I would have a better experience developing it, but be giving up on that free interop.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892829,
    "by": "nine_k",
    "timeISO": "2025-08-13T19:37:21.000Z",
    "textPlain": "I wish somebody with this amount of experience would compare the benefits / shortcomings of using the ReasonML syntax. (The article mentions it once, in passing.)",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892051,
    "by": "ackfoobar",
    "timeISO": "2025-08-13T18:28:14.000Z",
    "textPlain": "> Sum types: For example, Kotlin and Java (and de facto C#) use a construct associated with inheritance relations called sealing.This has the benefit of giving you the ability to refer to a case as its own type.> the expression of sums verbose and, in my view, harder to reason about.You declare the sum type once, and use it many times. Slightly more verbose sum type declaration is worth it when it makes using the cases cleaner.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892121,
    "by": "raphinou",
    "timeISO": "2025-08-13T18:34:37.000Z",
    "textPlain": "Some years ago I also wanted to make ocaml my primary language, but rapidly encountered problems: difficulty to install (on Linux due to the requirement of a very unusual tool which name and function I forgot), no response from community regarding how to solve that problem, no solid postgresql driver, ....Wanting to use a functional language I pivoted to fsharp, which was not the expected choice for me as I use Linux exclusively. I have been happy with this choice, it has even become my preferred language. The biggest problem for me was the management of the fsharp community, the second class citizen position of fsharp in the DotNet ecosystem, and Microsoft's action screwing the goodwill of the dev community (eg hot reload episode). I feel this hampered the growth of the fsharp community.I'm now starting to use rust, and the contrast on these points couldn't be bigger.Edit: downvoters, caring to share why? I thought sharing my experience would have been appreciated. Would like to know why I was wrong.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44893365,
    "by": "manoDev",
    "timeISO": "2025-08-13T20:21:00.000Z",
    "textPlain": "I'm sure there's merit to the language, but the syntax seems absolutely alien to me. Some attempt to look like verbose imperative code, a bunch of semicolons, and for some strange reason, hate of parenthesis.Real life sample:    let print_expr exp =\n        (* Local function definitions *)\n        let open_paren prec op_prec =\n          if prec > op_prec then print_string \"(\" in\n        let close_paren prec op_prec =\n          if prec > op_prec then print_string \")\" in\n        let rec print prec exp =     (* prec is the current precedence *)\n          match exp with\n            Const c -> print_float c\n          | Var v -> print_string v\n          | Sum(f, g) ->\n              open_paren prec 0;\n              print 0 f; print_string \" + \"; print 0 g;\n              close_paren prec 0\n          | Diff(f, g) ->\n              open_paren prec 0;\n              print 0 f; print_string \" - \"; print 1 g;\n              close_paren prec 0\n          | Prod(f, g) ->\n              open_paren prec 2;\n              print 2 f; print_string \" * \"; print 2 g;\n              close_paren prec 2\n          | Quot(f, g) ->\n              open_paren prec 2;\n              print 2 f; print_string \" / \"; print 3 g;\n              close_paren prec 2\n        in print 0 exp;;\n\nA function is defined as:    let print_expr exp =\n\nThat seems pretty hard to read at a glance, and easy to mistype as a definition.Also, you need to end the declaration with `in`?Then, semicolons...    open_paren prec 0;\n    print 0 f; print_string \" + \"; print 0 g;\n\n... and even double semicolons ...    print 0 exp;;\n\nThat looks like a language you really want an IDE helping you with.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892513,
    "by": "loxs",
    "timeISO": "2025-08-13T19:08:48.000Z",
    "textPlain": "I migrated from OCaml to Rust around 2020, haven't looked back. Although Rust is quite a lot less elegant and has some unpleasant deficiencies (lambdas, closures, currying)... and I end up having to close one one eye sometimes and clone some large data-structure to make my life easier... But regardless, its huge ecosystem and great tooling allows me to build things comparatively so easily, that OCaml has no chance. As a bonus, the end result is seriously faster - I know because I rewrote one of my projects and for some time I had feature parity between the OCaml and Rust versions.Nevertheless, I have fond memories of OCaml and a great amount of respect for the language design. Haven't checked on it since, probably should. I hope part of the problems have been solved.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892046,
    "by": "shortrounddev2",
    "timeISO": "2025-08-13T18:27:50.000Z",
    "textPlain": "OCaml is a great language without great tooling. Desperately needs a good LSP implementation to run breakpoints and other debugging tools on VSCode or other LSP-aware IDEs. I know there ARE tools available but there isn't great support for them and they don't work well",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892537,
    "by": "FrustratedMonky",
    "timeISO": "2025-08-13T19:11:15.000Z",
    "textPlain": "In F# comparison.  Modules \"my opinion, strongly justify preferring one over the other\".Strong stance on Modules.  My ignorance, what do they do that provides that much benefit.  ??",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892011,
    "by": "moi2388",
    "timeISO": "2025-08-13T18:25:03.000Z",
    "textPlain": "If I wanted to program in OCaml, id program in F# instead",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892960,
    "by": "nine_k",
    "timeISO": "2025-08-13T19:48:26.000Z",
    "textPlain": "I'd say that Google strives to have a reasonably short list of languages approved for production-touching code. Rust can replace / complement C++, while OCaml cannot (it could replace Go instead... fat chance!). So I suspect that the team picked Rust because it was the only blessed language with ADTs, not because they won't like something with faster compile times.No way OCaml could have stolen the Rust's thunder: we have a number of very decent and performant GC-based languages, from Go to Haskell; we only had one bare-metal-worthy expressive language in 2010, C++, and it was pretty terrible (still is, but before C++11 and C++17 it was even more terrible).",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892798,
    "by": "unstruktured",
    "timeISO": "2025-08-13T19:34:43.000Z",
    "textPlain": "There is absolutely no reason to use double semicolons in practice. The only place you really should see it is when using the repl.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44893725,
    "by": "the__alchemist",
    "timeISO": "2025-08-13T20:55:45.000Z",
    "textPlain": "I'm with you. I think some of the nicest parts of rust have nothing to do with memory safety; they're ways to structure your program as you mention.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44893511,
    "by": "troupo",
    "timeISO": "2025-08-13T20:33:12.000Z",
    "textPlain": "OCaml also needed the brief but bright ReasonML moment to add/fix/improve some of the syntax IIRC and work on user-friendly error messages. But this should've definitely happened much much earlier than it did.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892853,
    "by": "garbthetill",
    "timeISO": "2025-08-13T19:39:01.000Z",
    "textPlain": "doesnt rust still have the advantage of having no gc? I dont like writing rust, but the selling point of being able to write performative code with memory safety guarantees has always stuck with me",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892839,
    "by": "benreesman",
    "timeISO": "2025-08-13T19:37:52.000Z",
    "textPlain": "[flagged]",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44894006,
    "by": "dkarl",
    "timeISO": "2025-08-13T21:21:14.000Z",
    "textPlain": "In Scala, I've had excellent luck using LLMs to speed up development when I'm using cats-effect, an effects library.My experience in the past with something like cats-effect has been that there are straightforward things that aren't obvious, and if you haven't been using it recently, and maybe even if you've been using it but haven't solved a similar problem recently, you can get stuck trawling through the docs squinting at type signatures looking for what turns out to be, in hindsight, an elegant and simple solution. LLMs have vastly reduced this kind of friction. I just ask, \"In cats-effect, how do I...?\" and 80% of the time the answer gets me immediately unstuck. The other 20% of the time I provide clarifying context or ask a different LLM.I haven't done enough maintenance coding yet to know if this will radically shift my view of the cost/benefit of functional programming with effects, but I'm very excited. Writing cats-effect code has always been satisfying and frustrating in equal measure, and so far, I'm getting the confidence and correctness with a fraction of the frustration.I haven't unleashed Claude Code on any cats-effect code yet. I'm curious to see how well it will do.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892596,
    "by": "jappgar",
    "timeISO": "2025-08-13T19:15:39.000Z",
    "textPlain": "That was my optimistic take before I started working on a large Haskell code base.Aside from the obvious problem that there's not enough FP in the training corpus, it seems like terser languages don't work all that well with LLMs.My guess is that verbosity actually helps the generation self-correct... if it predicts some \"bad\" tokens it can pivot more easily and still produce working code.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892249,
    "by": "gf000",
    "timeISO": "2025-08-13T18:46:41.000Z",
    "textPlain": "My completely non-objective experiment of writing a simple CLI game in C++ and Haskell shows that the lines of code were indeed less in case of Haskell.. but the number of words were roughly the same, meaning the Haskell code just \"wider\" instead of \"higher\".And then I didn't even make this \"experiment\" with Java or another managed, more imperative language which could have shed some weight due to not caring about manual memory management.So not sure how much truth is in there - I think it differs based on the given program: some lend itself better for an imperative style, others prefer a more functional one.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892773,
    "by": "sshine",
    "timeISO": "2025-08-13T19:32:31.000Z",
    "textPlain": "> My thought is that if FP languages like OCaml / Haskell / etc. let us compress a lot of information into a small amount of text, then that's better for the context window.Claude Code’s Haskell style is very verbose; if-then-elsey, lots of nested case-ofs, do-blocks at multiple levels of intension, very little naming things at top-level.Given a sample of a simple API client, and a request to do the same but for another API, it did very well.I concluded that I just have more opinions about Haskell than Java or Rust. If it doesn’t look nice, why even bother with Haskell.I reckon that you could seed it with style examples that take up very little context space. Also, remind it to not enable language pragmas per file when they’re already in .cabal, and similar.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892280,
    "by": "esafak",
    "timeISO": "2025-08-13T18:49:33.000Z",
    "textPlain": "I think LLMs benefit from training examples, static typing, and an LSP implementation more than terseness.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892134,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:35:22.000Z",
    "textPlain": "To be completely honest, I currently only use LLMs to assist me in writing documentation (and translating articles), but I know that other people are looking into it: https://anil.recoil.org/wiki?t=%23projects",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44893514,
    "by": "seprov",
    "timeISO": "2025-08-13T20:33:40.000Z",
    "textPlain": "Procedures can be much more concise in functional/ML syntax, but many things are not -- dependency injection in languages like C# for example are able to be much less verbose because of really excellent DI libraries and (arguably more sane) instance constructor syntax.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892175,
    "by": "d4mi3n",
    "timeISO": "2025-08-13T18:39:14.000Z",
    "textPlain": "I think this is putting the cart before the horse. Programs are generally harder to read than they are to write, so optimizing for concise output to benefit the tool at the potential expense of the human isn't a trade I'd personally make.Granted, this may just be an argument for being more comfortable reading/writing code in a particular style, but even without the advantages of LLMs adoption of functional paradigms and tools has been a struggle.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44893570,
    "by": "joshmarlow",
    "timeISO": "2025-08-13T20:40:21.000Z",
    "textPlain": "It's been a few years since I've touched OCaml - the ecosystem just wasn't what I wanted - but the core language is still my favorite.And the best way I can describe why is that my code generally ends up with a few heavy functions that do too much; I can fix it once I notice it, but that's the direction my code tends to go in.In my OCaml code, I would look for the big function and... just not find it. No single workhorse that does a lot - for some reason it was just easier for me to write good code.Now I do Rust for side projects because I like the type system - but I would prefer OCaml.I keep meaning to checkout F# though for all of these reasons.",
    "parent": 44892977,
    "depth": 2
  },
  {
    "id": 44893123,
    "by": "debugnik",
    "timeISO": "2025-08-13T20:01:57.000Z",
    "textPlain": "Funny, I moved to OCaml to sidestep F# tooling. At least last time I used F#: Slow compiler, increasingly C#-only ecosystem, weak and undocumented MSBuild (writing custom tasks would otherwise be nice!), Ionide crashes, Fantomas is unsound...But OCaml sadly can't replace F# for all my use cases. F# does get access to many performance-oriented features that the CLR supports and OCaml simply can't, such as value-types. Maybe OxCaml can fix that long term, but I'm currently missing a performant ML-like with a simple toolchain.",
    "parent": 44892977,
    "depth": 2
  },
  {
    "id": 44893857,
    "by": "ackfoobar",
    "timeISO": "2025-08-13T21:08:22.000Z",
    "textPlain": "A first-order function type is already exponential.A sum type has as many possible values as the sum of its cases. E.g. `A of bool | B of bool` has 2+2=4 values. Similarly for product types and exponential types. E.g. the type bool -> bool has 2^2=4 values (id, not, const true, const false) if you don't think about side effects.",
    "parent": 44893525,
    "depth": 2
  },
  {
    "id": 44893545,
    "by": "nukifw",
    "timeISO": "2025-08-13T20:36:59.000Z",
    "textPlain": "Usually we speaking only about sum and product (because article usually refers to ADT, so Algebraic Data type). A function is not really Data, so it is not included. But you can use the same tricks (ie: a -> b has arity b^a) to compute the number of potential inhabitant",
    "parent": 44893525,
    "depth": 2
  },
  {
    "id": 44893905,
    "by": "globuous",
    "timeISO": "2025-08-13T21:12:19.000Z",
    "textPlain": "What I missed most were let bindings (https://ocaml.org/manual/5.3/bindingops.html)ReasonML has custom operators that allows for manipulating monads somewhat sanely (>>= operators and whatnot). rescript (reasonml’s “fork”) did not last time I checked. But it does have an async/await syntax which helps a lot with async code. reasonml did not last time I checked, so you had to use raw promises.I believe Melange (which the article briefly talks about) supports let bindings with the reason syntax.And this kinda changes everything if you React. Because you can now have sane JSX with let bindings. Which you could not until melange. Indeed, you can PPX your way out of it in ocaml syntax, but I’m not sure the syntax highlight works well in code editors. It did not on mine anyway last time I checked.So for frontend coding, Melange’s reason ml is great as you have both, and let bindings can approximate quite well async syntax on top of writing readable monadic code.For backend code, as a pythonista, I hate curlies. and I do like parenthesis-less function calls and definitions a lot. But I still have a lot of trouble, as a beginner ocamler, with non-variable function argument as I need to do “weird” parenthesis stuff.Hope this “helps”!",
    "parent": 44892829,
    "depth": 2
  },
  {
    "id": 44893908,
    "by": "nukifw",
    "timeISO": "2025-08-13T21:12:42.000Z",
    "textPlain": "Sorry, I never used ReasonML so I don't see any advantage of using ReasonML except it had the time to die twice in 4 years :)",
    "parent": 44892829,
    "depth": 2
  },
  {
    "id": 44893347,
    "by": "hardwaregeek",
    "timeISO": "2025-08-13T20:19:57.000Z",
    "textPlain": "I like Reason syntax and I wish it was more common, but I think if you want to engage in the OCaml community it’s probably better to just bite the bullet and use the standard syntax. It’s what almost everybody uses so you’ll need to understand it to read any code or documentation in the ecosystem",
    "parent": 44892829,
    "depth": 2
  },
  {
    "id": 44893538,
    "by": "myaccountonhn",
    "timeISO": "2025-08-13T20:35:56.000Z",
    "textPlain": "I don't have extensive experience but the little I did was issues with LSP not working as well.",
    "parent": 44892829,
    "depth": 2
  },
  {
    "id": 44893277,
    "by": "sunnydiskincali",
    "timeISO": "2025-08-13T20:13:52.000Z",
    "textPlain": "> This has the benefit of giving you the ability to refer to a case as its own type.A case of a sum-type is an expression (of the variety so-called a type constructor), of course it has a type.  datatype shape =\n      Circle of real\n    | Rectangle of real * real\n    | Point\n\n   Circle : real -> shape\n   Rectangle : real * real -> shape\n   Point : () -> shape\n\nA case itself isn't a type, though it has a type. Thanks to pattern matching, you're already unwrapping the parameter to the type-constructor when handling the case of a sum-type. It's all about declaration locality. (real * real) doesn't depend on the existence of shape.The moment you start ripping cases as distinct types out of the sum-type, you create the ability to side-step exhaustiveness and sum-types become useless in making invalid program states unrepresentable. They're also no longer sum-types. If you have a sum-type of nominally distinct types, the sum-type is contingent on the existence of those types. In a class hierarchy, this relationship is bizarrely reversed and there are knock-on effects to that.> You declare the sum type once, and use it many times.And you typically write many sum-types. They're disposable. And more to the point, you also have to read the code you write. The cost of verbosity here is underestimated.> Slightly more verbose sum type declaration is worth it when it makes using the cases cleaner.C#/Java don't actually have sum-types. It's an incompatible formalism with their type systems.Anyways, let's look at these examples:C#:  public abstract record Shape;\n  public sealed record Circle(double Radius) : Shape;\n  public sealed record Rectangle(double Width, double Height) : Shape;\n  public sealed record Point() : Shape;\n  \n  double Area(Shape shape) => shape switch\n  {\n      Circle c => Math.PI * c.Radius * c.Radius,\n      Rectangle r => r.Width * r.Height,\n      Point => 0.0,\n      _ => throw new ArgumentException(\"Unknown shape\", nameof(shape))\n  };\n\nML:  datatype shape =\n   ",
    "parent": 44892051,
    "depth": 2
  },
  {
    "id": 44892214,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:43:59.000Z",
    "textPlain": "In the specific case of OCaml, this is also possible using indexing and GADTs or polymorphic variants. But generally, referencing as its own type serves different purposes. From my point of view, distinguishing between sum branches often tends to result in code that is difficult to reason about and difficult to generalise due to concerns about variance and loss of type equality.",
    "parent": 44892051,
    "depth": 2
  },
  {
    "id": 44892151,
    "by": "wiseowise",
    "timeISO": "2025-08-13T18:36:36.000Z",
    "textPlain": "> Slightly more verbose sum type declaration is worth it *when it makes using the cases cleaner.*Correct. This is not the case when you talk about Java/Kotlin. Just ugliness and typical boilerplate heavy approach of JVM languages.",
    "parent": 44892051,
    "depth": 2
  },
  {
    "id": 44892232,
    "by": "johnisgood",
    "timeISO": "2025-08-13T18:45:19.000Z",
    "textPlain": "> difficulty to installUse opam: https://opam.ocaml.org or https://opam.ocaml.org/doc/Install.html.Additionally, see: https://ocaml.org/install#linux_mac_bsd and https://ocaml.org/docs/set-up-editor.It is easy to set up with Emacs, for example. VSCodium has OCaml extension as well.All you need for the OCaml compiler is opam, it handles all the packages and the compiler.For your project, use dune: https://dune.readthedocs.io/en/stable/quick-start.html.",
    "parent": 44892121,
    "depth": 2
  },
  {
    "id": 44892999,
    "by": "davidwritesbugs",
    "timeISO": "2025-08-13T19:51:37.000Z",
    "textPlain": "I abandoned ocaml just because I couldn't get a stepping debugger to work. Can't remember the exact issues but I tried to install in vscode to no avail & I've no interest in emacs",
    "parent": 44892121,
    "depth": 2
  },
  {
    "id": 44893606,
    "by": "myaccountonhn",
    "timeISO": "2025-08-13T20:44:04.000Z",
    "textPlain": "That code is probably some of the hardest you'll encounter in Ocaml, but for me its quite obvious what it does and easy to read because I've worked with GADTs before. If you haven't then its you'll need to study and understand them to understand the code.I actually really like the syntax of OCaml, its very easy to write and when you're used to it, easy to read (easier than reasonml IMO).Double semicolons are afaik only used in the repl.",
    "parent": 44893365,
    "depth": 2
  },
  {
    "id": 44893953,
    "by": "javcasas",
    "timeISO": "2025-08-13T21:16:42.000Z",
    "textPlain": "It also uses double semicolon because single semicolon is already used as statement separator kinda like C. So double semicolon is top-level statement terminator.",
    "parent": 44893365,
    "depth": 2
  },
  {
    "id": 44893887,
    "by": "javcasas",
    "timeISO": "2025-08-13T21:10:53.000Z",
    "textPlain": "`let` defines a value. Some values are \"plain old values\", some are functions.The syntax is `let <constantname> <parameters> = <value> in <expression>;;`\nwhere `expression` can also have `let` bindings.So you can have  let one = 1 in\n  let two = 2 in\n  let three = one + two in\n  print_endline (string_of_int three);;",
    "parent": 44893365,
    "depth": 2
  },
  {
    "id": 44893760,
    "by": "UncleOxidant",
    "timeISO": "2025-08-13T20:58:34.000Z",
    "textPlain": "I mean, I guess it depends on your background, but that code looks pretty nice compared to how it would look in a language without pattern matching and ADTs. This is why the MLs excel for things like parsers, interpreters, and compilers. Beauty is in the eye of the beholder, I guess. I suspect that if you gave it a bit of time it would start to really grow on you - that's how it was in my case. At first: \"WTF is this weird syntax?!\", a few weeks in \"oh, this makes a lot of sense, actually\", a few years \"Yeah, I'd much rather write this sort of thing in OCaml (or an ML in general)\"",
    "parent": 44893365,
    "depth": 2
  },
  {
    "id": 44893670,
    "by": "jasperry",
    "timeISO": "2025-08-13T20:49:40.000Z",
    "textPlain": "Your comment makes me think the kind of people who favor OCaml over Rust wouldn't necessarily value a huge ecosystem or the most advanced tooling. They're the kind who value the elegance aspect above almost all else, and prefer to build things from the ground up, using no more than a handful of libraries and a very basic build procedure.",
    "parent": 44892513,
    "depth": 2
  },
  {
    "id": 44892744,
    "by": "ackfoobar",
    "timeISO": "2025-08-13T19:30:32.000Z",
    "textPlain": "> the end result is seriously fasterDo you have a ballpark value of how much faster Rust is? Also I wonder if OxCaml will be roughly as fast with less effort.",
    "parent": 44892513,
    "depth": 2
  },
  {
    "id": 44892562,
    "by": "debugnik",
    "timeISO": "2025-08-13T19:13:21.000Z",
    "textPlain": "LSP isn't the protocol that interfaces with debuggers, that'd be DAP. You're right that OCaml debugging is kinda clunky at the moment.OCaml does have an okay LSP implementation though, and it's getting better; certainly more stable than F#'s in my experience, since that comparison is coming up a lot in this comment section.",
    "parent": 44892046,
    "depth": 2
  },
  {
    "id": 44892077,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:30:51.000Z",
    "textPlain": "Indeed, efforts should be made in terms of DAP (https://microsoft.github.io/debug-adapter-protocol//), extending the following experimentation: https://lambdafoo.com/posts/2024-03-25-ocaml-debugging-with-.... However, I find the assertion about tooling a bit exaggerated, don't you?",
    "parent": 44892046,
    "depth": 2
  },
  {
    "id": 44892114,
    "by": "dismalaf",
    "timeISO": "2025-08-13T18:34:08.000Z",
    "textPlain": "??  OCaml has had a completion engine for as long as I can remember (definitely over a decade) and it powers their LSP these days.  I do know however that the community focuses mostly on Vim and Emacs.",
    "parent": 44892046,
    "depth": 2
  },
  {
    "id": 44892844,
    "by": "debugnik",
    "timeISO": "2025-08-13T19:38:19.000Z",
    "textPlain": "In short, OCaml modules are used for coarse-grained generics.Modules are like structurally-typed records that can contain both abstract types and values/functions dependent on those types; every implementation file is itself a module. When passed to functors (module-level functions), they allow you to parameterize large pieces of code, depending on multiple  types and functions, all at once quite cleanly. And simply including them or narrowing their signatures is how one exports library APIs.(The closest equivalent I can imagine to module signatures is Scala traits with abstract type members, but structurally-typed and every package is an instance.)However, they are a bit too verbose for finer-grained generics. For example, a map with string keys needs `module String_map = Map.Make(String)`. There is limited support for passing modules as first-class values with less ceremony, hopefully with more on the way.",
    "parent": 44892537,
    "depth": 2
  }
]
[
  {
    "id": 44892713,
    "by": "noelwelsh",
    "timeISO": "2025-08-13T19:27:29.000Z",
    "textPlain": "I saw a talk by someone from Google about their experiences using Rust in the Android team. Two points stuck out: they migrated many projects from Python, so performance can't have been that much of a concern, and in their surveys the features people liked most were basics like pattern matching and ADTs. My conclusion is that for a lot of tasks the benefit from Rust came from ML cicra 1990, not lifetimes etc. I feel if OCaml had got its act together around about 2010 with multicore and a few other annoyances[1] it could have been Rust. Unfortunately it fell into the gap between what academia could justify working on and what industry was willing to do.[1]: Practically speaking, the 31-bit Ints are annoying if you're trying to do any bit bashing, but aesthetically the double semicolons are an abomination and irk me far more.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892977,
    "by": "garbthetill",
    "timeISO": "2025-08-13T19:49:43.000Z",
    "textPlain": "What a brilliant article, it really puts to rest for me, the whole “why not use F#?” argument. In almost every OCaml thread, someone suggests F# as a way to sidestep OCaml’s tooling.I’ve always been curious about OCaml, especially since some people call it “Go with types” and I’m not a fan of writing Rust. But I’m still not sold on OCaml as a whole, its evangelists just don’t win me over the way the Erlang, Ruby, Rust, or Zig folks do. I just cant see the vision",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892053,
    "by": "_mu",
    "timeISO": "2025-08-13T18:28:17.000Z",
    "textPlain": "I haven't worked in OCaml but I have worked a bit in F# and found it to be a pleasant experience.One thing I am wondering about in the age of LLMs is if we should all take a harder look at functional languages again. My thought is that if FP languages like OCaml / Haskell / etc. let us compress a lot of information into a small amount of text, then that's better for the context window.Possibly we might be able to put much denser programs into the model and one-shot larger changes than is achievable in languages like Java / C# / Ruby / etc?",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44893365,
    "by": "manoDev",
    "timeISO": "2025-08-13T20:21:00.000Z",
    "textPlain": "The syntax seems absolutely alien to me – although it's a functional language, most of it reads like imperative code with a bunch of semicolons (double semicolons even) and lack of scoping hints.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892829,
    "by": "nine_k",
    "timeISO": "2025-08-13T19:37:21.000Z",
    "textPlain": "I wish somebody with this amount of experience would compare the benefits / shortcomings of using the ReasonML syntax. (The article mentions it once, in passing.)",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892051,
    "by": "ackfoobar",
    "timeISO": "2025-08-13T18:28:14.000Z",
    "textPlain": "> Sum types: For example, Kotlin and Java (and de facto C#) use a construct associated with inheritance relations called sealing.This has the benefit of giving you the ability to refer to a case as its own type.> the expression of sums verbose and, in my view, harder to reason about.You declare the sum type once, and use it many times. Slightly more verbose sum type declaration is worth it when it makes using the cases cleaner.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892121,
    "by": "raphinou",
    "timeISO": "2025-08-13T18:34:37.000Z",
    "textPlain": "Some years ago I also wanted to make ocaml my primary language, but rapidly encountered problems: difficulty to install (on Linux due to the requirement of a very unusual tool which name and function I forgot), no response from community regarding how to solve that problem, no solid postgresql driver, ....Wanting to use a functional language I pivoted to fsharp, which was not the expected choice for me as I use Linux exclusively. I have been happy with this choice, it has even become my preferred language. The biggest problem for me was the management of the fsharp community, the second class citizen position of fsharp in the DotNet ecosystem, and Microsoft's action screwing the goodwill of the dev community (eg hot reload episode). I feel this hampered the growth of the fsharp community.I'm now starting to use rust, and the contrast on these points couldn't be bigger.Edit: downvoters, caring to share why? I thought sharing my experience would have been appreciated. Would like to know why I was wrong.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892513,
    "by": "loxs",
    "timeISO": "2025-08-13T19:08:48.000Z",
    "textPlain": "I migrated from OCaml to Rust around 2020, haven't looked back. Although Rust is quite a lot less elegant and has some unpleasant deficiencies (lambdas, closures, currying)... and I end up having to close one one eye sometimes and clone some large data-structure to make my life easier... But regardless, its huge ecosystem and great tooling allows me to build things comparatively so easily, that OCaml has no chance. As a bonus, the end result is seriously faster - I know because I rewrote one of my projects and for some time I had feature parity between the OCaml and Rust versions.Nevertheless, I have fond memories of OCaml and a great amount of respect for the language design. Haven't checked on it since, probably should. I hope part of the problems have been solved.",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892046,
    "by": "shortrounddev2",
    "timeISO": "2025-08-13T18:27:50.000Z",
    "textPlain": "OCaml is a great language without great tooling. Desperately needs a good LSP implementation to run breakpoints and other debugging tools on VSCode or other LSP-aware IDEs. I know there ARE tools available but there isn't great support for them and they don't work well",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892537,
    "by": "FrustratedMonky",
    "timeISO": "2025-08-13T19:11:15.000Z",
    "textPlain": "In F# comparison.  Modules \"my opinion, strongly justify preferring one over the other\".Strong stance on Modules.  My ignorance, what do they do that provides that much benefit.  ??",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892011,
    "by": "moi2388",
    "timeISO": "2025-08-13T18:25:03.000Z",
    "textPlain": "If I wanted to program in OCaml, id program in F# instead",
    "parent": 44891759,
    "depth": 1
  },
  {
    "id": 44892960,
    "by": "nine_k",
    "timeISO": "2025-08-13T19:48:26.000Z",
    "textPlain": "I'd say that Google strives to have a reasonably short list of languages approved for production-touching code. Rust can replace / complement C++, while OCaml cannot (it could replace Go instead... fat chance!). So I suspect that the team picked Rust because it was the only blessed language with ADTs, not because they won't like something with faster compile times.No way OCaml could have stolen the Rust's thunder: we have a number of very decent and performant GC-based languages, from Go to Haskell; we only had one bare-metal-worthy expressive language in 2010, C++, and it was pretty terrible (still is, but before C++11 and C++17 it was even more terrible).",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892798,
    "by": "unstruktured",
    "timeISO": "2025-08-13T19:34:43.000Z",
    "textPlain": "There is absolutely no reason to use double semicolons in practice. The only place you really should see it is when using the repl.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892853,
    "by": "garbthetill",
    "timeISO": "2025-08-13T19:39:01.000Z",
    "textPlain": "doesnt rust still have the advantage of having no gc? I dont like writing rust, but the selling point of being able to write performative code with memory safety guarantees has always stuck with me",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44892839,
    "by": "benreesman",
    "timeISO": "2025-08-13T19:37:52.000Z",
    "textPlain": "Came here to see if the top comment on an OCaml thread had something about Rust changing the subject to Rust with an oblique tieback to TFA.Come on guys, this was old five years ago and its not organic, the strike force is quieter about brigading than it used to be, but you can still set your watch by it.",
    "parent": 44892713,
    "depth": 2
  },
  {
    "id": 44893123,
    "by": "debugnik",
    "timeISO": "2025-08-13T20:01:57.000Z",
    "textPlain": "Funny, I moved to OCaml to sidestep F# tooling. At least last time I used F#: Slow compiler, increasingly C#-only ecosystem, weak and undocumented MSBuild (writing custom tasks would otherwise be nice!), Ionide crashes, Fantomas is unsound...But OCaml sadly can't replace F# for all my use cases. F# does get access to many performance-oriented features that the CLR supports and OCaml simply can't, such as value-types. Maybe OxCaml can fix that long term, but I'm currently missing a performant ML-like with a simple toolchain.",
    "parent": 44892977,
    "depth": 2
  },
  {
    "id": 44892596,
    "by": "jappgar",
    "timeISO": "2025-08-13T19:15:39.000Z",
    "textPlain": "That was my optimistic take before I started working on a large Haskell code base.Aside from the obvious problem that there's not enough FP in the training corpus, it seems like terser languages don't work all that well with LLMs.My guess is that verbosity actually helps the generation self-correct... if it predicts some \"bad\" tokens it can pivot more easily and still produce working code.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892249,
    "by": "gf000",
    "timeISO": "2025-08-13T18:46:41.000Z",
    "textPlain": "My completely non-objective experiment of writing a simple CLI game in C++ and Haskell shows that the lines of code were indeed less in case of Haskell.. but the number of words were roughly the same, meaning the Haskell code just \"wider\" instead of \"higher\".And then I didn't even make this \"experiment\" with Java or another managed, more imperative language which could have shed some weight due to not caring about manual memory management.So not sure how much truth is in there - I think it differs based on the given program: some lend itself better for an imperative style, others prefer a more functional one.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892773,
    "by": "sshine",
    "timeISO": "2025-08-13T19:32:31.000Z",
    "textPlain": "> My thought is that if FP languages like OCaml / Haskell / etc. let us compress a lot of information into a small amount of text, then that's better for the context window.Claude Code’s Haskell style is very verbose; if-then-elsey, lots of nested case-ofs, do-blocks at multiple levels of intension, very little naming things at top-level.Given a sample of a simple API client, and a request to do the same but for another API, it did very well.I concluded that I just have more opinions about Haskell than Java or Rust. If it doesn’t look nice, why even bother with Haskell.I reckon that you could seed it with style examples that take up very little context space. Also, remind it to not enable language pragmas per file when they’re already in .cabal, and similar.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892280,
    "by": "esafak",
    "timeISO": "2025-08-13T18:49:33.000Z",
    "textPlain": "I think LLMs benefit from training examples, static typing, and an LSP implementation more than terseness.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892175,
    "by": "d4mi3n",
    "timeISO": "2025-08-13T18:39:14.000Z",
    "textPlain": "I think this is putting the cart before the horse. Programs are generally harder to read than they are to write, so optimizing for concise output to benefit the tool at the potential expense of the human isn't a trade I'd personally make.Granted, this may just be an argument for being more comfortable reading/writing code in a particular style, but even without the advantages of LLMs adoption of functional paradigms and tools has been a struggle.",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44892134,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:35:22.000Z",
    "textPlain": "To be completely honest, I currently only use LLMs to assist me in writing documentation (and translating articles), but I know that other people are looking into it: https://anil.recoil.org/wiki?t=%23projects",
    "parent": 44892053,
    "depth": 2
  },
  {
    "id": 44893347,
    "by": "hardwaregeek",
    "timeISO": "2025-08-13T20:19:57.000Z",
    "textPlain": "I like Reason syntax and I wish it was more common, but I think if you want to engage in the OCaml community it’s probably better to just bite the bullet and use the standard syntax. It’s what almost everybody uses so you’ll need to understand it to read any code or documentation in the ecosystem",
    "parent": 44892829,
    "depth": 2
  },
  {
    "id": 44893277,
    "by": "sunnydiskincali",
    "timeISO": "2025-08-13T20:13:52.000Z",
    "textPlain": "> This has the benefit of giving you the ability to refer to a case as its own type.A case of a sum-type is an expression (of the variety so-called a type constructor), of course it has a type.  datatype shape =\n      Circle of real\n    | Rectangle of real * real\n    | Point\n\n   Circle : real -> shape\n   Rectangle : real * real -> shape\n   Point : () -> shape\n\nA case itself isn't a type, though it has a type. Thanks to pattern matching, you're already unwrapping the parameter to the type-constructor when handling the case of a sum-type. It's all about declaration locality. (real * real) doesn't depend on the existence of shape.The moment you start ripping cases as distinct types out of the sum-type, you create the ability to side-step exhaustiveness and sum-types become useless in making invalid program states unrepresentable. They're also no longer sum-types. If you have a sum-type of nominally distinct types, the sum-type is contingent on the existence of those types. In a class hierarchy, this relationship is bizarrely reversed and there are knock-on effects to that.> You declare the sum type once, and use it many times.And you typically write many sum-types. They're disposable. And more to the point, you also have to read the code you write. The cost of verbosity here is underestimated.> Slightly more verbose sum type declaration is worth it when it makes using the cases cleaner.C#/Java don't actually have sum-types. It's an incompatible formalism with their type systems.Anyways, let's look at these examples:C#:  public abstract record Shape;\n  public sealed record Circle(double Radius) : Shape;\n  public sealed record Rectangle(double Width, double Height) : Shape;\n  public sealed record Point() : Shape;\n  \n  double Area(Shape shape) => shape switch\n  {\n      Circle c => Math.PI * c.Radius * c.Radius,\n      Rectangle r => r.Width * r.Height,\n      Point => 0.0,\n      _ => throw new ArgumentException(\"Unknown shape\", nameof(shape))\n  };\n\nML:  datatype shape =\n   ",
    "parent": 44892051,
    "depth": 2
  },
  {
    "id": 44892214,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:43:59.000Z",
    "textPlain": "In the specific case of OCaml, this is also possible using indexing and GADTs or polymorphic variants. But generally, referencing as its own type serves different purposes. From my point of view, distinguishing between sum branches often tends to result in code that is difficult to reason about and difficult to generalise due to concerns about variance and loss of type equality.",
    "parent": 44892051,
    "depth": 2
  },
  {
    "id": 44892151,
    "by": "wiseowise",
    "timeISO": "2025-08-13T18:36:36.000Z",
    "textPlain": "> Slightly more verbose sum type declaration is worth it *when it makes using the cases cleaner.*Correct. This is not the case when you talk about Java/Kotlin. Just ugliness and typical boilerplate heavy approach of JVM languages.",
    "parent": 44892051,
    "depth": 2
  },
  {
    "id": 44892232,
    "by": "johnisgood",
    "timeISO": "2025-08-13T18:45:19.000Z",
    "textPlain": "> difficulty to installUse opam: https://opam.ocaml.org or https://opam.ocaml.org/doc/Install.html.Additionally, see: https://ocaml.org/install#linux_mac_bsd and https://ocaml.org/docs/set-up-editor.It is easy to set up with Emacs, for example. VSCodium has OCaml extension as well.All you need for the OCaml compiler is opam, it handles all the packages and the compiler.For your project, use dune: https://dune.readthedocs.io/en/stable/quick-start.html.",
    "parent": 44892121,
    "depth": 2
  },
  {
    "id": 44892999,
    "by": "davidwritesbugs",
    "timeISO": "2025-08-13T19:51:37.000Z",
    "textPlain": "I abandoned ocaml just because I couldn't get a stepping debugger to work. Can't remember the exact issues but I tried to install in vscode to no avail & I've no interest in emacs",
    "parent": 44892121,
    "depth": 2
  },
  {
    "id": 44892744,
    "by": "ackfoobar",
    "timeISO": "2025-08-13T19:30:32.000Z",
    "textPlain": "> the end result is seriously fasterDo you have a ballpark value of how much faster Rust is? Also I wonder if OxCaml will be roughly as fast with less effort.",
    "parent": 44892513,
    "depth": 2
  },
  {
    "id": 44892562,
    "by": "debugnik",
    "timeISO": "2025-08-13T19:13:21.000Z",
    "textPlain": "LSP isn't the protocol that interfaces with debuggers, that'd be DAP. You're right that OCaml debugging is kinda clunky at the moment.OCaml does have an okay LSP implementation though, and it's getting better; certainly more stable than F#'s in my experience, since that comparison is coming up a lot in this comment section.",
    "parent": 44892046,
    "depth": 2
  },
  {
    "id": 44892077,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:30:51.000Z",
    "textPlain": "Indeed, efforts should be made in terms of DAP (https://microsoft.github.io/debug-adapter-protocol//), extending the following experimentation: https://lambdafoo.com/posts/2024-03-25-ocaml-debugging-with-.... However, I find the assertion about tooling a bit exaggerated, don't you?",
    "parent": 44892046,
    "depth": 2
  },
  {
    "id": 44892114,
    "by": "dismalaf",
    "timeISO": "2025-08-13T18:34:08.000Z",
    "textPlain": "??  OCaml has had a completion engine for as long as I can remember (definitely over a decade) and it powers their LSP these days.  I do know however that the community focuses mostly on Vim and Emacs.",
    "parent": 44892046,
    "depth": 2
  },
  {
    "id": 44892844,
    "by": "debugnik",
    "timeISO": "2025-08-13T19:38:19.000Z",
    "textPlain": "In short, OCaml modules are used for coarse-grained generics.Modules are like structurally-typed records that can contain both abstract types and values/functions dependent on those types; every implementation file is itself a module. When passed to functors (module-level functions), they allow you to parameterize large pieces of code, depending on multiple  types and functions, all at once quite cleanly. And simply including them or narrowing their signatures is how one exports library APIs.(The closest equivalent I can imagine to module signatures is Scala traits with abstract type members, but structurally-typed and every package is an instance.)However, they are a bit too verbose for finer-grained generics. For example, a map with string keys needs `module String_map = Map.Make(String)`. There is limited support for passing modules as first-class values with less ceremony, hopefully with more on the way.",
    "parent": 44892537,
    "depth": 2
  },
  {
    "id": 44892895,
    "by": "akkad33",
    "timeISO": "2025-08-13T19:42:54.000Z",
    "textPlain": "I don't know OCAML well but I think this is referring to the fact that modules on OCAML can be generic. In f# there is no HKTs that is types that can be parameterised with type classes. So in F# you have to have List.map, option.map etc, whereas in a language like OCAML or Haskell they would have one parametrised module",
    "parent": 44892537,
    "depth": 2
  },
  {
    "id": 44892040,
    "by": "nukifw",
    "timeISO": "2025-08-13T18:27:18.000Z",
    "textPlain": "Hi! Thank you for your interest (and for potentially reading this).Yes, F# is a very nice language, however, it seems to me that I am making a somewhat forced comparison between OCaml and F# in the following section: https://xvw.lol/en/articles/why-ocaml.html#ocaml-and-f",
    "parent": 44892011,
    "depth": 2
  },
  {
    "id": 44892704,
    "by": "jimbob45",
    "timeISO": "2025-08-13T19:26:29.000Z",
    "textPlain": "It's always weird when Microsoft pulls an \"embrace, extend, extinguish\" but the \"extinguish\" part happens without their involvement or desire and then we're all stuck wondering how Microsoft got left holding the bag.",
    "parent": 44892011,
    "depth": 2
  }
]
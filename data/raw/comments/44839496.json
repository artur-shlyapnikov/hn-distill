[
  {
    "id": 44867539,
    "by": "pjmlp",
    "timeISO": "2025-08-11T18:17:30.000Z",
    "textPlain": "Note that Java now has its own API for this purpose.https://openjdk.org/jeps/484",
    "parent": 44839496,
    "depth": 1
  },
  {
    "id": 44868252,
    "by": "cogman10",
    "timeISO": "2025-08-11T19:14:07.000Z",
    "textPlain": "If you are into code generation, another project of interest is Java Poethttps://github.com/square/javapoetI've used it to do a mass refactoring of an annotation-based library.  Worked pretty great.",
    "parent": 44839496,
    "depth": 1
  },
  {
    "id": 44868675,
    "by": "selimco",
    "timeISO": "2025-08-11T19:50:50.000Z",
    "textPlain": "It seems like micronaut has been able to avoid runtime bytecode generation by doing everything at compile-time. I wonder if there’s things that you can’t do the micronaut way.",
    "parent": 44839496,
    "depth": 1
  },
  {
    "id": 44867437,
    "by": "morkalork",
    "timeISO": "2025-08-11T18:09:26.000Z",
    "textPlain": "Reminds me of a side project I did when first starting CS! The Java byte code specification is absolutely approachable and if you've never looked at it before I recommend it (although this project says you can still use it without that knowledge)",
    "parent": 44839496,
    "depth": 1
  },
  {
    "id": 44868464,
    "by": "ActorNightly",
    "timeISO": "2025-08-11T19:31:51.000Z",
    "textPlain": "The better question is why use Java for anything these days. If you really need to run something with JVM, use Kotlin.",
    "parent": 44839496,
    "depth": 1
  },
  {
    "id": 44867760,
    "by": "atomicnumber3",
    "timeISO": "2025-08-11T18:35:30.000Z",
    "textPlain": "for those who might be clicking through thinking \"since when??\", the emphasis is on \"now\" - this was released in JDK 24.bytebuddy predates it by at least a decade.",
    "parent": 44867539,
    "depth": 2
  },
  {
    "id": 44869079,
    "by": "zappb",
    "timeISO": "2025-08-11T20:28:09.000Z",
    "textPlain": "Ideally, tools like ByteBuddy will adopt that API as it's for low level concerns.",
    "parent": 44867539,
    "depth": 2
  },
  {
    "id": 44867848,
    "by": "brabel",
    "timeISO": "2025-08-11T18:42:42.000Z",
    "textPlain": "How does that compare in terms of usability and completeness?",
    "parent": 44867539,
    "depth": 2
  },
  {
    "id": 44870748,
    "by": "layer8",
    "timeISO": "2025-08-11T23:44:18.000Z",
    "textPlain": "Should probably link to https://github.com/palantir/javapoet instead, as the Square version has been deprecated since 2020.",
    "parent": 44868252,
    "depth": 2
  },
  {
    "id": 44871528,
    "by": "hansvm",
    "timeISO": "2025-08-12T01:59:37.000Z",
    "textPlain": "Sure:- There are how many computer architectures? A compile-once-run-anywhere binary looks closer to shipping a fancy interpreter with your code than shipping a compiled project. Runtime bytecode generation is one technique for making that fast.- More generally, anything you don't know till runtime generates a huge amount of bloat if you handle it at compile-time. Imagine, e.g., a UI for dragging and dropping ML components to create an architecture. For as much compute as you're about to pour into training, even for very simple problems, it's worth something that looks like a compilation pass to appropriately fuse everything together. You could probably get away with literally shipping a compiler, but bytecode generation is a reasonable solution too.- Some things are literally impossible at compile-time without boxing and other overhead. E.g., once upon a time I made a zero-cost-abstraction library allowing you to specify an ML computational graph using the type system (most useful for problems where you're not just doing giant matmuls all day). It was in a language where mutually recursive generics are lazily generated, so you're able to express arbitrary nth derivatives still in the type system, still with zero overhead. What you can't do though is create a runtime program capable of creating arbitrary derivatives; there must be an upper bound for any finite-sized binary (for sufficiently complex starting functions) -- you could cap it at 2nd derivatives or 10th or whatever, but there would have to be a cap. If you move that to runtime though then you can have your cake and eat it too, less the cost of compiling (i.e., bytecode generation) at runtime.Etc. It's a tradeoff between binary size (which might have to be infinite in the compiled case) and runtime overhead (having to \"compile\" for each new kind of input you find).",
    "parent": 44868675,
    "depth": 2
  },
  {
    "id": 44871706,
    "by": "exabrial",
    "timeISO": "2025-08-12T02:32:09.000Z",
    "textPlain": "I think that's noteworthy, but just not necessary. Still really cool if memory usage and startup times are your constraints.",
    "parent": 44868675,
    "depth": 2
  },
  {
    "id": 44872170,
    "by": "geokon",
    "timeISO": "2025-08-12T03:44:43.000Z",
    "textPlain": "where to start?",
    "parent": 44867437,
    "depth": 2
  },
  {
    "id": 44872129,
    "by": "symbolicAGI",
    "timeISO": "2025-08-12T03:37:34.000Z",
    "textPlain": "A recent good reason for using Java is that frontier LLMs are trained with very large amounts of high quality enterprise Java source code. Claude Code for example loves Java and its static type system.I constrain my LLM-generated Java code to only static methods of 20 LOC or less, and limit data types to those that are JSON compatible. Both of these lead to more reliable code and data that Claude Code fully understands and generates.I am preparing to auto-generate an agent-based application that might reach 1.5 million Java LOC. Hard to imagine accomplishing that with Javascript or Python or C++.",
    "parent": 44868464,
    "depth": 2
  },
  {
    "id": 44870422,
    "by": "AdieuToLogic",
    "timeISO": "2025-08-11T23:00:24.000Z",
    "textPlain": "> The better question is why use Java for anything these days.Java (the language) is pretty much \"C for the JVM.\"  By that, I mean frameworks/libraries intended for maximum potential use in languages running on the JVM (such as Kotlin, Scala, and of course Java) all support Java (the language) interoperability.  Many written in alternate languages targeting the JVM, such as Akka[0], typically have some degree of Java (the language) support as well.While I prefer to program in one of the alternate programming languages targeting the JVM, I understand why many OSS projects are implemented in Java (the language) for the reasons outlined above.0 - https://github.com/akka/akka",
    "parent": 44868464,
    "depth": 2
  },
  {
    "id": 44868632,
    "by": "ackfoobar",
    "timeISO": "2025-08-11T19:47:06.000Z",
    "textPlain": "As a Kotlin enjoyer, I find these comments counterproductive. Maybe they like the lack of extension functions?",
    "parent": 44868464,
    "depth": 2
  },
  {
    "id": 44872345,
    "by": "peterashford",
    "timeISO": "2025-08-12T04:14:04.000Z",
    "textPlain": "I've worked in both and I prefer Java",
    "parent": 44868464,
    "depth": 2
  }
]
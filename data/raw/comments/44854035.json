[
  {
    "id": 44854235,
    "by": "homebrewer",
    "timeISO": "2025-08-10T10:34:36.000Z",
    "textPlain": "With fish, if the program you're interested in hasn't betrayed the decades-old tradition of shipping man pages, it's often as simple as running `fish_update_completions`.It parses all man pages on your system and generates completion files for you. By default, they go into ~/.cache/fish/generated_completions/*If the man page was written poorly/is missing, you can always write your own completion (and hopefully send it upstream). fish uses such a simple format that I don't think there's any need for tutorials save the official doc:https://fishshell.com/docs/current/completions.htmlFor example, here's an excerpt from curl  complete --command curl --short-option 'L' --long-option 'location' --description 'Follow redirects' \n  complete --command curl --short-option 'O' --long-option 'remote-name' --description 'Write output to file named as remote file'",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854384,
    "by": "derriz",
    "timeISO": "2025-08-10T11:06:55.000Z",
    "textPlain": "I feel that the ergonomics of bash completion took a hit as the configurations got “smarter” and “helpfully” started blocking file or directory name completion if it thinks it wouldn’t be appropriate to have a file name at the current cursor position.  Instead of blocking, the default should always be to fall back to filename completion.Sometimes I’m close to disabling/uninstalling all completion scripts out of irritation as decades of muscle memory are frustrated by this behavior.It’s like that bad/annoying UX with text fields where the UI is constantly fighting against you in order prevent you from producing “illegal” intermediate input - e.g. let me paste the clipboard here goddammit - I know what I’m doing - I’ll correct it.",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854164,
    "by": "lihaoyi",
    "timeISO": "2025-08-10T10:21:14.000Z",
    "textPlain": "I wrote this, hope everyone finds it as interesting reading this as I did figuring this out for the first time!",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44860778,
    "by": "vismit2000",
    "timeISO": "2025-08-11T04:37:09.000Z",
    "textPlain": "Since auto text completion is the primary task of an LLM, I have seen GitHub copilot do that very well on both bash and zsh within vscode terminal!",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44857473,
    "by": "paradox460",
    "timeISO": "2025-08-10T19:14:03.000Z",
    "textPlain": "I've started using jdx's usage[1] for my clis. It integrates neatly into clap, and can be used stand alone in scripts. It can generate completions, argparse, manpages, and moreI'm still on the fence if replacing the argparse blocks in my fish scripts is worth the hassle, but against things like old school optparse, it's far better[1]: https://usage.jdx.dev/",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854775,
    "by": "medv",
    "timeISO": "2025-08-10T12:36:01.000Z",
    "textPlain": "JSON fields autocomplete right in bash/zsh: https://fx.wtf/install#autocomplete",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854174,
    "by": "oezi",
    "timeISO": "2025-08-10T10:22:26.000Z",
    "textPlain": "Isn't there a standard flag which programs can implement to avoid writing this bash script?Ideally this could all be part of a library such as argparse for typical cases, right?",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854218,
    "by": "vcdimension",
    "timeISO": "2025-08-10T10:31:54.000Z",
    "textPlain": "Here's another tutorial for creating zsh completers using the built-in functions: https://github.com/vapniks/zsh-completions/blob/master/zsh-c...",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854992,
    "by": "sebtron",
    "timeISO": "2025-08-10T13:16:06.000Z",
    "textPlain": "Basic completion in ksh is as easy as defining an array. From https://man.openbsd.org/ksh :Custom completions may be configured by creating an array named ‘complete_command’, optionally suffixed with an argument number to complete only for a single argument. So defining an array named ‘complete_kill’ provides possible completions for any argument to the kill(1) command, but ‘complete_kill_1’ only completes the first argument. For example, the following command makes ksh offer a selection of signal names for the first argument to kill(1):    set -A complete_kill_1 -- -9 -HUP -INFO -KILL -TERM",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854574,
    "by": "vbezhenar",
    "timeISO": "2025-08-10T11:51:29.000Z",
    "textPlain": "Here's zsh snippet I've came up with for my own simple functions. I'm using it as a base for other completions. In this example, function `set-java-home zulu-21` sets JAVA_HOME to `~/apps/java/zulu-21`. Here's `_set-java-home`:    #compdef set-java-home\n    \n    local -a versions=(~/apps/java/*(:t))\n    _describe 'version' versions\n\nSo basically almost a one-liner (but couldn't do it really one-liner, unfortunately).",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854971,
    "by": "harimurti",
    "timeISO": "2025-08-10T13:12:06.000Z",
    "textPlain": "I’m not familiar with `_gnu_generic`, but it sounds like a handy shortcut for basic completions without writing a full script. Does it work with commands that only have `--help` but no man pages?",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854197,
    "by": "bravesoul2",
    "timeISO": "2025-08-10T10:26:57.000Z",
    "textPlain": "Do many people do bash on osx or zsh on Linux, and would this make much of a difference?",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854278,
    "by": "camdroidw",
    "timeISO": "2025-08-10T10:43:46.000Z",
    "textPlain": "Why doesn't someone (not me) just build a basic DSL and a transpiler that does this?",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44857274,
    "by": "gosub100",
    "timeISO": "2025-08-10T18:43:02.000Z",
    "textPlain": "I did something similar to this for tab-completing server names for use with ssh. I went a step further and allowed pattern matching based on the server being qa/prod and on locale. so for instance you could type `ssh co prod <tab>` and it would tab-complete / suggest any servers that were production and located in the Denver datacenter (co is the state abbrev for Colorado, for non-US readers).Unfortunately my work doesn't allow me to share code, but essentially I remapped ssh to a bash script that maintains an environment variable containing the args (you must do this because each <tab> press is an independent invocation of the script. Then you run into persistence problems, so I added a call to compute elapsed seconds so that it flushes the state variable after a 10s timeout).The bash script then forwards the args to a python script that reads a JSON file and figures out which params (such as 'co' or 'qa') map to which hostnames. It also matches against partial hostnames, so when you see this after tabqa-server-co1\nqa-server-co2\npr-server-co3you only need to add '3' to the list of args to narrow it down to 1 match, then hit <enter> to ssh to that host.",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854959,
    "by": "xenophonf",
    "timeISO": "2025-08-10T13:09:40.000Z",
    "textPlain": "I wish tcsh would get more love.",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44854228,
    "by": "wiseowise",
    "timeISO": "2025-08-10T10:33:45.000Z",
    "textPlain": "Shell syntax is the exact reason why we've needed LLMs in the first place.",
    "parent": 44854035,
    "depth": 1
  },
  {
    "id": 44856093,
    "by": "yencabulator",
    "timeISO": "2025-08-10T16:02:54.000Z",
    "textPlain": "I'll switch to fish after it stops expanding `car TAB` to `blkdiscard` when I don't have `cargo` in path. Non-prefix completion for commands is plain evil.",
    "parent": 44854235,
    "depth": 2
  },
  {
    "id": 44854299,
    "by": "btreecat",
    "timeISO": "2025-08-10T10:47:56.000Z",
    "textPlain": "When I screen share, people don't realize I'm not using zsh and dozen plugins. It's just fish and it's beautiful out of the box.",
    "parent": 44854235,
    "depth": 2
  },
  {
    "id": 44860411,
    "by": "fishywang",
    "timeISO": "2025-08-11T02:55:31.000Z",
    "textPlain": "I tried to use fish on some of my debian servers that i only rarely update packages/kernel, so I don't have to carry my bashrc there, but found their completion for apt is pretty naive. for example after updated kernel i would want to clean up the old ones, but `apt purge linux-image-<TAB>` would list all available kernel versions, not just the ones currently installed.in the end i switched back to bash.",
    "parent": 44854235,
    "depth": 2
  },
  {
    "id": 44854453,
    "by": "kekebo",
    "timeISO": "2025-08-10T11:22:15.000Z",
    "textPlain": "Thank you for the comment.  \nhttps://github.com/umlx5h/zsh-manpage-completion-generator appears to adapt this to ZSH. Have yet to try through",
    "parent": 44854235,
    "depth": 2
  },
  {
    "id": 44854808,
    "by": "cb321",
    "timeISO": "2025-08-10T12:43:08.000Z",
    "textPlain": "For those programs that have betrayed shipping man pages, instead say relying only on a --help system, do you happen to know if the fish shell has an analogue to Zsh `_gnu_generic` and Bash `complete -F _longopt`?  If not, do you have any insight into why not/what it would take to make that happen?",
    "parent": 44854235,
    "depth": 2
  },
  {
    "id": 44855114,
    "by": "sanewombat",
    "timeISO": "2025-08-10T13:37:56.000Z",
    "textPlain": "It's surprising that on OpenSUSE `zypper search fish-completion` returns more than 200 packages. Something is fishy here.",
    "parent": 44854235,
    "depth": 2
  },
  {
    "id": 44855281,
    "by": "IgorPartola",
    "timeISO": "2025-08-10T14:07:04.000Z",
    "textPlain": "man pages are so underrated. I mean every project nowadays has README.md so I don’t see why we can’t just auto generate them with or without an LLM helping. Also I wish programs would use standardized generic arguments for help, config file, version, background the task, PID file, log file, and log level.",
    "parent": 44854235,
    "depth": 2
  },
  {
    "id": 44855013,
    "by": "jnpnj",
    "timeISO": "2025-08-10T13:19:31.000Z",
    "textPlain": "oh wow, it's parsing all 9461 man pages on my arch install, for a cute total of 13MBthanks a lot",
    "parent": 44854235,
    "depth": 2
  },
  {
    "id": 44855551,
    "by": "JNRowe",
    "timeISO": "2025-08-10T14:45:22.000Z",
    "textPlain": "There is the complete-filename function that only completes filenames in bash, bound to M-/ by default.  You can use that in any place you want a filename where \"complete\"(the function normally bound to tab) would do something you don't desire.There are a collection of other non-context aware completion functions that are bound by default too, useful for example when you when you wish to complete hostnames in a for-loop.zle has what is largely a significant superset of this, the documentation is spread about between the zshzle and zshcomp* manpages.",
    "parent": 44854384,
    "depth": 2
  },
  {
    "id": 44855140,
    "by": "loeg",
    "timeISO": "2025-08-10T13:41:46.000Z",
    "textPlain": "There is one particular command I occasionally use that has totally broken completion for files, so I've taken to just using 'ls X Y Z' to get the right completion behavior and then changing 'ls' to the right command as the last step.",
    "parent": 44854384,
    "depth": 2
  },
  {
    "id": 44854543,
    "by": "IshKebab",
    "timeISO": "2025-08-10T11:44:53.000Z",
    "textPlain": "I agree that is annoying. It's waaay less confusing to complete a filename and then get an error from the actual program than it is for just ...nothing to happen so you get confused and have to `ls` to check if the file actually exists and it does and so you think tab completion is broken for some reason and you copy & paste the filename and then finally you get the error that explains what is going on.It should at least print a message like \"file foo.exe exists but it isn't executable\".",
    "parent": 44854384,
    "depth": 2
  },
  {
    "id": 44854534,
    "by": "compressedgas",
    "timeISO": "2025-08-10T11:43:05.000Z",
    "textPlain": "As it works as desired after running: complete -r; there is something broken about the bash-completion script.",
    "parent": 44854384,
    "depth": 2
  },
  {
    "id": 44854399,
    "by": "cryptoz",
    "timeISO": "2025-08-10T11:13:19.000Z",
    "textPlain": "I have come to absolutely despise web form inputs with front end email validators that are broken. Input field hints to type your email, so you start typing. As soon as you type the first letter it goes red and says “error!!! Invalid email!”Unbelievably frustrating.",
    "parent": 44854384,
    "depth": 2
  },
  {
    "id": 44855289,
    "by": "bbkane",
    "timeISO": "2025-08-10T14:07:45.000Z",
    "textPlain": "Thanks for sharing! I hope to incorporate your bash completion ideas into my CLIs (I've already got zsh completions).Instead of sourcing the zsh completion script on every startup, you can install it into somewhere on $fpath and zsh will \"compile\" and cache the completions. This can really speed up shell startup time, but of course is harder to set up. Users have to understand $fpath to put the completions there.I distribute my CLIs via Homebrew which can install completions automatically.",
    "parent": 44854164,
    "depth": 2
  },
  {
    "id": 44854302,
    "by": "tetha",
    "timeISO": "2025-08-10T10:49:14.000Z",
    "textPlain": "It's a good first dive into zsh completion. The whole thing is quite the large system to wrap ones head around it and I'm still somewhat struggling.But at work, I've been slowly adding auto completion to our ansible wrapper scripts, like explanations which playbooks to use when, smart `-l` completion based off a possibly selected playbook (so, if the playbook is postgres.yml, it doesn't suggest mariadb groups), tag autocompletion (with a few, admittedly, hardcoded explanations how these tags should be used) and such.It's somewhat of a friday-afternoon struggle project, but it's making the big ansible project pretty approachable to use.",
    "parent": 44854164,
    "depth": 2
  },
  {
    "id": 44854179,
    "by": "oezi",
    "timeISO": "2025-08-10T10:23:00.000Z",
    "textPlain": "Thanks, for the interesting read.",
    "parent": 44854164,
    "depth": 2
  },
  {
    "id": 44859518,
    "by": "FujiApple",
    "timeISO": "2025-08-10T23:50:55.000Z",
    "textPlain": "I’ve recently been building a similar tool [1] which defines a specification for CLIs, though the goals are slightly different to the tool you mention I think. I just added support for fish as it happens.[1] https://github.com/fujiapple852/claptrap",
    "parent": 44857473,
    "depth": 2
  },
  {
    "id": 44854799,
    "by": "imcritic",
    "timeISO": "2025-08-10T12:41:31.000Z",
    "textPlain": "Thanks for linking this! This is a lightweight solution, compared to ijq (interactive jq), but it still may come in handy.https://github.com/gpanders/ijq",
    "parent": 44854775,
    "depth": 2
  },
  {
    "id": 44854206,
    "by": "vcdimension",
    "timeISO": "2025-08-10T10:28:55.000Z",
    "textPlain": "In zsh you can use the _gnu_generic function for simple completion of commands with a --help flag. \nJust put a line like this somewhere in your startup file: compdef _gnu_generic <CMD>",
    "parent": 44854174,
    "depth": 2
  },
  {
    "id": 44855703,
    "by": "duckerude",
    "timeISO": "2025-08-10T15:08:13.000Z",
    "textPlain": "Rust has the clap_complete package for its most popular arg parsing library: https://crates.io/crates/clap_completeripgrep exposes its (bespoke) shell completion and man page generation through a --generate option: rg --generate=man, rg --generate=complete-bash, etcetera. In xh (clap-based) we provide the same but AFAIK we're the only one to copy that interface.Symfony (for PHP) provides some kind of runtime completion generation but I don't know the details.",
    "parent": 44854174,
    "depth": 2
  },
  {
    "id": 44854479,
    "by": "mnahkies",
    "timeISO": "2025-08-10T11:30:01.000Z",
    "textPlain": "I've wondered this as well - it would sure be nice if there was a standard --completion or something that common argument parsing libraries could automatically implement for us (much like they often implement automatic help text)",
    "parent": 44854174,
    "depth": 2
  },
  {
    "id": 44855957,
    "by": "chasil",
    "timeISO": "2025-08-10T15:44:52.000Z",
    "textPlain": "Is this in the Korn & Bolsy ksh88 book?Or is this ksh93 syntax that oksh back ported?",
    "parent": 44854992,
    "depth": 2
  },
  {
    "id": 44854251,
    "by": "homebrewer",
    "timeISO": "2025-08-10T10:38:02.000Z",
    "textPlain": "I don't know about \"use\" — luckily, there's no opt-out telemetry — but enough of \"enthusiast distribution\" users who have also opted in (very biased sample) have explicitly installed zsh (not necessarily run it)https://pkgstats.archlinux.de/compare/packages#packages=bash...OTOH, it's only 4-7% on Debian (also opt-in):https://qa.debian.org/popcon.php?package=zsh",
    "parent": 44854197,
    "depth": 2
  },
  {
    "id": 44855363,
    "by": "bbkane",
    "timeISO": "2025-08-10T14:18:31.000Z",
    "textPlain": "People do!See: https://pixi.carapace.sh/ or https://github.com/withfig/autocompleteIt's still a hard problem as lots of tools format --help differently. One of the things I'm jealous in Poweshell is their standardized completions",
    "parent": 44854278,
    "depth": 2
  },
  {
    "id": 44854385,
    "by": "cb321",
    "timeISO": "2025-08-10T11:07:14.000Z",
    "textPlain": "The answer to your question is that command-lines have a much larger diversity of syntax (even to get help!) than most people realize.  Folks have their 30..60 commands they run frequently and don't run into many or conveniently forget/neglect older ones like `gcc` or `tar` or `dd`.  Many people (not saying you specifically) do not even realize that double-dash long options are a GNU extension never standardized or that Python toolkits typically allow --my-opt for --my-option abbreviations, just to name a couple of the dozen variations (space or '=', or ':' or '/' or any of the above or etc., etc.).  There are probably hundreds if not thousands of syntax possibilities, but people often act like there is only one.As an example of diversity estimation that you can try at home, a couple of times I have run every single command in my command search PATH with --help </dev/null >/tmp/help.$c 2>&1 .  Caution - be careful if you do this!  Have backups/checksums of everything important and run as an unprivileged user.  I always have to kill off several processes that just hang doing something or otherwise manually intervene.  Anyway, this alone suggests data collection of help text is not a trivial problem.Beyond data collection, many commands did not/do not use CLI toolkits at all.  Their commands may have even less regular syntax.  Freeform help makes it harder to produce a regular help syntax to convert into the interpreter needed by a completion system.  That said, as elsethread commented for some toolkits the Zsh _gnu_generic works great!  It essentially IS the \"automagic\" system you might want, just for a highly restricted circumstance.Any CLI toolkit itself does have the data, by necessity.  So, if the CLI framework supports the 2 or 3 common shells there is no need for a translator exactly.  You just need a code generator.  There is a stab at an auto-generation framework from said data for the Nim CLI toolkit, cligen, over at:https://github.com/c-blake/cligen/blob/ma",
    "parent": 44854278,
    "depth": 2
  },
  {
    "id": 44856004,
    "by": "chasil",
    "timeISO": "2025-08-10T15:51:21.000Z",
    "textPlain": "There is a famous paper on the perils of scripting in the csh. It is unfortunate that Bill Joy was not able to write a formal grammar or parser for his language. It was certainly a missed opportunity, and tcsh cannot fix the design.That being said, csh advocates definitely influenced everything in the Bourne/POSIX family.",
    "parent": 44854959,
    "depth": 2
  },
  {
    "id": 44855832,
    "by": "esafak",
    "timeISO": "2025-08-10T15:23:43.000Z",
    "textPlain": "Why, it's a dinosaur? Have you tried nushell, murex, oil shell or xonsh?",
    "parent": 44854959,
    "depth": 2
  },
  {
    "id": 44856571,
    "by": "anthk",
    "timeISO": "2025-08-10T17:08:48.000Z",
    "textPlain": "Perl solved that 20 years ago.And `rc` under plan9/9front did a Unix shell better than the classic Unix itself.",
    "parent": 44854228,
    "depth": 2
  },
  {
    "id": 44854270,
    "by": "camdroidw",
    "timeISO": "2025-08-10T10:42:13.000Z",
    "textPlain": "You mean Unix shell syntax. Powershell has got this absolutely right ,and only this (which is probably still a 50% of what a shell is)",
    "parent": 44854228,
    "depth": 2
  }
]
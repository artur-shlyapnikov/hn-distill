[
  {
    "id": 44843607,
    "by": "akkad33",
    "timeISO": "2025-08-09T02:31:08.000Z",
    "textPlain": "F# is a chimera of a language. The functional parts of the language are nicely designed: no nulls, discriminated unions (ADTs), you write simple functions in simple modules and there is nothing that is too clever to understand: it's very pragmatic. Then there is a whole lot of stuff like inheritance, classes, interfaces, nulls mainly there for dotnet interoperability that gets very ugly very fast. There are way too many variants of the same thing: records, classes, struct records, tuples, struct tuples etc, which are mainly there either for compatibility with similar c# stuff or because the default language constructs often result in suboptimal code. At the end I went with Rust because it has one way of doing such stuff. And for those interested in a gc language with functional features there is now Gleam",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843492,
    "by": "mrbluecoat",
    "timeISO": "2025-08-09T02:08:28.000Z",
    "textPlain": "When your top reason for a language being mainstream is \"interoperability with .NET\", I think the argument is a stretch.",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843682,
    "by": "glimshe",
    "timeISO": "2025-08-09T02:49:32.000Z",
    "textPlain": "This feels like \"This year is the year of Linux on the Desktop\"I've been hearing about F# hitting mainstream for over a decade. Unlike Linux, which is now fairly popular on the Desktop, I predict that F# won't ever be mainstream.",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843522,
    "by": "jakebasile",
    "timeISO": "2025-08-09T02:15:09.000Z",
    "textPlain": "Could be! Depends if MS starts putting some more money behind it, including marketing. They're pretty deep in an AI-everything spiral right now though.I'm a Clojure guy, but the ML family (specifically OCaml and F#) have always interested me as another branch of functional programming. I started out in the before times as a .NET Programmer (VB6 -> VB.NET -> C#) and have toyed with F# a little since then. It's cool, but the tooling leaves a lot to be desired compared to what's available for OCaml unless you decide to use full fat Visual Studio.What I particularly like about them is the middle ground of inferred types. I don't need types since maps, lists, and value types are enough for me in almost all cases, but if I must use a strongly typed system why not let the compiler figure it out for me? I always thought that was a neat idea.",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843755,
    "by": "wewewedxfgdf",
    "timeISO": "2025-08-09T03:10:57.000Z",
    "textPlain": "Functional programming people have been hoping for their favorite functional language to go mainstream for a long time but it never happens.",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843632,
    "by": "hirvi74",
    "timeISO": "2025-08-09T02:38:05.000Z",
    "textPlain": "Oh my, please!I haven't used F# too terribly much, but as a .Net dev, it's never gotten the love it deserves. I would probably have converted over if there was better third-party library support for the language. (I haven't check in a some years)",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843534,
    "by": "CharlieDigital",
    "timeISO": "2025-08-09T02:17:05.000Z",
    "textPlain": "I tried F# when we were building out a scraper at a startup.  After a bit, I realized that must of the things could also be done in C# and ended up using C# instead because it's just a bit more accessible.  F# looks neat, but C# has a lot of parity at this point on some of the core selling points IMO.",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843571,
    "by": "mbac32768",
    "timeISO": "2025-08-09T02:25:00.000Z",
    "textPlain": "I do not understand how they could develop a language inspired by OCaml but not bring over labeled function arguments. A real L when it comes to ergonomics.And they just have no plans to ever fix this??",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843618,
    "by": "Beermotor",
    "timeISO": "2025-08-09T02:34:30.000Z",
    "textPlain": "I became more proficient in one language than any other. Therefore this language is the best language ever and will take over the universe.",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843493,
    "by": "UncleOxidant",
    "timeISO": "2025-08-09T02:08:43.000Z",
    "textPlain": "Wishful thinking, me thinks. How good are the AI coding agents at coding F#?",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843554,
    "by": "thuridas",
    "timeISO": "2025-08-09T02:21:37.000Z",
    "textPlain": "Not having exceptions doesn't seem like an advantage. My experience with either tough me that some infrastructure error are better as exceptions.Kotlin handling of nulls is probably the most elegant. And you do not need. Net. When you want 20 pods in kubernetes you probably want some alpine image instead of windows",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843525,
    "by": "SoftTalker",
    "timeISO": "2025-08-09T02:15:24.000Z",
    "textPlain": "C# was Microsoft’s response to Java, was F# their response to Scala and Clojure?",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843676,
    "by": "daft_pink",
    "timeISO": "2025-08-09T02:47:45.000Z",
    "textPlain": "Seems unlikely as most of us are ditching .netI was a Microsoft fanboy years ago but even I am completely uninterested these days.",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843448,
    "by": "smoothdeveloper",
    "timeISO": "2025-08-09T02:00:12.000Z",
    "textPlain": "Just a polling of HN hive mind on this critical matter.Worst case, let the \"tried F# once/for real\" ramblers unload their bag once more :)",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843518,
    "by": "binarysneaker",
    "timeISO": "2025-08-09T02:14:29.000Z",
    "textPlain": "Nope.",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843617,
    "by": "lihaciudaniel",
    "timeISO": "2025-08-09T02:34:30.000Z",
    "textPlain": "If you do not believe in the python supremacy you are an idiot. C#, F#, M#, G# these are chords not programming languages.",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843561,
    "by": "sheepscreek",
    "timeISO": "2025-08-09T02:23:52.000Z",
    "textPlain": "I think, we’re not far from the day when LLMs will be spitting out highly optimized ilasm/byte-code (dotnet intermediate language representation). So your programming language will well and truly be a bunch of prompts. That’s it.",
    "parent": 44843447,
    "depth": 1
  },
  {
    "id": 44843781,
    "by": "DimmieMan",
    "timeISO": "2025-08-09T03:19:33.000Z",
    "textPlain": "C# will eventually have unions that will undoubtedly be incompatible too, I worry about source generators becoming ubiquitous as well.This was also my experience with F#, phenomenal language dragged down by ugly interop with an ecosystem that barely acknowledges its existence and I feel is incompatible with its ideals.Shame too because there’s some genuinely great stuff in the community like fable [1] where if you were to chuck in JSX like templating you’d have an absolute killer web tool rather than the mess blazor is.It’s ironic, and an indictment of .Net that I found js interop less annoying than .net interop.[1] https://github.com/fable-compiler/Fable",
    "parent": 44843607,
    "depth": 2
  },
  {
    "id": 44843634,
    "by": "banashark",
    "timeISO": "2025-08-09T02:38:44.000Z",
    "textPlain": "Well there are the 3 you mentioned (records, classes, and tuples) which should be easy enough to differentiate from each other. The struct versions aren't necessary to use in most cases, and are an optimization.The thoughtful, but not breakneck speed of changes within the language is one thing I appreciate a lot. Things do get added (there are proposals and discussions that are fairly regular in the GitHub repo for language design matters). A recent example is adding a spread operator.",
    "parent": 44843607,
    "depth": 2
  },
  {
    "id": 44843620,
    "by": "banashark",
    "timeISO": "2025-08-09T02:35:29.000Z",
    "textPlain": "I understand where you're coming from, but I'd challenge your dismissal of that note by noting how seemingly powerful a large ecosystem of available packages is when onboarding people to an ecosystem.I don't think Scala, Kotlin, or Clojure would have had as much adoption if they hadn't had access to the JVM ecosystem of libraries available.While it's not the only benefit, I think one could just point at the usage of OCaml as the alternative to F#. While both are in the lower percentages of language popularity/usage, I've worked with at least 50 (dozens lol) people who were paid to write production F#.",
    "parent": 44843492,
    "depth": 2
  },
  {
    "id": 44843661,
    "by": "enjo",
    "timeISO": "2025-08-09T02:43:53.000Z",
    "textPlain": "It's Scala all over again.",
    "parent": 44843492,
    "depth": 2
  },
  {
    "id": 44843743,
    "by": "ffin",
    "timeISO": "2025-08-09T03:07:11.000Z",
    "textPlain": "not to get into this debate, but linux is far from mainstream",
    "parent": 44843682,
    "depth": 2
  },
  {
    "id": 44843591,
    "by": "CrimsonCape",
    "timeISO": "2025-08-09T02:27:52.000Z",
    "textPlain": "I had a thought today, \"when is Microsoft and/or Apple going to earnestly search out their next Steve Jobs?\"And I think the answer is that guys like Bill Gates and Tim Cook are too proud, too prideful to admit they are not kickass rockstars of tech, too jealous to find and cultivate their next super-figurehead. Instead they are safe and lame.Microsoft needs a non-lame, non-MBA, engineer to take control and inject some younger mindset into making themselves cool again, focused back on tech, UI, user experience, and passion. Engineer tooling would be a great approach.",
    "parent": 44843522,
    "depth": 2
  },
  {
    "id": 44843650,
    "by": "AdieuToLogic",
    "timeISO": "2025-08-09T02:41:20.000Z",
    "textPlain": "> I do not understand how they could develop a language inspired by OCaml but not bring over labeled function arguments. A real L when it comes to ergonomics.Is this what you desire?  Named Arguments[0]\n\n  Arguments for methods can be specified by position in a \n  comma-separated argument list, or they can be passed to a \n  method explicitly by providing the name, followed by an \n  equal sign and the value to be passed in. If specified by \n  providing the name, they can appear in a different order \n  from that used in the declaration.\n\n0 - https://learn.microsoft.com/en-us/dotnet/fsharp/language-ref...",
    "parent": 44843571,
    "depth": 2
  },
  {
    "id": 44843693,
    "by": "buffet_overflow",
    "timeISO": "2025-08-09T02:53:30.000Z",
    "textPlain": "That language isn’t the same language I became more proficient in, so are you sure it’s not terrible, useless, and will lose handily to the one I use for my specific purposes?",
    "parent": 44843618,
    "depth": 2
  },
  {
    "id": 44843581,
    "by": "banashark",
    "timeISO": "2025-08-09T02:26:04.000Z",
    "textPlain": "Comparisons to typescript/node (which I have more ai hours in, but equal experience)Pros:* type system is less flexible which simplifies things for the ai* mostly functional code* the language hasn’t evolved as much as others because it’s had a strong foundation of features for a while, leading to the corpus containing fairly common themesCons:* smaller corpus* no reliable hot reloading, which causes annoying iterations of starting a server in the background to test, then forgetting to stop it and hitting errors from starting it again. It does this even when attempting to prompt against it* Struggles with some breaking changes and interfaces for dotnet things (using old apis, installing old versions of packages)* file ordering dependency messes with its flow. Usually has to stop to reorder things every once in a while. Can create a mess in the fsprojOverall my “tier-list” so far has f# below typescript, but above a number of other environments (Kotlin/jvm, Ruby, c#).Last week I wrote out a 2 page prd for a small service and it got about 95% of the way there (not including tests). If you’re promoting doesn’t have to do with web framework stuff, or you have a repository with existing patterns, it does pretty well.I gave it a task of “write an inertiajs 2.0 server compatibility library for the oxpecker framework” with a few extra things to create an example test and verify with the playwright mcp. It struggled pretty hard and didn’t end up anywhere close to what I had in my head.So I’d definitely say that directing it more than vibing would yield a higher chance at success.",
    "parent": 44843493,
    "depth": 2
  },
  {
    "id": 44843646,
    "by": "banashark",
    "timeISO": "2025-08-09T02:40:38.000Z",
    "textPlain": "As noted in another sibling comment, f# has exceptions and they're a good tool to use.Some folks opt to go full \"railroad-oriented programming\" mode, but using both has more benefits. Here is a good article on it: https://medium.com/@lanayx/practical-error-handling-in-f-c3c...",
    "parent": 44843554,
    "depth": 2
  },
  {
    "id": 44843566,
    "by": "zdragnar",
    "timeISO": "2025-08-09T02:24:24.000Z",
    "textPlain": "You can have your cake and eat it too with dotnet core on Linux if we're talking remote / web servers.",
    "parent": 44843554,
    "depth": 2
  },
  {
    "id": 44843559,
    "by": "CharlieDigital",
    "timeISO": "2025-08-09T02:23:33.000Z",
    "textPlain": "C# runs fine on Alpine.https://learn.microsoft.com/en-us/dotnet/core/install/linux-...Welcome to 2025.",
    "parent": 44843554,
    "depth": 2
  },
  {
    "id": 44843609,
    "by": "akkad33",
    "timeISO": "2025-08-09T02:32:01.000Z",
    "textPlain": "F# has exceptions though",
    "parent": 44843554,
    "depth": 2
  },
  {
    "id": 44843584,
    "by": "azhenley",
    "timeISO": "2025-08-09T02:26:27.000Z",
    "textPlain": "It was a Microsoft Research project based on OCaml and adapted for .Net.",
    "parent": 44843525,
    "depth": 2
  },
  {
    "id": 44843638,
    "by": "swader999",
    "timeISO": "2025-08-09T02:39:34.000Z",
    "textPlain": "Clojure is the youngest in that group.",
    "parent": 44843525,
    "depth": 2
  },
  {
    "id": 44843543,
    "by": "moron4hire",
    "timeISO": "2025-08-09T02:19:17.000Z",
    "textPlain": "It's a research language with legs. Microsoft's explicit strategy with F# is to test functional features they might decide to bring into C#.",
    "parent": 44843525,
    "depth": 2
  },
  {
    "id": 44843495,
    "by": "adastra22",
    "timeISO": "2025-08-09T02:08:51.000Z",
    "textPlain": "The very first advantage listed is actually a disadvantage for 95% of developers.“Wedded to the dotnet ecosystem.”",
    "parent": 44843448,
    "depth": 2
  },
  {
    "id": 44843597,
    "by": "suprjami",
    "timeISO": "2025-08-09T02:29:23.000Z",
    "textPlain": "I think that's unlikely to get widespread traction.Source code is not for computers, it is a way for human developers to communicate with each other.Compilers/interpreters are a consumer of that communication.Without easy communication of ideas, software does not work. That's why very few people write in raw assembly (hardware or bytecode) and why so many people write in programming languages.LLMs will not remove the human interchange of ideas. At least not the current generation of generative LLMs.",
    "parent": 44843561,
    "depth": 2
  },
  {
    "id": 44843596,
    "by": "adzm",
    "timeISO": "2025-08-09T02:29:22.000Z",
    "textPlain": "What would be the benefit to this versus generating highly optimized c# for example?",
    "parent": 44843561,
    "depth": 2
  }
]
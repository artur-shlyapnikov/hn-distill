[
  {
    "id": 44846761,
    "by": "tastyminerals2",
    "timeISO": "2025-08-09T14:31:08.000Z",
    "textPlain": "Personally, I had good experience with marimos so far. Reactive execution, variable deduplication, clear business logic vs UI elements logic separation that is forced on you is good. It retrains ppl to write slightly better structured Python code which is a win in my eyes.",
    "parent": 44801392,
    "depth": 1
  },
  {
    "id": 44846144,
    "by": "getnormality",
    "timeISO": "2025-08-09T12:56:30.000Z",
    "textPlain": "> You have to be very disciplined to make a Jupyter notebook that is actually reproducibleThis seems not necessarily very hard to me? All you have to do is keep yourself honest by actually trying to reproduce the results of the notebook when you're done:1. Copy the notebook2. Run from first cell in the copy3. Check that the results are the same4. If not the same, debug and repeatWhat makes it hard is when the feedback loop is slow because the data is big. But not all data is big!Another thing that might make it hard is if your execution is so chaotic that debugging is impossible because what you did and what you think you did bear no resemblance. But personally I wouldn't define rising above that state as incredible discipline. For people who suffer from that issue, I think the best help would be a command history similar to that provided by RStudio.All that said, Marimo seems great and I agree notebooks are dangerous if their results are trusted equally as fully explicit processing pipelines.",
    "parent": 44801392,
    "depth": 1
  },
  {
    "id": 44846138,
    "by": "nylonstrung",
    "timeISO": "2025-08-09T12:55:45.000Z",
    "textPlain": "Marimo seems really solid if you like tools like Streamlit or Observable",
    "parent": 44801392,
    "depth": 1
  },
  {
    "id": 44845197,
    "by": "riedel",
    "timeISO": "2025-08-09T09:33:25.000Z",
    "textPlain": "Even with data flow extension (also like ipyflow [0] ) I am still struggling with the execution model of notebooks in general. I often still see people defining functions and classes in notebooks to somehow handle prototyping loops.I would love to see DAGs like in SSA form of compilers, that also supports loop operators. However, IMHO also the notebook interface needs to adjust for that (cell indentation ?). However, the strength of notebooks rather shows in document authoring like quarto, which IMHO mostly contradicts more complex controll flow.[0] https://github.com/ipyflow/ipyflow",
    "parent": 44801392,
    "depth": 1
  },
  {
    "id": 44845892,
    "by": "PeterStuer",
    "timeISO": "2025-08-09T12:07:51.000Z",
    "textPlain": "Would you not need \"volatile\" markup for anything touching a python external system?",
    "parent": 44801392,
    "depth": 1
  },
  {
    "id": 44845190,
    "by": "probablypower",
    "timeISO": "2025-08-09T09:32:19.000Z",
    "textPlain": "This is well written and an interesting read but, embedding notebooks into your data pipelines smells horrible.",
    "parent": 44801392,
    "depth": 1
  },
  {
    "id": 44847116,
    "by": "esafak",
    "timeISO": "2025-08-09T15:08:41.000Z",
    "textPlain": "Notebooks ought to have embedded metadata, like a pyproject.toml, to list the dependencies.",
    "parent": 44846144,
    "depth": 2
  },
  {
    "id": 44846712,
    "by": "tastyminerals2",
    "timeISO": "2025-08-09T14:24:39.000Z",
    "textPlain": "Not very hard to you, however the reproducibility numbers tell a different story. Back in the days, when we were searching for some ML model implementations in the public repos and found ipynb files in it, we skipped the repo without delving into details. Within the company data engineer research notebooks were never allowed inside a repo. Experiment, yes, but rewrite it in plain python and push.",
    "parent": 44846144,
    "depth": 2
  },
  {
    "id": 44847041,
    "by": "exe34",
    "timeISO": "2025-08-09T15:01:28.000Z",
    "textPlain": "The few times I've made notebooks, I've tried to migrate code out of the notebook as soon as possible and then only import foo and run foo.bar() in the notebook. It helps to only have the top level config/layout in the notebook.",
    "parent": 44846144,
    "depth": 2
  },
  {
    "id": 44846579,
    "by": "iamwil",
    "timeISO": "2025-08-09T14:09:05.000Z",
    "textPlain": "why does it smell horrible?",
    "parent": 44845190,
    "depth": 2
  },
  {
    "id": 44845605,
    "by": "nojito",
    "timeISO": "2025-08-09T11:14:17.000Z",
    "textPlain": "Marimo is just a .py file.",
    "parent": 44845190,
    "depth": 2
  }
]
[
  {
    "id": 44886800,
    "by": "Fraterkes",
    "timeISO": "2025-08-13T10:43:39.000Z",
    "textPlain": "Almost even more interesting is the Bezier Boolean-Operations lib they use (it’s a rewrite of Pathbool.js (https://github.com/r-flash/PathBool.js) in Rust)https://github.com/GraphiteEditor/Graphite/tree/master/libra...There’s not a ton of robust curve boolean libs out there that aren’t just part of some huge package of tools. This is the only one I know of that isn’t Js.(Edit: added a link)",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44888089,
    "by": "__jonas",
    "timeISO": "2025-08-13T13:19:57.000Z",
    "textPlain": "This looks really nice!I’m currently looking for a nice implementation of stroke expansion (here called outlining) that I can run in the browser, this seems like a good option besides skia (pathkit)[0] and vello/kurbo[1].Ideally I’d love to be able to expand in a non-uniform way, similar to what Metafont does for bitmap fonts, or what Inkscape allows with its power stroke effect, or even just with a non-uniform ‘nib’ as is possible with FontForge[2].This doesn’t seem to be something that these bezier libraries generally offer which is understandable, probably a rather niche goal.[0] https://skia.org/docs/user/modules/pathkit/[1] https://doc.servo.org/kurbo/stroke/index.html[2] https://fontforge.org/docs/techref/stroke.html",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44890097,
    "by": "LegionMammal978",
    "timeISO": "2025-08-13T15:53:54.000Z",
    "textPlain": "This library has a very interesting algorithm  for computing the curve point closest to a given point, seemingly based on a root-finder that doesn't need any complex numbers. Does anyone know of any resources about such an algorithm?",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44889517,
    "by": "nartho",
    "timeISO": "2025-08-13T15:12:51.000Z",
    "textPlain": "So this is a long shot but, as a software engineer lacking in the math department who has slowly been trying to improve calculus and geometry, what are some good resources/requirements to get to a point where I can implement something like that ?",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44888465,
    "by": "phkahler",
    "timeISO": "2025-08-13T13:52:07.000Z",
    "textPlain": "If they could extend it to rational Beziers it might be useful for CAD applications. We have a subset of these in C++ as the core of Solvespace. This is one of my favorite source files:https://github.com/solvespace/solvespace/blob/master/src/srf...",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44885119,
    "by": "pjmlp",
    "timeISO": "2025-08-13T06:10:17.000Z",
    "textPlain": "Great example, this is the kind of stuff that we could make use of interactive documents for, and not bend them into applications.",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44888217,
    "by": "graphviz",
    "timeISO": "2025-08-13T13:32:12.000Z",
    "textPlain": "Any ideas how these primitives could be used to implement an edge router for drawing natural-looking curves around obstacles in diagrams, as an improvement on the 25-year-old solver in graphviz https://dpd.cs.princeton.edu/Papers/DGKN97.pdf?",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44889077,
    "by": "viggity",
    "timeISO": "2025-08-13T14:40:37.000Z",
    "textPlain": "Anytime béziers are mentioned on HN, I feel compelled to share these absolutely incredible videos from Freya Holmérhttps://www.youtube.com/watch?v=jvPPXbo87ds (73 minutes)https://www.youtube.com/watch?v=aVwxzDHniEw (24 minutes)",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44884409,
    "by": "Syzygies",
    "timeISO": "2025-08-13T03:29:45.000Z",
    "textPlain": "I'm hoping to code Bezier animation in OCaml/F# in four dimensional space time, with a moving vantage point. Offload rendering each time slice frame to worker threads.I'm surprised Bezier-rs is all about curves. Sure, fonts, but I can't be alone here in seeing curves as a special case.It's easy as a pure mathematician to write off Bezier theory as \"specialized\" but it's simply the right way to work with polynomials on a simplex.",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44884695,
    "by": "continuational",
    "timeISO": "2025-08-13T04:40:28.000Z",
    "textPlain": "Very neat. I'm not sure if I missed it, but is there any way to get n equidistant points on the curve?E.g. for moving an object at constant speed along the curve.",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44890323,
    "by": "brcmthrowaway",
    "timeISO": "2025-08-13T16:10:24.000Z",
    "textPlain": "If only you could make a perfect circle out of bezier curves.. then P=NP",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44887852,
    "by": "childintime",
    "timeISO": "2025-08-13T12:54:38.000Z",
    "textPlain": "Bezier curves in painting software never gave me the results I wanted. And I mean never. I sincerely wonder who succeeds at using them?From these graphs I see that I always wanted the simple Quadratic version, and would use 2 of them in sequence to approximate a Cubic version. That would be so much easier. But if the software could allow me to adjust the midpoint, and maintain a smooth transition, that would be perfect. I think.So I basically wish for a different interface, one that has more thought put into it. Now it's a \"give access to the parameters, and be done with it\" kind. As if novices don't have the need for a nice smooth curve between known points.",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44884593,
    "by": "shmerl",
    "timeISO": "2025-08-13T04:15:13.000Z",
    "textPlain": "Is the documentation using the library itself for visualizations?",
    "parent": 44846781,
    "depth": 1
  },
  {
    "id": 44890646,
    "by": "meindnoch",
    "timeISO": "2025-08-13T16:36:20.000Z",
    "textPlain": "\"The boolean operations are implemented using a graph-based approach. After the parsing the input, self-intersecting cubic beziers curves are simplified. Then the intersection points between all edges are calculated. These are then turned into a graph representation where every intersection becomes a new vertex. We then apply edge contractions to remove vertices with a degree of 2 to compute the graph minor. At this stage, identical edges are deduplicated. Because we are ultimately interested in the faces of the graph to decide if they should be included in the final output, we then compute the dual graph in which the faces become vertices and vertices become the new faces. That dual structure is then used to determine which faces (dual vertices) should be included in the final output.\"This would be such a pain in the ass to implement with good precision and performance.",
    "parent": 44886800,
    "depth": 2
  },
  {
    "id": 44889857,
    "by": "stuaxo",
    "timeISO": "2025-08-13T15:36:09.000Z",
    "textPlain": "Oh, that's definitely interesting - would be good for creative coding.I could do with python bindings for this.",
    "parent": 44886800,
    "depth": 2
  },
  {
    "id": 44886917,
    "by": "QuantumNomad_",
    "timeISO": "2025-08-13T10:57:26.000Z",
    "textPlain": "Link to the code for the mentioned Rust path-bool crate:https://github.com/GraphiteEditor/Graphite/tree/master/libra...",
    "parent": 44886800,
    "depth": 2
  },
  {
    "id": 44891018,
    "by": "CyLith",
    "timeISO": "2025-08-13T17:04:40.000Z",
    "textPlain": "The library only solves up to cubic equations, and the comments have a link to the following page:\nhttps://momentsingraphics.de/CubicRoots.htmlFor general polynomials, it matters a great deal in what basis it is represented. The typical monomial basis is usually not the best from a numerical standpoint. I am aware of some modern methods such as this: https://arxiv.org/pdf/1611.02435For polynomials expressed in e.g. a Bernstein basis, there are often much faster and stable tailored methods working solving for the eigenvalues of a companion matrix of a different form.",
    "parent": 44890097,
    "depth": 2
  },
  {
    "id": 44889793,
    "by": "ajs1998",
    "timeISO": "2025-08-13T15:32:12.000Z",
    "textPlain": "Maybe not exactly what you're looking for, but this video is excellent. And her other video on Splines is also great.https://www.youtube.com/watch?v=aVwxzDHniEw",
    "parent": 44889517,
    "depth": 2
  },
  {
    "id": 44887797,
    "by": "ttd",
    "timeISO": "2025-08-13T12:47:30.000Z",
    "textPlain": "If you're not restricted to Bezier for graphics (it's a very common choice as the path primitive for vector graphics), there are other classes of curves that you may find are a better fit. In particular, I think animations typically feel better if they move at constant speed - which is nontrivial with Bezier curves because they do not have an exact closed-form arc length parameterization. Something like pythagorean hodographs could be a better fit for your application.I am not a mathematician though, so if you have other insight I'd be glad to hear it.",
    "parent": 44884409,
    "depth": 2
  },
  {
    "id": 44884728,
    "by": "jamwaffles",
    "timeISO": "2025-08-13T04:49:13.000Z",
    "textPlain": "There is indeed: Bezier::compute_lookup_table[1]. You'll want to use a `TValueType` of `Euclidean` to get equidistant points.[1]: https://docs.rs/bezier-rs/latest/bezier_rs/struct.Bezier.htm...",
    "parent": 44884695,
    "depth": 2
  },
  {
    "id": 44890548,
    "by": "Sharlin",
    "timeISO": "2025-08-13T16:27:15.000Z",
    "textPlain": "With rational Bézier curves you can!",
    "parent": 44890323,
    "depth": 2
  },
  {
    "id": 44887972,
    "by": "panzerboiler",
    "timeISO": "2025-08-13T13:07:38.000Z",
    "textPlain": "A Bézier curve is not an interpolating spline. It is a parametric curve defined by a set of control points, which the curve typically does not pass through (except the first and last points). Bézier curves exhibit local control (changing a control point influences only a portion of the curve, especially in piecewise Bézier constructions). Interpolating splines may seem more user-friendly at first, since the curve passes exactly through all the given points. However, this can lead to unintuitive behavior: modifying a single point can cause global changes in the curve, including in areas far from the edited point. In some cases, these changes can be drastic, making precise control difficult or impossible. I may be biased by my 20+ years of graphic design work, but I prefer the precision and control given by Bézier curves.",
    "parent": 44887852,
    "depth": 2
  },
  {
    "id": 44888231,
    "by": "WillAdams",
    "timeISO": "2025-08-13T13:33:32.000Z",
    "textPlain": "A markedly different UI is that of FutureWave SmartSketch which has been reimplemented inhttps://www.wickeditor.com/For Beziér curves remember the basics:- put nodes at extrema and points of inflection (extreme left/right, top/bottom, middle of _S_ curve)- rule of 30 --- off curve nodes should be ~30% away from the matching on curve node for smoothest appearance unless the shape one is trying to achieve dictates a different placement",
    "parent": 44887852,
    "depth": 2
  },
  {
    "id": 44888366,
    "by": "phkahler",
    "timeISO": "2025-08-13T13:43:36.000Z",
    "textPlain": "You might like the spline tool in Solvespace:https://solvespace.com/If you just do a start/end point it will create a cubic with 2 endpoints and 2 control points. But if you drop a whole series of points (up to 12 I think) it will create a curve that passes though all of them. This is done by internally creating a bunch of cubic splines where the control points are automatically positioned and not shown. You still get 2 control points for the derivatives at the ends, unless you create a closed loop.",
    "parent": 44887852,
    "depth": 2
  },
  {
    "id": 44885675,
    "by": "LoganDark",
    "timeISO": "2025-08-13T07:47:12.000Z",
    "textPlain": "Yep, WASM",
    "parent": 44884593,
    "depth": 2
  }
]
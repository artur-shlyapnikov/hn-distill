[
  {
    "id": 44901335,
    "by": "usrbinbash",
    "timeISO": "2025-08-14T15:10:06.000Z",
    "textPlain": "> We don't just keep adding more words to our context window, because it would drive us mad.That, and we also don't only focus on the textual description of a  problem when we encounter a problem. We don't see the debugger output and go \"how do I make this bad output go away?!?\". Oh, I am getting an authentication error. Well, meaybe I should just delete the token check for that code path...problem solved?!No. Problem very much not-solved. In fact, problem very much very bigger big problem now, and [Grug][1] find himself reaching for club again.Software engineers are able to step back, think about the whole thing, and determine the root cause of a problem. I am getting an auth error...ok, what happens when the token is verified...oh, look, the problem is not the authentication at all...in fact there is no error! The test was simply bad and tried to call a higher privilege function as a lower privilege user. So, test needs to be fixed. And also, even though it isn't per-se an error, the response for that function should maybe differentiate between \"401 because you didn't authenticate\" and \"401 because your privileges are too low\".[1]: https://grugbrain.dev",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901670,
    "by": "chollida1",
    "timeISO": "2025-08-14T15:33:51.000Z",
    "textPlain": "Most of this might be true for LLM's but years of investing experience has created a mental model of looking for the tech or company that sucks and yet keeps growing.People complained endlessly about the internet in the early to mid 90s, its slow, static, most sites had under construction signs on them, your phone modem would just randomly disconnect.  The internet did suck in alot of ways and yet people kept using it.Twitter sucked in the mid 2000s, we saw the fail whale weekly and yet people continued to use it for breaking news.Electric cars sucked, no charging, low distance, expensive and yet no matter how much people complain about them they kept getting better.Phones sucked, pre 3G was slow, there wasn't much you could use them for before app stores and the cameras were potato quality and yet people kept using them while they improved.Always look for the technology that sucks and yet people keep using it because it provides value.  LLM's aren't great at alot of tasks and yet no matter how much people complain about them, they keep getting used and keep improving through constant iteration.LLM\"s amy not be able to build software today, but they are 10x better than where they were in 2022 when we first started using chatgpt.  Its pretty reasonable to assume in 5 years they will be able to do these types of development tasks.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901548,
    "by": "JimDabell",
    "timeISO": "2025-08-14T15:25:56.000Z",
    "textPlain": "LLMs can’t build software because we are expecting them to hear a few sentences, then immediately start coding until there’s a prototype. When they get something wrong, they have a huge amount of spaghetti to wade through. There’s little to no opportunity to iterate at a higher level before writing code.If we put human engineering teams in the same situation, we’d expect them to do a terrible job, so why do we expect LLMs to do any better?We can dramatically improve the output of LLM software development by using all those processes and tools that help engineering teams avoid these problems:https://jim.dabell.name/articles/2025/08/08/autonomous-softw...",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901287,
    "by": "9cb14c1ec0",
    "timeISO": "2025-08-14T15:05:51.000Z",
    "textPlain": "> what they cannot do is maintain clear mental modelsThe more I use claude code, the more frustrated I get with this aspect.  I'm not sure that a generic text-based LLM can properly solve this.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901793,
    "by": "pjmlp",
    "timeISO": "2025-08-14T15:42:40.000Z",
    "textPlain": "Only because most AI startups are doing it wrong.I don't want a chat window.I want AI workflows as part of my IDE, like Visual Studio, InteliJ, Android Studio are finally going after.I want voice controlled actions on my native language.Knowledge across everything on the project for doing code refactorings, static analysis with AI feedback loop, generating UI based out of handwritten sketches, programming on the go using handwriting, source control commit messages out of code changes,...",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901371,
    "by": "emilecantin",
    "timeISO": "2025-08-14T15:13:38.000Z",
    "textPlain": "Yeah, I think it's pretty clear to a lot of people that LLMs aren't at the \"build me Facebook, but for dogs\" stage yet. I've had relatively good success with more targeted tasks, like \"Add a modal that does this, take this existing modal as an example for code style\". I also break my problem down into smaller chunks, and give them one by one to the LLM. It seems to work much better that way.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902015,
    "by": "1zael",
    "timeISO": "2025-08-14T15:59:02.000Z",
    "textPlain": "> \"when test fail, they are left guessing as to whether to fix the code or the tests\"I've one thing that helps is using the \"Red-Green-Refactor\" language. We're in RED phase - test should fail. We're in GREEN phase - make this test pass with minimal code. We're in REFACTOR phase - improve the code without breaking tests.This helps the LLM understand the TDD mental model rather than just seeing \"broken code\" that needs fixing.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901494,
    "by": "Transfinity",
    "timeISO": "2025-08-14T15:22:16.000Z",
    "textPlain": "> LLMs get endlessly confused: they assume the code they wrote actually works; when test fail, they are left guessing as to whether to fix the code or the tests; and when it gets frustrating, they just delete the whole lot and start over.I feel personally described by this statement. At least on a bad day, or if I'm phoning it in. Not sure if that says anything about AI - maybe just that the whole \"mental models\" part is quite hard.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902340,
    "by": "alliancedamages",
    "timeISO": "2025-08-14T16:21:45.000Z",
    "textPlain": "> ...but the distinguishing factor of effective engineers is their ability to build and maintain clear mental models.I wonder is this not just a proxy for intelligence?",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901488,
    "by": "generalizations",
    "timeISO": "2025-08-14T15:22:00.000Z",
    "textPlain": "These LLM discussions really need everyone to mention what LLM they're actually using.> AI is awesome for coding! [Opus 4]> No AI sucks for coding and it messed everything up! [4o]Would really clear the air. People seem to be evaluating the dumbest models (apparently because they don't know any better?) and then deciding the whole AI thing just doesn't work.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901636,
    "by": "lordnacho",
    "timeISO": "2025-08-14T15:31:35.000Z",
    "textPlain": "I think I agree with the idea that LLMs are good at the junior level stuff.What's happened for me recently is I've started to revisit the idea that typing speed doesn't matter.This is an age-old thing, most people don't think it really matters how fast you can type. I suppose the steelman is, most people think it doesn't really matters how fast you can get the edits to your code that you want. With modern tools, you're not typing out all the code anyway, and there's all sorts of non-AI ways to get your code looking the way you want. And that doesn't matter, the real work of the engineer is the architecture of how the whole program functions. Typing things faster doesn't make you get to the goal faster, since finding the overall design is the limiting thing.But I've been using Claude for a while now, and I'm starting to see the real benefit: you no longer need to concentrate to rework the code.It used to be burdensome to do certain things. For instance, I decided to add an enum value, and now I have to address all the places where it matches on that enum. This wasn't intellectually hard in the old world, you just got the compiler to tell you where the problems were, and you added a little section for your new value to do whatever it needed, in all the places it appeared.But you had to do this carefully, otherwise you would just cause more compile/error cycles. Little things like forgetting a semicolon will eat a cycle, and old tools would just tell you the error was there, not fix it for you.LLMs fix it for you. Now you can just tell Claude to change all the code in a loop until it compiles. You can have multiple agents working on your code, fixing little things in many places, while you sit on HN and muse about it. Or perhaps spend the time considering what direction the code needs to go.The big thing however is that when you're no longer held up by little compile errors, you can do more things. I had a whole laundry list of things I wanted to change about my codeba",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902166,
    "by": "nowittyusername",
    "timeISO": "2025-08-14T16:09:47.000Z",
    "textPlain": "Saying LLMS are not good at x or y, is akin to saying a brain is useless without a body. Which is obvious.  The success of agentic coding solutions depends on not just the model but also the system that the developers built around the model. And the companies that will succeed in this area are going to be the companies that focus on building sophisticated and capable systems that utilize said models. We are still in very early days where most organizations are only coming to terms with this realization... Only a few of them fully utilize this concept to the fullest, Claude code being the best example. The Claude models are specifically trained for tool calling and other capabilities and the Claude code cli compliments and takes advantage of those capabilities to the fullest, things like context management among other capabilities are extremely important  ...",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902093,
    "by": "ontigola",
    "timeISO": "2025-08-14T16:03:54.000Z",
    "textPlain": "Great, concise article. Nothing important to add, except that AI snake-oil salesmen will continue spreading their exaggerations far and wide, at least we who are truly in this business agree on the facts.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901861,
    "by": "Onewildgamer",
    "timeISO": "2025-08-14T15:48:06.000Z",
    "textPlain": "I wonder if some of this can be solved by removing some wrongly setup context in LLM. Or get a short summary, restructure it and againt feed to a fresh LLM context.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901331,
    "by": "empath75",
    "timeISO": "2025-08-14T15:09:26.000Z",
    "textPlain": "It's good at micro, but not macro.  I think that will eventually change with smarter engineering around it, larger context windows, etc.  Never underestimate how much code that engineers will write to avoid writing code.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901455,
    "by": "saghm",
    "timeISO": "2025-08-14T15:19:54.000Z",
    "textPlain": ">   Context omission: Models are bad at finding omitted context.>   Recency bias: They suffer a strong recency bias in the context window.>   Hallucination: They commonly hallucinate details that should not be there.To be fair, those are all issues that most human engineers I've worked with (including myself!) have struggled with to various degrees, even if we don't refer to them the same way. I don't know about the rest of you, but I've certainly had times where I found out that an important nuance of a design was overlooked until well into the process of developing something, forgotten a crucial detail that I learned months ago that would have helped me debug something much faster than if I had remembered it from the start, or accidentally make an assumption about how something worked (or misremembered it) and ended up with buggy code as a result. I've mostly gotten pretty positive feedback about my work over the course of my career, so if I \"can't build software\", I have to worry about the companies that have been employing me and my coworkers who have praised my work output over the years. Then again, I think \"humans can't build software reliably\" is probably a mostly correct statement, so maybe the lesson here is that software is hard in general.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901780,
    "by": "sneak",
    "timeISO": "2025-08-14T15:42:23.000Z",
    "textPlain": "Am I the only one continuously astounded at how well Opus 4 actually does build mental models when prompted correctly?I find Sonnet frequently loses the plot, but Opus can usually handle it (with sufficient clarity in prompting).",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901406,
    "by": "trod1234",
    "timeISO": "2025-08-14T15:16:12.000Z",
    "textPlain": "I think most people trying to touch on this topic don't consider this byline with other similar bylines like, \"Why LLMs can't recognize themselves looping\", or \"Why LLMs can't express intent\", or \"Why LLMs can't recognize truth/falsity, or confidence levels of what they know vs don't know\", these other bylines basically with a little thought equate to Computer Science halting problems, or  the undecidability nature of mathematics.Taken to a next step, recognizing this makes the investment in such a moonshot pipedream (overcoming these inherent problems in a deterministic way), recklessly negligent.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901701,
    "by": "antihipocrat",
    "timeISO": "2025-08-14T15:35:43.000Z",
    "textPlain": "...\"(at least for now) you are in the drivers seat, and the LLM is just another tool to reach for.\"Improvements in model performance seem to be approaching the peak rather than demonstrating exponential gains. Is the quote above where we land in the end?",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901637,
    "by": "revskill",
    "timeISO": "2025-08-14T15:31:39.000Z",
    "textPlain": "They can read and mind the error then figure out the best way to resolve. It is the best part about llm. No human can do it better than an llm. But they are not your mind reader. It is where things fall apart.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901481,
    "by": "Nickersf",
    "timeISO": "2025-08-14T15:21:22.000Z",
    "textPlain": "I think they're another tool in the toolbox not a new workshop. You have to build a good strategy around LLM usage when developing software. I think people are naturally noticing that and adapting.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901854,
    "by": "codr7",
    "timeISO": "2025-08-14T15:47:48.000Z",
    "textPlain": "Well, welcome to the club of awareness :)",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901360,
    "by": "jmclnx",
    "timeISO": "2025-08-14T15:12:42.000Z",
    "textPlain": "I am not a fan of today's concept of \"AI\", but to be fair, building today's software is not for the faint of heart,  very few people gets it right on try 1.Years ago I gave up compiling these large applications all together.  I compiled Firefox via FreeBSD's (v8.x) ports system, that alone was a nightmare.I cannot imagine what it would be like to compile GNOME3 or KDE or Libreoffice.  Emacs is the largest thing I compile now.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901910,
    "by": "jeffWrld",
    "timeISO": "2025-08-14T15:51:52.000Z",
    "textPlain": "[dead]",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901868,
    "by": "Xplan",
    "timeISO": "2025-08-14T15:48:39.000Z",
    "textPlain": "[dead]",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901477,
    "by": "myfavoritedog",
    "timeISO": "2025-08-14T15:21:03.000Z",
    "textPlain": "[dead]",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902078,
    "by": "mccoyb",
    "timeISO": "2025-08-14T16:02:21.000Z",
    "textPlain": "This is a low information density blog post. I’ve really liked Zed’s blog posts in the past (especially about the editor internals!) so I hope this doesn’t come the wrong way, but this seems to be a loose restatement of what many people are empirically finding out by using LLM agents.Perhaps good for someone just getting their feet wet with these computational objects, but not resolving or explaining things in a clear way, or highlighting trends in research and engineering that might point towards ways forward.You also have a technical writing no no where you cite a rather precise and specific study with a paraphrase to support your claims … analogous to saying “Godel’s incompleteness theorem means _something something_ about the nature of consciousness”.A phrase like: “Unfortunately, for now, they cannot (beyond a certain complexity) actually understand what is going on” referencing a precise study … is ambiguous and shoddy technical writing — what exactly does the author mean here? It’s vague.I think it is even worse here because _the original study_ provides task-specific notions of complexity (a critique of the original study! Won’t different representations lead to different complexity scaling behavior? Of course! That’s what software engineering is all about: I need to think at different levels to control my exposure to complexity)",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901575,
    "by": "skydhash",
    "timeISO": "2025-08-14T15:27:40.000Z",
    "textPlain": "Programmers are mostly translating business rules to the very formal process execution of the computer world. And you need to both knows what the rules means and how the computer works (or at least how the abstracted version you’re working with works). The translation is messy at first, which is why you need to revise it again and again. Especially when later rules comes challenging all the assumptions you’ve made or even contradicting themselves.Even translations between human languages (which allows for ambiguity) can be messy. Imagine if the target language is for a system that will exactly do as told unless someone has qualified those actions as bad.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44902070,
    "by": "ai-christianson",
    "timeISO": "2025-08-14T16:01:37.000Z",
    "textPlain": "I take a more pragmatic approach --everything is human in the loop. It helps me get the job done faster and with higher quality, so I use it.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44902313,
    "by": "appease7727",
    "timeISO": "2025-08-14T16:19:30.000Z",
    "textPlain": "The way it works for me at least is I can fit a huge amount of context in my head. This works because the text is utterly irrelevant and gets discarded immediately.Instead, my brain parses code into something like an AST which then is represented as a spatial graph. I model the program as a logical structure instead of a textual one. When you look past the language, you can work on the program. The two are utterly disjoint.I think LLMs fail at software because they're focused on text and can't build a mental model of the program logic. It take a huge amount of effort and brainpower to truly architect something and understand large swathes of the system. LLMs just don't have that type of abstract reasoning.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44901997,
    "by": "reactordev",
    "timeISO": "2025-08-14T15:57:38.000Z",
    "textPlain": "While I agree with you - The whole grug brain thing is offensive. Because we have all been grug at some point.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44901533,
    "by": "livid-neuro",
    "timeISO": "2025-08-14T15:25:05.000Z",
    "textPlain": "The first cars broke down all the time. They had a limited range. There wasn't a vast supply of parts for them. There wasn't a vast industry of experts who could work on them. There wasn't a vast network of fuel stations to provide energy for them. The horse was a proven method.What an LLM cannot do today is almost irrelevant in the tide of change upon the industry. The fact is, with improvements, it doesn't mean an LLM cannot do it tomorrow.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44901736,
    "by": "chuckadams",
    "timeISO": "2025-08-14T15:38:04.000Z",
    "textPlain": "An AI might tell you to use a 403 for insufficient privileges instead of 401.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44901530,
    "by": "trod1234",
    "timeISO": "2025-08-14T15:25:03.000Z",
    "textPlain": "Isn't the 401 for LLMs the same single undecidable token? \nDoesn't this basically go to the undecidable nature of math in CS?Put another way, you have an excel roster corresponding to people with accounts where some need to have their account shutdown but you only have their first and last names as identifiers, and the pool is sufficiently large that there are more than one person per a given set of names.You can't shut down all accounts with a given name, and there is no unique identifier. How do you solve this?You have to ask and be given that unique identifier that differentiates between the undecidable. Without that, even the person can't do the task.The person can make guesses, but those guesses are just hallucinations with a significant n probability towards a bad repeat outcome.At a core level I don't think these type of issues are going to be solved. Quite a lot of people would be unable to solve this and struggle with this example (when not given the answer, or hinted at the solution in the framing of the task; ie when they just have a list of names and are told to do an impossible task).",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44901757,
    "by": "throwaway1004",
    "timeISO": "2025-08-14T15:39:58.000Z",
    "textPlain": "That reference link is a wild ride of unqualified, cartoonish passive-aggression, the cute link to the author's \"swag\" is the icing on the cake.Concidentally, I encountered the author's work for the first time only a couple of days ago as a podcast guest, he vouches for the \"Dirty Code\" approach while straw-manning Uncle Bob's general principles of balancing terseness/efficiency with ergonomics and readability (in most, but not all, cases).I guess this stuff sells t-shirts and mugs /rant",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44902039,
    "by": "freehorse",
    "timeISO": "2025-08-14T16:00:00.000Z",
    "textPlain": "At the same time, there have been expectations about many of these that did not meet reality at any point. Much of this is due to physical limitations that are not trivial to be overcome. Internet gets faster and more stable, but the metaverse taking over did not happen partially because many people still get nausea after a bit and no 10x scaling fixed that.A lot of what you described as \"sucked\" were not seen as \"sucking\" at the time. Nobody complained about the phones being slow because nobody expected to use phones the way we do today. The internet was slow and less stable but nobody complained because they expected to stream 4k movies and they could not. This is anachronistic.The fact that we can see how some things improved in X Y manner does not mean that LLMs will improve the way you think they will. Maybe we invent a different technology that does a better job. After it was not that dial up itself became faster and I don't think there were fanatics saying that dialup technology would give us 1Gbp speeds. The problem with AI is that because scaling up compute has provided breakthroughs, some think that somehow with scaling up compute and some technical tricks we can solve all the current problems. I don't think that anybody can say that we cannot invent a technology that can overcome these, but if LLMs is this technology that can just keep scaling has been under doubt. Last year or so there has been a lot of refinement and broadening of applications, but nothing like a breakthrough.",
    "parent": 44901670,
    "depth": 2
  },
  {
    "id": 44902439,
    "by": "mbesto",
    "timeISO": "2025-08-14T16:29:45.000Z",
    "textPlain": "We also thought 3D printing would print us a car, but alas.FWIW - 3d printing has come a far way, and I personally have a 3D printer. But the idea that it was going to completely disrupt manufacturing is simply not true. There are known limitations (how the heck are you going to get a wood polymer squeezed through a metal tip?) and those limitations are physics, not technical ones.",
    "parent": 44901670,
    "depth": 2
  },
  {
    "id": 44902043,
    "by": "runako",
    "timeISO": "2025-08-14T16:00:14.000Z",
    "textPlain": "> Phones sucked, pre 3G was slow, there wasn't much you could use them for before app stores and the cameras were potato qualityThis is a big rewrite of history. Phones took off because before mobile phones the only way to reach a person was to call when they were at home or their office. People were unreachable for timespans that now seem quaint. Texting brought this into async. The \"potato\" cameras were the advent of people always having a camera with them.People using the Nokia 3210 were very much not anticipating when their phones would get good, they were already a killer app. That they improved was icing on the cake.",
    "parent": 44901670,
    "depth": 2
  },
  {
    "id": 44902425,
    "by": "isoprophlex",
    "timeISO": "2025-08-14T16:28:54.000Z",
    "textPlain": "Now think about hoverboards, self-cleaning shirts, moon bases, flying cars, functioning democracies, whatever VR tech is described in snow crash as well. Where on the spectrum will  LLMs fall?",
    "parent": 44901670,
    "depth": 2
  },
  {
    "id": 44901994,
    "by": "bunderbunder",
    "timeISO": "2025-08-14T15:57:18.000Z",
    "textPlain": "This is such selective hindsight, though. We remember the small minority of products that persisted and got better. We don't remember the majority of ones that fizzled out after the novelty wore off, or that ultimately plateaued.Me, I agree with the author of the article. It's possible that the technology will eventually get there, but it doesn't seem to be there now. And I prefer to make decisions based on present-day reality instead of just assuming that the future I want is the future I'll get.",
    "parent": 44901670,
    "depth": 2
  },
  {
    "id": 44902037,
    "by": "overgard",
    "timeISO": "2025-08-14T15:59:47.000Z",
    "textPlain": "I'm not a fan of the argument that LLMs have gotten X times better in the past few years, so thusly they will continue to get X times better in the next few years. From what I can see, all the growth has mostly come from optimizing a few techniques, but I'm not convinced that we aren't going to get stuck in a local maxima (actually, I think that's the most likely outcome).Specifically, to me the limitation of LLMs is discovering new knowledge and being able to reason about information they haven't seen before. LLMs still fail at things like counting the number of b's in the word blueberry or not getting distracted by inserting random cat facts in word problems (both issues I've seen appear in the last month)I don't mean that to say they're a useless tool, I'm just not into the breathless hype.",
    "parent": 44901670,
    "depth": 2
  },
  {
    "id": 44901759,
    "by": "ausbah",
    "timeISO": "2025-08-14T15:40:12.000Z",
    "textPlain": "those are really good points, but LLMs have really started to plateau off on their capabilities haven’t they? the improvements from gpt2 class models to 3 was much bigger then 3 to 4, which was only somewhat bigger than 4 to 5most of the vibe shift I think I’ve seen in the past few months to using LLMs in the context of coding has been improvements in dataset curation and ux, not fundamentally better tech",
    "parent": 44901670,
    "depth": 2
  },
  {
    "id": 44902386,
    "by": "4b11b4",
    "timeISO": "2025-08-14T16:25:31.000Z",
    "textPlain": "\"it's pretty reasonable\".. big jump?",
    "parent": 44901670,
    "depth": 2
  },
  {
    "id": 44901938,
    "by": "diwank",
    "timeISO": "2025-08-14T15:53:34.000Z",
    "textPlain": "yup. I started a fully autonomous, 100% vibe coded side project called steadytext, mostly expecting it to hit a wall, with LLMs eventually struggling to maintain or fix any non-trivial bug in it. turns out I was wrong, not only has claude opus been able to write up a pretty complex 7k LoC project with a python library, a CLI, _and_ a postgres extension. It actively maintains it and is able to fix filed issues and feature requests entirely on its own. It is completely vibe coded, I have never even looked at 90% of the code in that repo. it has full test coverage, passes CI, and we use it in production!granted- it needs careful planning for CLAUDE.md and all issues and feature requests need a lot of in-depth specifics but it all works. so I am not 100% convinced by this piece. I'd say it's def not easy to get coding agents to be able to manage and write software effectively and specially hard to do so in existing projects but my experience has been across that entire spectrum. I have been sorely disappointed in coding agents and even abandoned a bunch or projects and dozens of pull requests but I have also seen them work.you can check out that project here: https://github.com/julep-ai/steadytext/",
    "parent": 44901548,
    "depth": 2
  },
  {
    "id": 44901526,
    "by": "dlivingston",
    "timeISO": "2025-08-14T15:24:43.000Z",
    "textPlain": "Reminds me of how Google's Genie 3 can only run for a ~minute before losing its internal state [0].My gut feeling is that this problem won't be solved until some new architecture is invented, on the scale of the transformer, which allows for short-term context, long-term context, and self-modulation of model weights (to mimic \"learning\"). (Disclaimer: hobbyist with no formal training in machine learning.)[0]: https://news.ycombinator.com/item?id=44798166",
    "parent": 44901287,
    "depth": 2
  },
  {
    "id": 44901704,
    "by": "elephanlemon",
    "timeISO": "2025-08-14T15:35:48.000Z",
    "textPlain": "I’ve been thinking about this recently… maybe a more workable solution at the moment is to run a hierarchy of agents, with the top level one maintaining the general mental model (and not filling its context with anything much more than “next agent down said this task was complete”). Definitely seems like anytime you try to have one Code agent run everything it just goes off the rails sooner or later, ignoring important details from your original instructions, failing to make sure it’s adhering to CLAUDE.md, etc. I think you can do this now with Code’s agent feature? Anyone have strategies to share?",
    "parent": 44901287,
    "depth": 2
  },
  {
    "id": 44902062,
    "by": "SoftTalker",
    "timeISO": "2025-08-14T16:01:16.000Z",
    "textPlain": "Is this really that diffferent from the \"average\" programmer, especially a more junior one?> LLMs get endlessly confused: they assume the code they wrote actually works; when test fail, they are left guessing as to whether to fix the code or the tests; and when it gets frustrating, they just delete the whole lot and start over.I see this constantly with mediocre developers. Flailing, trying different things, copy-pasting from StackOverflow without understanding, ultimately deciding the compiler must have a bug, or cosmic rays are flipping bits.",
    "parent": 44901287,
    "depth": 2
  },
  {
    "id": 44901724,
    "by": "edaemon",
    "timeISO": "2025-08-14T15:37:11.000Z",
    "textPlain": "Same here. I have used this tool which helps a bit: https://github.com/rizethereum/claude-code-requirements-buil...That and other tricks have only made me slightly less frustrated, though.",
    "parent": 44901287,
    "depth": 2
  },
  {
    "id": 44901468,
    "by": "cmrdporcupine",
    "timeISO": "2025-08-14T15:20:40.000Z",
    "textPlain": "Honestly it forces you -- rightfully -- to step back and be the one doing the planning.You can let it do the grunt coding, and a lot of the low level analysis and testing, but you absolutely need to be the one in charge on the design.It frankly gives me more time to think about the bigger picture within the amount of time I have to work on a task, and I like that side of things.There's definitely room for a massive amount of improvement in how the tool presents changes and suggestions to the user. It needs to be far more interactive.",
    "parent": 44901287,
    "depth": 2
  },
  {
    "id": 44901795,
    "by": "taormina",
    "timeISO": "2025-08-14T15:43:05.000Z",
    "textPlain": "I've used a wide variety of the \"best\" models, and I've mostly settled on Opus 4 and Sonnet 4 with Claude Code, but they don't ever actually get better. Grok 3-4 and GPT4 were worse, but like, at a certain point you don't get brownie points for not tripping over how low the bar is set.",
    "parent": 44901488,
    "depth": 2
  }
]
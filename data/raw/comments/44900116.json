[
  {
    "id": 44908874,
    "by": "lisbbb",
    "timeISO": "2025-08-15T05:22:44.000Z",
    "textPlain": "Back around, I don't even know, 2013?  A colleague and I were working on updating a system that scanned in letters with mail order forms.  The workers would lay the items from the envelopes in order on a conveyor type scanner.  They had to lay them down in order:  order form, payment check, envelope.  The system would scan each document and add two blank fake scanned pages after each envelope.  The company that set it up billed by scanned page.  We figured out that you didn't need the blank pages as a delimiter because the envelope could reliably serve as that.  By the way, the OCR was so bad that they never got the order forms to scan automatically, but people had to examine the order form as a pdf doc and key in everything instead.  By eliminating the fake, nonsensical blank scanned pages, we saved the company over $1M/year in costs.  We never got a single accolade or pat on the back or anything for that.  Can AI do that, though?",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901335,
    "by": "usrbinbash",
    "timeISO": "2025-08-14T15:10:06.000Z",
    "textPlain": "> We don't just keep adding more words to our context window, because it would drive us mad.That, and we also don't only focus on the textual description of a  problem when we encounter a problem. We don't see the debugger output and go \"how do I make this bad output go away?!?\". Oh, I am getting an authentication error. Well, meaybe I should just delete the token check for that code path...problem solved?!No. Problem very much not-solved. In fact, problem very much very bigger big problem now, and [Grug][1] find himself reaching for club again.Software engineers are able to step back, think about the whole thing, and determine the root cause of a problem. I am getting an auth error...ok, what happens when the token is verified...oh, look, the problem is not the authentication at all...in fact there is no error! The test was simply bad and tried to call a higher privilege function as a lower privilege user. So, test needs to be fixed. And also, even though it isn't per-se an error, the response for that function should maybe differentiate between \"401 because you didn't authenticate\" and \"401 because your privileges are too low\".[1]: https://grugbrain.dev",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902590,
    "by": "andrewmutz",
    "timeISO": "2025-08-14T16:41:32.000Z",
    "textPlain": "The author does not understand what LLMs and coding tools are capable of today.> LLMs get endlessly confused: they assume the code they wrote actually works; when test fail, they are left guessing as to whether to fix the code or the tests; and when it gets frustrating, they just delete the whole lot and start over.  This is exactly the opposite of what I am looking for.  Software engineers test their work as they go. When tests fail, they can check in with their mental model to decide whether to fix the code or the tests, or just to gather more data before making a decision. When they get frustrated, they can reach for help by talking things through. And although sometimes they do delete it all and start over, they do so with a clearer understanding of the problem.My experiences are based on using Cline with Anthropic Sonnet 3.7 doing TDD on Rails, and have a very different experience.  I instruct the model to write tests before any code and it does.  It works in small enough chunks that I can review each one.  When tests fail, it tends to reason very well about why and fixes the appropriate place.  It is very common for the LLM to consult more code as it goes to learn more.It's certainly not perfect but it works about as well, if not better, than a human junior engineer.  Sometimes it can't solve a bug, but human junior engineers get in the same situation too.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44908856,
    "by": "madrasman",
    "timeISO": "2025-08-15T05:19:02.000Z",
    "textPlain": "The 2 iOS apps that I published (mid level complexity and work well) say otherwise. I was blown away by what cursor + o3 could do.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901670,
    "by": "chollida1",
    "timeISO": "2025-08-14T15:33:51.000Z",
    "textPlain": "Most of this might be true for LLM's but years of investing experience has created a mental model of looking for the tech or company that sucks and yet keeps growing.People complained endlessly about the internet in the early to mid 90s, its slow, static, most sites had under construction signs on them, your phone modem would just randomly disconnect.  The internet did suck in alot of ways and yet people kept using it.Twitter sucked in the mid 2000s, we saw the fail whale weekly and yet people continued to use it for breaking news.Electric cars sucked, no charging, low distance, expensive and yet no matter how much people complain about them they kept getting better.Phones sucked, pre 3G was slow, there wasn't much you could use them for before app stores and the cameras were potato quality and yet people kept using them while they improved.Always look for the technology that sucks and yet people keep using it because it provides value.  LLM's aren't great at alot of tasks and yet no matter how much people complain about them, they keep getting used and keep improving through constant iteration.LLM\"s amy not be able to build software today, but they are 10x better than where they were in 2022 when we first started using chatgpt.  Its pretty reasonable to assume in 5 years they will be able to do these types of development tasks.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901548,
    "by": "JimDabell",
    "timeISO": "2025-08-14T15:25:56.000Z",
    "textPlain": "LLMs can’t build software because we are expecting them to hear a few sentences, then immediately start coding until there’s a prototype. When they get something wrong, they have a huge amount of spaghetti to wade through. There’s little to no opportunity to iterate at a higher level before writing code.If we put human engineering teams in the same situation, we’d expect them to do a terrible job, so why do we expect LLMs to do any better?We can dramatically improve the output of LLM software development by using all those processes and tools that help engineering teams avoid these problems:https://jim.dabell.name/articles/2025/08/08/autonomous-softw...",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901287,
    "by": "9cb14c1ec0",
    "timeISO": "2025-08-14T15:05:51.000Z",
    "textPlain": "> what they cannot do is maintain clear mental modelsThe more I use claude code, the more frustrated I get with this aspect.  I'm not sure that a generic text-based LLM can properly solve this.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901636,
    "by": "lordnacho",
    "timeISO": "2025-08-14T15:31:35.000Z",
    "textPlain": "I think I agree with the idea that LLMs are good at the junior level stuff.What's happened for me recently is I've started to revisit the idea that typing speed doesn't matter.This is an age-old thing, most people don't think it really matters how fast you can type. I suppose the steelman is, most people think it doesn't really matters how fast you can get the edits to your code that you want. With modern tools, you're not typing out all the code anyway, and there's all sorts of non-AI ways to get your code looking the way you want. And that doesn't matter, the real work of the engineer is the architecture of how the whole program functions. Typing things faster doesn't make you get to the goal faster, since finding the overall design is the limiting thing.But I've been using Claude for a while now, and I'm starting to see the real benefit: you no longer need to concentrate to rework the code.It used to be burdensome to do certain things. For instance, I decided to add an enum value, and now I have to address all the places where it matches on that enum. This wasn't intellectually hard in the old world, you just got the compiler to tell you where the problems were, and you added a little section for your new value to do whatever it needed, in all the places it appeared.But you had to do this carefully, otherwise you would just cause more compile/error cycles. Little things like forgetting a semicolon will eat a cycle, and old tools would just tell you the error was there, not fix it for you.LLMs fix it for you. Now you can just tell Claude to change all the code in a loop until it compiles. You can have multiple agents working on your code, fixing little things in many places, while you sit on HN and muse about it. Or perhaps spend the time considering what direction the code needs to go.The big thing however is that when you're no longer held up by little compile errors, you can do more things. I had a whole laundry list of things I wanted to change about my codeba",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901371,
    "by": "emilecantin",
    "timeISO": "2025-08-14T15:13:38.000Z",
    "textPlain": "Yeah, I think it's pretty clear to a lot of people that LLMs aren't at the \"build me Facebook, but for dogs\" stage yet. I've had relatively good success with more targeted tasks, like \"Add a modal that does this, take this existing modal as an example for code style\". I also break my problem down into smaller chunks, and give them one by one to the LLM. It seems to work much better that way.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901488,
    "by": "generalizations",
    "timeISO": "2025-08-14T15:22:00.000Z",
    "textPlain": "These LLM discussions really need everyone to mention what LLM they're actually using.> AI is awesome for coding! [Opus 4]> No AI sucks for coding and it messed everything up! [4o]Would really clear the air. People seem to be evaluating the dumbest models (apparently because they don't know any better?) and then deciding the whole AI thing just doesn't work.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902015,
    "by": "1zael",
    "timeISO": "2025-08-14T15:59:02.000Z",
    "textPlain": "> \"when test fail, they are left guessing as to whether to fix the code or the tests\"I've one thing that helps is using the \"Red-Green-Refactor\" language. We're in RED phase - test should fail. We're in GREEN phase - make this test pass with minimal code. We're in REFACTOR phase - improve the code without breaking tests.This helps the LLM understand the TDD mental model rather than just seeing \"broken code\" that needs fixing.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901793,
    "by": "pjmlp",
    "timeISO": "2025-08-14T15:42:40.000Z",
    "textPlain": "Only because most AI startups are doing it wrong.I don't want a chat window.I want AI workflows as part of my IDE, like Visual Studio, InteliJ, Android Studio are finally going after.I want voice controlled actions on my native language.Knowledge across everything on the project for doing code refactorings, static analysis with AI feedback loop, generating UI based out of handwritten sketches, programming on the go using handwriting, source control commit messages out of code changes,...",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44905259,
    "by": "mikewarot",
    "timeISO": "2025-08-14T20:26:37.000Z",
    "textPlain": "3 months ago, I would have agreed with much of this article, however...In the past week, I watched this video[1] from Welch Labs about how deep networks work, and it inspired an idea. I spent some time \"vibe coding\" with Visual Studio Code's ChatGPT5 preview and had it generate a python framework that can take an image, and teach a small network how to generate that one sample image.The network was simple... 2 inputs (x,y), 3 outputs (r,g,b), and a number of hidden layers with a specified number of nodes per layer.It's an agent, it writes code, tests it, fixes problems, and it pretty much just works. As I explored the space of image generation, I had it add options over time, and it all just worked. Unlike previous efforts, I didn't have to copy/paste error messages in and try to figure out how things broke. I was pleasantly surprised that the code just worked in a manner close to what I wanted.The only real problem I had was getting .venv working right, and that's more of an install issue rather then the LLMs fault.I've got to say, I'm quite impressed with Python's argparse library.It's amazing how much detail you can get out of a 4 hidden layers of 64 values, and 3 output channels (rgb), if you're willing to through a few days of CPU time at it.  My goal is to see just how small of a network I can make to generate my favorite photo.As it iterates through checkpoints, I have it output an image with the current values, to compare against the original, it's quite fascinating to watch as it folds the latent space to capture major features of the photo, then folds some more to catch smaller details, over and over, as the signal to noise ratio very slowly increases over the hours.As for ChatGPT5, maybe I just haven't run out of context window yet, but for now, it all just seems like magic.[1] https://www.youtube.com/watch?v=qx7hirqgfuU",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901494,
    "by": "Transfinity",
    "timeISO": "2025-08-14T15:22:16.000Z",
    "textPlain": "> LLMs get endlessly confused: they assume the code they wrote actually works; when test fail, they are left guessing as to whether to fix the code or the tests; and when it gets frustrating, they just delete the whole lot and start over.I feel personally described by this statement. At least on a bad day, or if I'm phoning it in. Not sure if that says anything about AI - maybe just that the whole \"mental models\" part is quite hard.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902823,
    "by": "guluarte",
    "timeISO": "2025-08-14T16:58:37.000Z",
    "textPlain": "Turns out, English is pretty bad for creating deterministic software. If you are vibe coding, you either are happy with the randomness generated by the LLMs or you enter a loop to try to generate a deterministic output, in which case using a programming language could have been easier.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44907101,
    "by": "crabmusket",
    "timeISO": "2025-08-14T23:53:41.000Z",
    "textPlain": "The 4 step process outlined at the start of this article really reminds me of Deutsch's The Beginning of Infinity:> The real source of our theories is conjecture, and the real source of our knowledge is conjecture alternating with criticism.(This is rephrased Karl Popper, and Popper cites an intellectual lineage beginning somewhere around Parmenides.)I see writing tests as a criticism of the code you wrote, which itself was a conjecture. Both are attempting to approach an explanation in your mind, some platonic idea that you think you are putting on paper. The code is an attempt to do so, the test is criticism from a different direction that you have done so.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902967,
    "by": "lysecret",
    "timeISO": "2025-08-14T17:09:35.000Z",
    "textPlain": "Bit of a click baity title since thy can definitely help in building software.However, I agree with the main thesis (that they can’t do it on their own). Also related to this this whole idea of “we will easily fix memory next” will turn out to be the same as “we can fix vision in one summer” turned out it’s 30 years later, much improved but still not fixed. Memory is hard.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902166,
    "by": "nowittyusername",
    "timeISO": "2025-08-14T16:09:47.000Z",
    "textPlain": "Saying LLMS are not good at x or y, is akin to saying a brain is useless without a body. Which is obvious.  The success of agentic coding solutions depends on not just the model but also the system that the developers built around the model. And the companies that will succeed in this area are going to be the companies that focus on building sophisticated and capable systems that utilize said models. We are still in very early days where most organizations are only coming to terms with this realization... Only a few of them fully utilize this concept to the fullest, Claude code being the best example. The Claude models are specifically trained for tool calling and other capabilities and the Claude code cli compliments and takes advantage of those capabilities to the fullest, things like context management among other capabilities are extremely important  ...",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902556,
    "by": "nextworddev",
    "timeISO": "2025-08-14T16:39:24.000Z",
    "textPlain": "60% of the complaints in this post can be solved by providing better requirements and context upfront",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902794,
    "by": "anotheryou",
    "timeISO": "2025-08-14T16:56:00.000Z",
    "textPlain": "Maybe we should let it build a mental model in documentation markdown files?Vibing I often let it explain the implemented business logic (instead of reading the code directly) and judge that.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901861,
    "by": "Onewildgamer",
    "timeISO": "2025-08-14T15:48:06.000Z",
    "textPlain": "I wonder if some of this can be solved by removing some wrongly setup context in LLM. Or get a short summary, restructure it and againt feed to a fresh LLM context.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902340,
    "by": "alliancedamages",
    "timeISO": "2025-08-14T16:21:45.000Z",
    "textPlain": "> ...but the distinguishing factor of effective engineers is their ability to build and maintain clear mental models.I wonder is this not just a proxy for intelligence?",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901455,
    "by": "saghm",
    "timeISO": "2025-08-14T15:19:54.000Z",
    "textPlain": ">   Context omission: Models are bad at finding omitted context.>   Recency bias: They suffer a strong recency bias in the context window.>   Hallucination: They commonly hallucinate details that should not be there.To be fair, those are all issues that most human engineers I've worked with (including myself!) have struggled with to various degrees, even if we don't refer to them the same way. I don't know about the rest of you, but I've certainly had times where I found out that an important nuance of a design was overlooked until well into the process of developing something, forgotten a crucial detail that I learned months ago that would have helped me debug something much faster than if I had remembered it from the start, or accidentally make an assumption about how something worked (or misremembered it) and ended up with buggy code as a result. I've mostly gotten pretty positive feedback about my work over the course of my career, so if I \"can't build software\", I have to worry about the companies that have been employing me and my coworkers who have praised my work output over the years. Then again, I think \"humans can't build software reliably\" is probably a mostly correct statement, so maybe the lesson here is that software is hard in general.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44903744,
    "by": "VladTepes2025",
    "timeISO": "2025-08-14T18:13:46.000Z",
    "textPlain": "Have faith in AI, one day it will do what we hallucinate it can do!",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901331,
    "by": "empath75",
    "timeISO": "2025-08-14T15:09:26.000Z",
    "textPlain": "It's good at micro, but not macro.  I think that will eventually change with smarter engineering around it, larger context windows, etc.  Never underestimate how much code that engineers will write to avoid writing code.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44903682,
    "by": "shad42",
    "timeISO": "2025-08-14T18:08:11.000Z",
    "textPlain": "LLMs are powerful assistants—as long as the user keeps a firm mental model of the problem. That’s why, for now, they complement software engineers rather than replace them (at least today).When you already know exactly what needs to be built and simply want to skip the drudgery of boilerplate or repetitive tasks, a coding CLI is great: it handles the grunt work so you can stay focused on the high-level design and decision-making that truly matter (and also more fun).",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44906685,
    "by": "random2019",
    "timeISO": "2025-08-14T22:54:55.000Z",
    "textPlain": "Btw a lot of blogposts happened on https://uplift.bio/blog about an alternative AI cognitive architecture, but somehow nothing came out of that as a commerical service to the greater public and they kept it closed source, and the C# code remains undetermined to this day, even if they supposedly wrote over 1 million lines of C# for that weird blog, which sounds insane to me, for C# a terser language ...{{cite web\n | title       = The Actual Growth of Machine Intelligence - 2021 Q4 to Present - Buil…\n | url         = https://uplift.bio/blog/the-actual-growth-of-machine-intelli...\n | date        = 2022-12-15\n | archiveurl  = http://archive.today/uwOes\n | archivedate = 2022-12-15 }}I barely know basics about Linux, computers, and the tooling around programming languages.They managed to run a better chatbot than ChatGPT 5 on 128 GB of RAM, 2 Xeons and around 180 dollars per month on a cloud Azure VM. Almost nobody cares. It's interesting they only used CPUs not GPUs.They mentioned something like, deep learning isn't good enough for their approach? Although in passing they said uplift could use GPUs too.They said they quit because it wasn't imaginative enough, but they also censored it a lot.They started coding around 2012 (?) put the bot online around 2019, and shut down public use around 2022.The AI revolution already happened in an obscure corner of the internet, but because of greed or anxiety of the creators it never took off.Lets see what happens by 2030, but, I'm not hoping much.\"1 million LOC\" they hardcoded everything, maybe, idk.I'm not paid to post this, and I mostly have no idea, but lets see if anything interesting comes out of my comment.I've learned about AST - Attention Schema Theory, IIT - Integrated Information Theory and GWT - Global Workspace Theory but without the knowledge it's mostly buzzwords for me.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901406,
    "by": "trod1234",
    "timeISO": "2025-08-14T15:16:12.000Z",
    "textPlain": "I think most people trying to touch on this topic don't consider this byline with other similar bylines like, \"Why LLMs can't recognize themselves looping\", or \"Why LLMs can't express intent\", or \"Why LLMs can't recognize truth/falsity, or confidence levels of what they know vs don't know\", these other bylines basically with a little thought equate to Computer Science halting problems, or  the undecidability nature of mathematics.Taken to a next step, recognizing this makes the investment in such a moonshot pipedream (overcoming these inherent problems in a deterministic way), recklessly negligent.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901637,
    "by": "revskill",
    "timeISO": "2025-08-14T15:31:39.000Z",
    "textPlain": "They can read and mind the error then figure out the best way to resolve. It is the best part about llm. No human can do it better than an llm. But they are not your mind reader. It is where things fall apart.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901481,
    "by": "Nickersf",
    "timeISO": "2025-08-14T15:21:22.000Z",
    "textPlain": "I think they're another tool in the toolbox not a new workshop. You have to build a good strategy around LLM usage when developing software. I think people are naturally noticing that and adapting.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901701,
    "by": "antihipocrat",
    "timeISO": "2025-08-14T15:35:43.000Z",
    "textPlain": "...\"(at least for now) you are in the drivers seat, and the LLM is just another tool to reach for.\"Improvements in model performance seem to be approaching the peak rather than demonstrating exponential gains. Is the quote above where we land in the end?",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901780,
    "by": "sneak",
    "timeISO": "2025-08-14T15:42:23.000Z",
    "textPlain": "Am I the only one continuously astounded at how well Opus 4 actually does build mental models when prompted correctly?I find Sonnet frequently loses the plot, but Opus can usually handle it (with sufficient clarity in prompting).",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901854,
    "by": "codr7",
    "timeISO": "2025-08-14T15:47:48.000Z",
    "textPlain": "Well, welcome to the club of awareness :)",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44903116,
    "by": "robomartin",
    "timeISO": "2025-08-14T17:20:57.000Z",
    "textPlain": "I decided to jump into the deep end of the pool and complete two projects using Cursor with it's default AI setup.The first project is a C++ embedded device.  The second is a sophisticated Django-based UI front end for a hardware device (so, python interacting with hardware and various JS libraries handling most of the front end).So far I am deeper into the Django project than the C++ embedded project.It's interesting.I had already hand-coded a conceptual version of the UI just to play with UI and interaction ideas.  I handed this to Cursor as well as a very detailed specification for the entire project, including directory structure, libraries, where to use what and why, etc.  In other words, exactly what I would provide a contractor or company if I were to outsource this project.  I also told it to take a first stab at the front end based on the hand-coded version I plopped into a temporary project directory.And then I channeled Jean-Luc Picard and said \"Engage!\".The first iteration took a few minutes.  It was surprisingly functional and complete.  Yet, of course, it had problems.  For example, it failed to separate various screens into separate independent Django apps.  It failed to separate the one big beautiful CSS and JS files into independent app-specific CSS and JS files.  In general, it ignored separation of concerns and just made it all work.  This is the kind of thing you might expect from a junior programmer/fresh grad.Achieving separation of concerns and other undesirable cross-pollination of code took some effort.  LLM's don't really understand.  They simulate understanding very well, but, at the end of the day, I don't think we are there.  They tend to get stuck and make dumb mistakes.The process to get to something that is now close to a release candidate entailed an interesting combination of manual editing and \"molding\" of the code base with short, precise and scope-limited instructions for Cursor.  For my workflow I am finding that limiting what I",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901910,
    "by": "jeffWrld",
    "timeISO": "2025-08-14T15:51:52.000Z",
    "textPlain": "[dead]",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902525,
    "by": "cindyllm",
    "timeISO": "2025-08-14T16:37:01.000Z",
    "textPlain": "[dead]",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901868,
    "by": "Xplan",
    "timeISO": "2025-08-14T15:48:39.000Z",
    "textPlain": "[dead]",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44903728,
    "by": "reramuyc",
    "timeISO": "2025-08-14T18:12:15.000Z",
    "textPlain": "[dead]",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901477,
    "by": "myfavoritedog",
    "timeISO": "2025-08-14T15:21:03.000Z",
    "textPlain": "[dead]",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902093,
    "by": "ontigola",
    "timeISO": "2025-08-14T16:03:54.000Z",
    "textPlain": "Great, concise article. Nothing important to add, except that AI snake-oil salesmen will continue spreading their exaggerations far and wide, at least we who are truly in this business agree on the facts.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901360,
    "by": "jmclnx",
    "timeISO": "2025-08-14T15:12:42.000Z",
    "textPlain": "I am not a fan of today's concept of \"AI\", but to be fair, building today's software is not for the faint of heart,  very few people gets it right on try 1.Years ago I gave up compiling these large applications all together.  I compiled Firefox via FreeBSD's (v8.x) ports system, that alone was a nightmare.I cannot imagine what it would be like to compile GNOME3 or KDE or Libreoffice.  Emacs is the largest thing I compile now.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902714,
    "by": "otterley",
    "timeISO": "2025-08-14T16:50:22.000Z",
    "textPlain": "On the contrary, Kiro (https://kiro.dev) is showing that it can be done by breaking down software engineering into multiple stages (requirements, design, and tasks) and then breaking the tasks down into discrete subtasks. Each of those can then be customized and refined as much as you like. It will even sketch out initial documents for all three.It’s still early days, but we are learning that as with software written exclusively by humans, the more specific the specifications are, the more likely the result will be as you intended.",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44902078,
    "by": "mccoyb",
    "timeISO": "2025-08-14T16:02:21.000Z",
    "textPlain": "This is a low information density blog post. I’ve really liked Zed’s blog posts in the past (especially about the editor internals!) so I hope this doesn’t come the wrong way, but this seems to be a loose restatement of what many people are empirically finding out by using LLM agents.Perhaps good for someone just getting their feet wet with these computational objects, but not resolving or explaining things in a clear way, or highlighting trends in research and engineering that might point towards ways forward.You also have a technical writing no no where you cite a rather precise and specific study with a paraphrase to support your claims … analogous to saying “Godel’s incompleteness theorem means _something something_ about the nature of consciousness”.A phrase like: “Unfortunately, for now, they cannot (beyond a certain complexity) actually understand what is going on” referencing a precise study … is ambiguous and shoddy technical writing — what exactly does the author mean here? It’s vague.I think it is even worse here because _the original study_ provides task-specific notions of complexity (a critique of the original study! Won’t different representations lead to different complexity scaling behavior? Of course! That’s what software engineering is all about: I need to think at different levels to control my exposure to complexity)",
    "parent": 44900116,
    "depth": 1
  },
  {
    "id": 44901575,
    "by": "skydhash",
    "timeISO": "2025-08-14T15:27:40.000Z",
    "textPlain": "Programmers are mostly translating business rules to the very formal process execution of the computer world. And you need to both knows what the rules means and how the computer works (or at least how the abstracted version you’re working with works). The translation is messy at first, which is why you need to revise it again and again. Especially when later rules comes challenging all the assumptions you’ve made or even contradicting themselves.Even translations between human languages (which allows for ambiguity) can be messy. Imagine if the target language is for a system that will exactly do as told unless someone has qualified those actions as bad.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44902070,
    "by": "ai-christianson",
    "timeISO": "2025-08-14T16:01:37.000Z",
    "textPlain": "I take a more pragmatic approach --everything is human in the loop. It helps me get the job done faster and with higher quality, so I use it.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44902313,
    "by": "appease7727",
    "timeISO": "2025-08-14T16:19:30.000Z",
    "textPlain": "The way it works for me at least is I can fit a huge amount of context in my head. This works because the text is utterly irrelevant and gets discarded immediately.Instead, my brain parses code into something like an AST which then is represented as a spatial graph. I model the program as a logical structure instead of a textual one. When you look past the language, you can work on the program. The two are utterly disjoint.I think LLMs fail at software because they're focused on text and can't build a mental model of the program logic. It take a huge amount of effort and brainpower to truly architect something and understand large swathes of the system. LLMs just don't have that type of abstract reasoning.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44901533,
    "by": "livid-neuro",
    "timeISO": "2025-08-14T15:25:05.000Z",
    "textPlain": "The first cars broke down all the time. They had a limited range. There wasn't a vast supply of parts for them. There wasn't a vast industry of experts who could work on them. There wasn't a vast network of fuel stations to provide energy for them. The horse was a proven method.What an LLM cannot do today is almost irrelevant in the tide of change upon the industry. The fact is, with improvements, it doesn't mean an LLM cannot do it tomorrow.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44902776,
    "by": "JackFr",
    "timeISO": "2025-08-14T16:54:50.000Z",
    "textPlain": "- When we have a report of a failing test before fixing it, identify the component under test. Think deeply about the component and describe its purpose, the control flows and state changes that occur within the component and assumptions the component makes about context.  Write that analysis in file called component-name-mental-model.md.- When ever you address a failing test, always bring your component mental model into the context.Paste that into your Claude prompt and see if you get better results.  You'll even be able to read and correct the LLM's mental model.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44901736,
    "by": "chuckadams",
    "timeISO": "2025-08-14T15:38:04.000Z",
    "textPlain": "An AI might tell you to use a 403 for insufficient privileges instead of 401.",
    "parent": 44901335,
    "depth": 2
  },
  {
    "id": 44903791,
    "by": "Natsu",
    "timeISO": "2025-08-14T18:18:00.000Z",
    "textPlain": ">  the response for that function should maybe differentiate between \"401 because you didn't authenticate\" and \"401 because your privileges are too low\".I'd tend to think it more proper if it were 401 you didn't authenticate and 403 you're forbidden from doing that with those user rights, but you have to be careful about exactly how detailed your messages are, lest they get tagged as a CWE-209 in your next security audit.",
    "parent": 44901335,
    "depth": 2
  }
]
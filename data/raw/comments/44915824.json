[
  {
    "id": 44916909,
    "by": "Const-me",
    "timeISO": "2025-08-15T20:23:22.000Z",
    "textPlain": "Not sure if that’s relevant, but when I do micro-benchmarks like that measuring time intervals way smaller than 1 second, I use __rdtsc() compiler intrinsic instead of standard library functions.On all modern processors, that instruction measures wallclock time with a counter which increments at the base frequency of the CPU unaffected by dynamic frequency scaling.Apart from the great resolution, that time measuring method has an upside of being very cheap, couple orders of magnitude faster than an OS kernel call.",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44916819,
    "by": "sweetjuly",
    "timeISO": "2025-08-15T20:12:56.000Z",
    "textPlain": "A better title: a pathological test program meant for Linux does not trigger pathological behavior on OpenBSD",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44916702,
    "by": "cout",
    "timeISO": "2025-08-15T19:57:32.000Z",
    "textPlain": "Interesting. I tried to follow the discussion in the linked thread, and the only takeaway I got was \"something to do with RCU\". What id the simplified explanation?",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44918133,
    "by": "sugarpimpdorsey",
    "timeISO": "2025-08-15T22:42:16.000Z",
    "textPlain": "OpenBSD is many things, but 'fast' is not a word that comes to mind.Lightweight? Yes.Minimalist? Definitely.Compact? Sure.But fast? No.Would I host a database or fileserver on OpenBSD? Hell no.Boot times seem to take as long as they did 20 years ago. They are also advocates for every schizo security mitigation they can dream up that sacrifices speed and that's ok too.But let's not pretend it's something it's not.",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44915925,
    "by": "rurban",
    "timeISO": "2025-08-15T18:33:12.000Z",
    "textPlain": "No, generally Linux is at least 3x faster than OpenBSD, because they don't care much for optimizations.",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44916798,
    "by": "themafia",
    "timeISO": "2025-08-15T20:10:05.000Z",
    "textPlain": "Yea,  well,  I had to modify your website to make it readable.  Why do people do this?",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44920078,
    "by": "1vuio0pswjnm7",
    "timeISO": "2025-08-16T04:10:03.000Z",
    "textPlain": "\"Usually it's the weirdo benchmark that shows OpenBSD being 10x slower, so this one is definitely going in the collection.\"Could it behttps://web.archive.org/web/20031020054211if_/http://bulk.fe...or is there another one",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44918960,
    "by": "eyberg",
    "timeISO": "2025-08-16T00:50:52.000Z",
    "textPlain": "This is kind of a stupid \"benchmark\" but if we're going to walk down this road:linux: elapsed: 0.019895snanos (running on said linux): elapsed: 0.000886s",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44916743,
    "by": "agambrahma",
    "timeISO": "2025-08-15T20:02:48.000Z",
    "textPlain": "So ... essentially testing file descriptor allocation overhead",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44917320,
    "by": "GTP",
    "timeISO": "2025-08-15T21:12:51.000Z",
    "textPlain": "By leaving my finger on the screen, I accidentally triggered an easter egg of two \"cannons\" shooting squares. Did anyone else notice it?",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44916631,
    "by": "haunter",
    "timeISO": "2025-08-15T19:47:02.000Z",
    "textPlain": "In my\nmind faster  = the same game with the same graphics settings have more FPS(I don’t even know you could actually start mainstream games on BSD or not)",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44916685,
    "by": "dang",
    "timeISO": "2025-08-15T19:55:42.000Z",
    "textPlain": "The article title is too baity to fit HN's guidelines (https://news.ycombinator.com/newsguidelines.html) so I replaced it with a phrase from the article that's hopefully just baity enough.",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44920833,
    "by": "u64x086a",
    "timeISO": "2025-08-16T06:43:25.000Z",
    "textPlain": "What about this on FreeBSD? It's possible to reach the same results?",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44920829,
    "by": "u64x086a",
    "timeISO": "2025-08-16T06:43:01.000Z",
    "textPlain": "What about the FreeBSD?",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44916757,
    "by": "asveikau",
    "timeISO": "2025-08-15T20:03:39.000Z",
    "textPlain": "My guess is it has something to do with the file descriptor table having a lot of empty entries (the dup2(0, 666) line.)Now time to read the actual linked discussion.",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44921566,
    "by": "owl_vision",
    "timeISO": "2025-08-16T08:59:58.000Z",
    "textPlain": "What were the resource setups?  How do they compare to linux resource setups?Defaults in current are in etc.amd64/login.conf.  https://cvsweb.openbsd.org/cgi-bin/cvsweb/~checkout~/src/etc...(p.s.: the bubble are cool.  highly distracting to me, hence I could not read the article in full.)",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44916562,
    "by": "jedberg",
    "timeISO": "2025-08-15T19:37:38.000Z",
    "textPlain": "\"It depends\"Faster is all relative.  What are you doing?  Is it networking?  Then BSD is probably faster than Linux.  Is it something Linux is optimized for?  Then probably Linux.A general benchmark?  Who knows, but does it really matter?At the end of the day, you should benchmark your own workload, but also it's important to realize that in this day and age, it's almost never the OS that is the bottleneck.  It's almost always a remote network call.",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44917334,
    "by": "M_r_R_o_b_o_t_",
    "timeISO": "2025-08-15T21:14:38.000Z",
    "textPlain": "Ye",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44917047,
    "by": "znpy",
    "timeISO": "2025-08-15T20:42:58.000Z",
    "textPlain": "the first step in benchmarking software is to use the same hardware.the author failed the first step.everything that follows is then garbage.",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44920580,
    "by": "ychnlt",
    "timeISO": "2025-08-16T05:54:13.000Z",
    "textPlain": "[dead]",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44916623,
    "by": "the_plus_one",
    "timeISO": "2025-08-15T19:45:46.000Z",
    "textPlain": "Is it just me, or is there some kind of asteroid game shooting bullets at my cursor while I try to read this [1]? I hate to sound mean, but it's a bit distracting. I guess it's my fault for having JavaScript enabled.[1]: https://flak.tedunangst.com/script.js",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44919662,
    "by": "kaskjdhaas",
    "timeISO": "2025-08-16T02:44:05.000Z",
    "textPlain": "[dead]",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44917703,
    "by": "uwagar",
    "timeISO": "2025-08-15T21:55:55.000Z",
    "textPlain": "the bsd people seem to enjoy measuring and logging a lot.",
    "parent": 44915824,
    "depth": 1
  },
  {
    "id": 44917042,
    "by": "sa46",
    "timeISO": "2025-08-15T20:42:16.000Z",
    "textPlain": "Isn't gettimeofday implemented with vDSO to avoid kernel context switching (and therefore, most of the overhead)?My understanding is that using tsc directly is tricky. The rate might not be constant, and the rate differs across cores. [1][1]: https://www.pingcap.com/blog/how-we-trace-a-kv-database-with...",
    "parent": 44916909,
    "depth": 2
  },
  {
    "id": 44918815,
    "by": "mananaysiempre",
    "timeISO": "2025-08-16T00:29:24.000Z",
    "textPlain": "This does not account for frequency scaling on laptops, context switches, core migrations, time spent in syscalls (if you don’t want to count it), etc. On Linux, you can get the kernel to expose the real (non-“reference”) cycle counter for you to access with __rdpmc() (no syscall needed) and put the corrective offset in an memory-mapped page. See the example code under cap_user_rdpmc on the manpage for perf_event_open() [1] and NOTE WELL the -1 in rdpmc(idx-1) there (I definitely did not waste an hour on that).If you want that on Windows, well, it’s possible, but you’re going to have to do it asynchronously from a different thread and also compute the offsets your own damn self[2].Alternatively, on AMD processors only, starting with Zen 2, you can get the real cycle count with __aperf() or __rdpru(__RDPRU_APERF) or manual inline assembly depending on your compiler. (The official AMD docs will admonish you not to assign meaning to anything but the fraction APERF / MPERF in one place, but the conjunction of what they tell you in other places implies that MPERF must be the reference cycle count and APERF must be the real cycle count.) This is definitely less of a hassle, but in my experience the cap_user_rdpmc method on Linux is much less noisy.[1] https://man7.org/linux/man-pages/man2/perf_event_open.2.html[2] https://www.computerenhance.com/p/halloween-spooktacular-day...",
    "parent": 44916909,
    "depth": 2
  },
  {
    "id": 44920803,
    "by": "ethan_smith",
    "timeISO": "2025-08-16T06:38:50.000Z",
    "textPlain": "While __rdtsc() is fast, be cautious with multi-core benchmarks as TSC synchronization between cores isn't guaranteed on all hardware, especially older systems. Modern Intel/AMD CPUs have \"invariant TSC\" which helps, but it's worth checking CPU flags first.",
    "parent": 44916909,
    "depth": 2
  },
  {
    "id": 44921125,
    "by": "signa11",
    "timeISO": "2025-08-16T07:35:56.000Z",
    "textPlain": "I don't think it is (guaranteed to be) synchronized across cores. I might be wrong about that though.",
    "parent": 44916909,
    "depth": 2
  },
  {
    "id": 44919129,
    "by": "junon",
    "timeISO": "2025-08-16T01:16:00.000Z",
    "textPlain": "rdtsc isn't available on all platforms, for what it's worth. It's often disabled as there's a CPU flag to allow its use in user space, and it's well know to not be so accurate.",
    "parent": 44916909,
    "depth": 2
  },
  {
    "id": 44919217,
    "by": "mrlongroots",
    "timeISO": "2025-08-16T01:27:18.000Z",
    "textPlain": "They could've just used `clock_gettime(CLOCK_MONOTONIC)`",
    "parent": 44916909,
    "depth": 2
  },
  {
    "id": 44919725,
    "by": "oguz-ismail",
    "timeISO": "2025-08-16T02:59:01.000Z",
    "textPlain": "> I use __rdtsc() compiler intrinsicWhat do you do on ARM?",
    "parent": 44916909,
    "depth": 2
  },
  {
    "id": 44916901,
    "by": "apgwoz",
    "timeISO": "2025-08-15T20:21:39.000Z",
    "textPlain": "Surely you must be new to tedu posts…",
    "parent": 44916819,
    "depth": 2
  },
  {
    "id": 44917222,
    "by": "bobby_big_balls",
    "timeISO": "2025-08-15T21:03:48.000Z",
    "textPlain": "In Linux, the file descriptor table (fdtable) of a process starts with a minimum of 256 slots. Two threads creating 256 sockets each, which uses 512 fds on top of the three already present (for stdin, stdout and stderr), requires that the fdtable be expanded about halfway through when the capacity is doubled from 256 to 512, and again near the end when resizing from 512 to 1024.This is done by expand_fdtable() in the kernel. It contains the following code:        if (atomic_read(&files->count) > 1)\n          synchronize_rcu();\n\nThe field files->count is a reference counter. As there are two threads, which share a set of open files between them, the value of this is 2, meaning that synchronize_rcu() is called here during fdtable expansion. This waits until a full RCU grace period has elapsed, causing a delay in acquiring a new fd for the socket currently being created.If the fdtable is expanded prior to creating a new thread, as the test program optionally will do by calling dup(0, 666) if supplied a command line argument, this avoids the synchronize_rcu() call because at this point files->count == 1. Therefore, if this is done, there will be no delay later on when creating all the sockets as the fdtable will have sufficient capacity.By contrast, the OpenBSD kernel doesn't have anything like RCU and just uses a rwlock when the file descriptor table of the process is being modified, avoiding the long delay during expansion that may be observed in Linux.",
    "parent": 44916702,
    "depth": 2
  },
  {
    "id": 44917030,
    "by": "viraptor",
    "timeISO": "2025-08-15T20:40:52.000Z",
    "textPlain": "When 2 threads are allocating sockets sequentially, they fight for the locks. If you preallocate a bigger table by creating fd 666 first, the lock contention goes away.",
    "parent": 44916702,
    "depth": 2
  },
  {
    "id": 44920836,
    "by": "somat",
    "timeISO": "2025-08-16T06:43:40.000Z",
    "textPlain": "Gotta disagree with you on your minimalist verdict, out of the box openbsd tends to have everything and the kitchen sink, I am not complaining, it is good solid well written software. but I have never found a base linux distro that was as well stocked as a base openbsd install.    a c compiler\n    a web server\n    3 routing daemons(bgpd, ospfd, ripd)\n    a mail server(smtpd, spamd)\n    a sound server(sndiod)\n    a reverse proxy(relayd)\n    2 desktop environments(fvwm, cwm)\n    plus many many more\n\nOpenbsd is not some minimalist highly focused operating system, I mean what on earth is it actually for? based on the included features, A desktop development system that is also the router and office web and mail server?Personally I love it, after a fresh install I always feel like I could rebuild the internet from scratch using only what is found in front of me if I needed to.",
    "parent": 44918133,
    "depth": 2
  },
  {
    "id": 44918410,
    "by": "ThinkBeat",
    "timeISO": "2025-08-15T23:22:31.000Z",
    "textPlain": "You must run a different branch of OpenBSD than I.",
    "parent": 44918133,
    "depth": 2
  },
  {
    "id": 44916830,
    "by": "farhaven",
    "timeISO": "2025-08-15T20:14:08.000Z",
    "textPlain": "OpenBSD is a lot faster in some specialized areas though. Random number generation from `/dev/urandom`, for example. When I was at university (in 2010 or so), it was faster to read `/dev/urandom` on my OpenBSD laptop and pipe it over ethernet to a friend's Linux laptop than running `cat /dev/urandom > /dev/sda` directly on his.Not by just a bit, but it was a difference between 10MB/s and 100MB/s.",
    "parent": 44915925,
    "depth": 2
  },
  {
    "id": 44916549,
    "by": "shmerl",
    "timeISO": "2025-08-15T19:35:32.000Z",
    "textPlain": "It's talking about a specific case: https://infosec.exchange/@jann/115022521451508325",
    "parent": 44915925,
    "depth": 2
  },
  {
    "id": 44916551,
    "by": "kleiba",
    "timeISO": "2025-08-15T19:35:54.000Z",
    "textPlain": "Pretty broad statement(s).",
    "parent": 44915925,
    "depth": 2
  },
  {
    "id": 44918412,
    "by": "nicce",
    "timeISO": "2025-08-15T23:23:22.000Z",
    "textPlain": "Rather they care about the security. The same mitigations in Linux would likely make it even slower.",
    "parent": 44915925,
    "depth": 2
  },
  {
    "id": 44918587,
    "by": "opan",
    "timeISO": "2025-08-15T23:50:49.000Z",
    "textPlain": "It looks good to me on mobile. High contrast, lines aren't too long. What issue did you have?",
    "parent": 44916798,
    "depth": 2
  },
  {
    "id": 44919829,
    "by": "loeg",
    "timeISO": "2025-08-16T03:21:30.000Z",
    "textPlain": "Sort of.  Fd table size, which is slightly different than fds (once you reach the ulimit, there's no need to resize it larger); and only in multithreaded programs.",
    "parent": 44916743,
    "depth": 2
  },
  {
    "id": 44918788,
    "by": "IFC_LLC",
    "timeISO": "2025-08-16T00:24:58.000Z",
    "textPlain": "I'll be honest, this was the first time when I was unhappy with an easter egg and was unable to finish reading the article because of it.Triggered on a safari on mac.",
    "parent": 44917320,
    "depth": 2
  },
  {
    "id": 44917339,
    "by": "evanjrowley",
    "timeISO": "2025-08-15T21:14:54.000Z",
    "textPlain": "I also saw it, and it happened on a non-touch computer screen.",
    "parent": 44917320,
    "depth": 2
  },
  {
    "id": 44917567,
    "by": "pan69",
    "timeISO": "2025-08-15T21:41:11.000Z",
    "textPlain": "Happened for me on my normal desktop browser, cute but distracting. It also made my mouse cursor disappear. I had to move my mouse outside the browser window to make it visible again.",
    "parent": 44917320,
    "depth": 2
  },
  {
    "id": 44916654,
    "by": "nine_k",
    "timeISO": "2025-08-15T19:50:29.000Z",
    "textPlain": "Isn't it mostly limited by GPU hardware, and by binary blobs that are largely independent from the host platform?",
    "parent": 44916631,
    "depth": 2
  },
  {
    "id": 44916765,
    "by": "JdeBP",
    "timeISO": "2025-08-15T20:04:51.000Z",
    "textPlain": "I was just about to point Ian Betteridge at the original title.  (-:",
    "parent": 44916685,
    "depth": 2
  },
  {
    "id": 44917768,
    "by": "wahern",
    "timeISO": "2025-08-15T22:02:12.000Z",
    "textPlain": "I think dup2 is the hint, but in the example case the dup2 path isn't invoked--it's conditioned on passing an argument, but the test runs are just `./a.out`. IIUC, the issue is growing the file descriptor table. The dup2 is a workaround that preallocates a larger table (666 > 256 * 2)[1], to avoid the pathological case when a multi-threaded process grows the table. From the linked infosec.exchange discussion it seems the RCU-based approach Linux is using can result in some significant latency, resulting in much worse performance in simple cases like this compared to a simple mutex[2].[1] Off-by-one. To be more precise, the state established by the dup2 is (667 > 256 * 2), or rather (667 > 3 + 256 * 2).[2] Presumably what OpenBSD is using. I'd be surprised if they've already imported and adopted FreeBSD's approach mentioned in the linked discussion, notwithstanding that OpenBSD has been on an MP scalability tear the past few years.",
    "parent": 44916757,
    "depth": 2
  },
  {
    "id": 44919839,
    "by": "loeg",
    "timeISO": "2025-08-16T03:22:55.000Z",
    "textPlain": "The article is marginally more interesting than the headline, and it's not very long.  Go ahead and read it.",
    "parent": 44916562,
    "depth": 2
  },
  {
    "id": 44917734,
    "by": "saagarjha",
    "timeISO": "2025-08-15T21:58:53.000Z",
    "textPlain": "You do understand that people who know how to benchmark things don’t actually need to conform to the rules of thumb that are given to non-experts so they don’t shoot themselves in the foot, right? Do you also write off rally drivers because they have their feet on both pedals?",
    "parent": 44917047,
    "depth": 2
  },
  {
    "id": 44917423,
    "by": "lilyball",
    "timeISO": "2025-08-15T21:24:04.000Z",
    "textPlain": "It's extremely distracting. I'm not normally one to have issues that require reduced motion, but the asteroids are almost distracting enough on their own, and the fact that it causes my cursor to vanish is a real accessibility issue. I didn't actually realize just how much I use my mouse cursor when reading stuff until now, partly as a fidget, partly as a controllable visual anchor as my eyes scan the page.",
    "parent": 44916623,
    "depth": 2
  }
]
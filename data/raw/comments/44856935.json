[
  {
    "id": 44858071,
    "by": "perlgeek",
    "timeISO": "2025-08-10T20:31:43.000Z",
    "textPlain": "I like 99% of this, and the thing I don't like is in the very first line of the example:> import abs, epsilon from mathIMHO it's wrong to put the imported symbols first, because the same symbol could come from two different libraries and mean different things. So the library name is pretty important, and putting it last (and burying it after a potentially long list of imported symbols) just feels wrong.I get that it has a more natural-language vibe this way, but put there's a really good reason that most of the languages I know that put the package/module name first:    import packageName.member; // java\n    from package import symbol; # python\n    use Module 'symbol'; # perl\n    \nWith Typescript being the notable exception:    import { pi as π } from \"./maths.js\";t",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857985,
    "by": "haberman",
    "timeISO": "2025-08-10T20:19:51.000Z",
    "textPlain": "I love the concept -- I've often wished that lean languages like Lua had more support for static typing, especially given the potential performance benefits.I also love the focus on performance.  I'm curious if you've considered using a tail call design for the interpreter.  I've found this to be the best way to get good code out of the compiler: https://blog.reverberate.org/2021/04/21/musttail-efficient-i...  Unfortunately it's not portable to MSVC.In that article I show that this technique was able to match Mike Pall's hand-coded assembly for one example he gave of LuaJIT's interpreter.  Mike later linked to the article as a new take for how to optimize interpreters: https://github.com/LuaJIT/LuaJIT/issues/716#issuecomment-854...Python 3.14 also added support for this style of interpreter dispatch and got a modest performance win from it: https://blog.reverberate.org/2025/02/10/tail-call-updates.ht...",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857819,
    "by": "cookiengineer",
    "timeISO": "2025-08-10T19:59:05.000Z",
    "textPlain": "If functions don't have a return signature, does that mean everything must be satisfied in the compilation step?What about memory management/ownership? This would imply that everything must be copy by value in each function callsite, right? How to use references/pointers? Are they supported?I like the matchers which look similar to Rust, but I dislike the error handling because it is neither implicit, and neither explicit, and therefore will be painful to debug in larger codebases I'd imagine.Do you know about Koka? I don't like its syntax choices much but I think that an effect based error type system might integrate nicely with your design choices, especially with matchers as consumers.[1] https://koka-lang.github.io/koka/doc/index.html",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857304,
    "by": "MobiusHorizons",
    "timeISO": "2025-08-10T18:48:35.000Z",
    "textPlain": "FYI \"the embedded scene\" is likely to be interpreted as \"embedded systems\" rather than \"embedded interpreters\" even by people who know about embedded interpreters, especially since all the languages you give as an example have been attempted for use on those targets (micropython, lua, and even typescript)",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858260,
    "by": "freeopinion",
    "timeISO": "2025-08-10T21:04:32.000Z",
    "textPlain": "I see your benchmarks compare against other interpreted languages \"in its class\".We read here a couple days ago about Q which is compiled. Bolt claims to \"plow through code at over 500kloc/thread/second\". Q claims to compile in milliseconds--so fast that you can treat it like a script.Bolt and Q are both newborns. Perhaps you could include each other in your benchmarks to give each other a little publicity.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858159,
    "by": "Fraterkes",
    "timeISO": "2025-08-10T20:49:47.000Z",
    "textPlain": "Really cool! Roughly how much memory does it take to include it in an engine? Also I'm really interested in the process of creating these really fast scripting languages, have you written anything about how you wrote Bolt?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857208,
    "by": "themonsu",
    "timeISO": "2025-08-10T18:31:32.000Z",
    "textPlain": "Looks cool, but please can we stop naming things ”bolt”",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858184,
    "by": "Forgret",
    "timeISO": "2025-08-10T20:53:45.000Z",
    "textPlain": "It looks cool, I wish you luck in developing the language. I liked your language and I hope it becomes popular someday.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857984,
    "by": "kiririn",
    "timeISO": "2025-08-10T20:19:22.000Z",
    "textPlain": "Nice, gives me Pawn vibes(https://www.compuphase.com/pawn/pawn.htm)",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857233,
    "by": "grodriguez100",
    "timeISO": "2025-08-10T18:36:24.000Z",
    "textPlain": "Sounds very good, and I can see many use cases in embedded systems. But that probably requires 32-bit arm support. Is that planned ?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857827,
    "by": "Vandash",
    "timeISO": "2025-08-10T19:59:56.000Z",
    "textPlain": "game dev for 15+ years here, love the first example on Github\nthis is compiled right? cannot replace lua?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857211,
    "by": "acron0",
    "timeISO": "2025-08-10T18:32:07.000Z",
    "textPlain": "If I was still writing games I would be alllllll over this",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857448,
    "by": "eulgro",
    "timeISO": "2025-08-10T19:09:42.000Z",
    "textPlain": "The question I ask myself when I see this kind of project is: how long are you willing to maintain it for?My main concern about a new language is not performance, syntax, or features, but long term support and community.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857326,
    "by": "thrance",
    "timeISO": "2025-08-10T18:52:14.000Z",
    "textPlain": "Function return type inference is funny but I don't think it's that great of a feature. It makes it harder for a library's consumer to know how to properly use a function, and it also makes it harder for the maintainer to not break backwards compatibility inadvertently. Anyway, I'm all for experimenting.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858126,
    "by": "beariish",
    "timeISO": "2025-08-10T20:43:16.000Z",
    "textPlain": "Do you think approaching the way typescript does it for Bolt is a reasonable compromise here? Bolt already supports full-module renames like    import math as not_math\n\nSo supporting something along the lines of    import abs as absolute, sqrt as square_root from math\n\nWould be farily simple to accomplish.",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44858028,
    "by": "beariish",
    "timeISO": "2025-08-10T20:25:05.000Z",
    "textPlain": "I did experiment with a few different dispatch methods before settling on the one in Bolt now, though not with tailcalls specifically. The approach I landed on was largely chosen cause it in my testing competes with computed goto solutions while also compiling on msvc, but I'm absolutely open to try other things out.",
    "parent": 44857985,
    "depth": 2
  },
  {
    "id": 44858121,
    "by": "summerwant",
    "timeISO": "2025-08-10T20:42:32.000Z",
    "textPlain": "I see lua, do you know terralang?",
    "parent": 44857985,
    "depth": 2
  },
  {
    "id": 44857347,
    "by": "beariish",
    "timeISO": "2025-08-10T18:56:01.000Z",
    "textPlain": "That's a good point, thank you. I've made a small edit to clarify.",
    "parent": 44857304,
    "depth": 2
  },
  {
    "id": 44858174,
    "by": "beariish",
    "timeISO": "2025-08-10T20:51:58.000Z",
    "textPlain": "Bolt's memory usage in most cases hovers right around Lua 5.4/Luau in my own testing, but maybe I should include a few memory benchmarks to highlight that more. It does notably have a higher memory overhead during compilation than other languages in this class though.As for writeups, I'm working on putting out some material about the creation of Bolt and my learnings now that it's out there.",
    "parent": 44858159,
    "depth": 2
  },
  {
    "id": 44857249,
    "by": "beariish",
    "timeISO": "2025-08-10T18:39:09.000Z",
    "textPlain": "As of right now no - my primary target when developing this was realtime and games in particular since that's what I know best, but if there's a real target in embedded that's certainly something that could be explored.",
    "parent": 44857233,
    "depth": 2
  },
  {
    "id": 44857885,
    "by": "IshKebab",
    "timeISO": "2025-08-10T20:06:24.000Z",
    "textPlain": "It's compiled in the same way that Lua is compiled. So yes, it can replace Lua.",
    "parent": 44857827,
    "depth": 2
  },
  {
    "id": 44857873,
    "by": "beariish",
    "timeISO": "2025-08-10T20:04:41.000Z",
    "textPlain": "Bolt is not compiled ahead of time, it's bytecode interpreted just like Lua",
    "parent": 44857827,
    "depth": 2
  },
  {
    "id": 44857851,
    "by": "brabel",
    "timeISO": "2025-08-10T20:02:17.000Z",
    "textPlain": "The only way to have any idea of how long a language might be still around is to look at how long it's been already around. From this perspective , you can only use older languages. The benchmarks show that Lua (and the Luau and Lua+JIT variants) is actually very competitive, so I'd stick with one of those.",
    "parent": 44857448,
    "depth": 2
  },
  {
    "id": 44857479,
    "by": "01HNNWZ0MV43FF",
    "timeISO": "2025-08-10T19:15:33.000Z",
    "textPlain": "In the end, weight is a kind of strength, and popularity is a kind of quality. It looks promising but you can't expect long-term support until there's more contributors and usersAt this point it is too early to know. Even JavaScript took like 20 years to catch on",
    "parent": 44857448,
    "depth": 2
  },
  {
    "id": 44857372,
    "by": "beariish",
    "timeISO": "2025-08-10T18:59:25.000Z",
    "textPlain": "There's nothing stopping a library author from explicitly annotating return types wherever a stable interface is important, the idea is more for smaller functions or callbacks to make use of this. Perhaps I'll make the examples clearer to reflect the intention.",
    "parent": 44857326,
    "depth": 2
  }
]
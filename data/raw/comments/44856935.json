[
  {
    "id": 44857985,
    "by": "haberman",
    "timeISO": "2025-08-10T20:19:51.000Z",
    "textPlain": "I love the concept -- I've often wished that lean languages like Lua had more support for static typing, especially given the potential performance benefits.I also love the focus on performance.  I'm curious if you've considered using a tail call design for the interpreter.  I've found this to be the best way to get good code out of the compiler: https://blog.reverberate.org/2021/04/21/musttail-efficient-i...  Unfortunately it's not portable to MSVC.In that article I show that this technique was able to match Mike Pall's hand-coded assembly for one example he gave of LuaJIT's interpreter.  Mike later linked to the article as a new take for how to optimize interpreters: https://github.com/LuaJIT/LuaJIT/issues/716#issuecomment-854...Python 3.14 also added support for this style of interpreter dispatch and got a modest performance win from it: https://blog.reverberate.org/2025/02/10/tail-call-updates.ht...",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44859665,
    "by": "conaclos",
    "timeISO": "2025-08-11T00:21:14.000Z",
    "textPlain": "I was quite excited by the description and then I noted that Bolt heavily relies on double floating point numbers. I am quite disappointed because this doesn't allow me to use Bolt in my context: embedded systems where floating point numbers are rarely supported... So I realized that I misinterpreted `embedded`.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858071,
    "by": "perlgeek",
    "timeISO": "2025-08-10T20:31:43.000Z",
    "textPlain": "I like 99% of this, and the thing I don't like is in the very first line of the example:> import abs, epsilon from mathIMHO it's wrong to put the imported symbols first, because the same symbol could come from two different libraries and mean different things. So the library name is pretty important, and putting it last (and burying it after a potentially long list of imported symbols) just feels wrong.I get that it has a more natural-language vibe this way, but put there's a really good reason that most of the languages I know that put the package/module name first:    import packageName.member; // java\n    from package import symbol; # python\n    use Module 'symbol'; # perl\n    \nWith Typescript being the notable exception:    import { pi as π } from \"./maths.js\";t",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857304,
    "by": "MobiusHorizons",
    "timeISO": "2025-08-10T18:48:35.000Z",
    "textPlain": "FYI \"the embedded scene\" is likely to be interpreted as \"embedded systems\" rather than \"embedded interpreters\" even by people who know about embedded interpreters, especially since all the languages you give as an example have been attempted for use on those targets (micropython, lua, and even typescript)",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857819,
    "by": "cookiengineer",
    "timeISO": "2025-08-10T19:59:05.000Z",
    "textPlain": "If functions don't have a return signature, does that mean everything must be satisfied in the compilation step?What about memory management/ownership? This would imply that everything must be copy by value in each function callsite, right? How to use references/pointers? Are they supported?I like the matchers which look similar to Rust, but I dislike the error handling because it is neither implicit, and neither explicit, and therefore will be painful to debug in larger codebases I'd imagine.Do you know about Koka? I don't like its syntax choices much but I think that an effect based error type system might integrate nicely with your design choices, especially with matchers as consumers.[1] https://koka-lang.github.io/koka/doc/index.html",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44860277,
    "by": "slmjkdbtl",
    "timeISO": "2025-08-11T02:29:22.000Z",
    "textPlain": "Wow a fast scripting language with normal syntax and type checking.. Really hope this can take off and be a valid Lua alternative.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44859571,
    "by": "JonChesterfield",
    "timeISO": "2025-08-11T00:00:31.000Z",
    "textPlain": "Outperforming languages in its class is doing some heavy lifting here. Missing comparison to wasm interpreter, any of the java or dot net interpreters, the MLs, any lisps etc.Compile to register bytecode is legitimate as a strategy but its not the fast one, as the author knows, so probably shouldn't be branding the language as fast at this point.It might be a fast language. Hard to tell from a superficial look, depends on how the type system, alias analysis and concurrency models interact. It's not a fast implementation at this point.> This means functions do not need to dynamically capture their imports, avoiding closure invocations, and are able to linearly address them in the import array instead of making some kind of environment lookup.That is suspect, could be burning function identifiers into the bytecode directly, not emitting lookups in a table.Likewise the switch on the end of each instruction is probably the wrong thing, take a look at a function per op, forced tailcalls, with the interpreter state in the argument registers of the machine function call. There's some good notes on that from some wasm interpreters, and some context on why from luajit if you go looking.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857208,
    "by": "themonsu",
    "timeISO": "2025-08-10T18:31:32.000Z",
    "textPlain": "Looks cool, but please can we stop naming things ”bolt”",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44860225,
    "by": "je42",
    "timeISO": "2025-08-11T02:17:20.000Z",
    "textPlain": "Nice language! I am wondering how error handling / exceptions works in bolt?Quickly scanned the programming guide - but wasn't able to find it. Did i miss a section?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858260,
    "by": "freeopinion",
    "timeISO": "2025-08-10T21:04:32.000Z",
    "textPlain": "I see your benchmarks compare against other interpreted languages \"in its class\".We read here a couple days ago about Q which is compiled. Bolt claims to \"plow through code at over 500kloc/thread/second\". Q claims to compile in milliseconds--so fast that you can treat it like a script.Bolt and Q are both newborns. Perhaps you could include each other in your benchmarks to give each other a little publicity.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44859122,
    "by": "tayistay",
    "timeISO": "2025-08-10T23:01:37.000Z",
    "textPlain": "Congrats! I think this could be quite useful for me.I noticed that `let`-declared variables seem to be mutable. I'd strongly recommend against that. Add a `var` keyword.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44860202,
    "by": "capyba",
    "timeISO": "2025-08-11T02:11:56.000Z",
    "textPlain": "In terms of performance, how does it compare to compiled languages like the C it’s written in?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858159,
    "by": "Fraterkes",
    "timeISO": "2025-08-10T20:49:47.000Z",
    "textPlain": "Really cool! Roughly how much memory does it take to include it in an engine? Also I'm really interested in the process of creating these really fast scripting languages, have you written anything about how you wrote Bolt?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858932,
    "by": "memophysic",
    "timeISO": "2025-08-10T22:40:52.000Z",
    "textPlain": "Looks great, I'm especially a fan of the more C and Python syntax. Lua works, but its syntax has always been bugging me.On the feature side, is there any support for breakpoints or a debugging server, and if not is it planned?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858854,
    "by": "astatine",
    "timeISO": "2025-08-10T22:30:14.000Z",
    "textPlain": "This looks awesome. Would you have any data on the performance of large number of invocations of small scripts? I am wondering at startup overhead for every script run. which the 500kloc/s may not capture well.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44859220,
    "by": "merksoftworks",
    "timeISO": "2025-08-10T23:11:45.000Z",
    "textPlain": "This is really cool but it's not portable to MacOs or aarm64 yet, and that kind of portability unfortunately is what appeals to me about an embeddable scripting language.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857984,
    "by": "kiririn",
    "timeISO": "2025-08-10T20:19:22.000Z",
    "textPlain": "Nice, gives me Pawn vibes(https://www.compuphase.com/pawn/pawn.htm)",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858184,
    "by": "Forgret",
    "timeISO": "2025-08-10T20:53:45.000Z",
    "textPlain": "It looks cool, I wish you luck in developing the language. I liked your language and I hope it becomes popular someday.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857448,
    "by": "eulgro",
    "timeISO": "2025-08-10T19:09:42.000Z",
    "textPlain": "The question I ask myself when I see this kind of project is: how long are you willing to maintain it for?My main concern about a new language is not performance, syntax, or features, but long term support and community.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857233,
    "by": "grodriguez100",
    "timeISO": "2025-08-10T18:36:24.000Z",
    "textPlain": "Sounds very good, and I can see many use cases in embedded systems. But that probably requires 32-bit arm support. Is that planned ?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857211,
    "by": "acron0",
    "timeISO": "2025-08-10T18:32:07.000Z",
    "textPlain": "If I was still writing games I would be alllllll over this",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857827,
    "by": "Vandash",
    "timeISO": "2025-08-10T19:59:56.000Z",
    "textPlain": "game dev for 15+ years here, love the first example on Github\nthis is compiled right? cannot replace lua?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858568,
    "by": "k__",
    "timeISO": "2025-08-10T21:43:03.000Z",
    "textPlain": "Awesome.Is it deterministic like Lua?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857326,
    "by": "thrance",
    "timeISO": "2025-08-10T18:52:14.000Z",
    "textPlain": "Function return type inference is funny but I don't think it's that great of a feature. It makes it harder for a library's consumer to know how to properly use a function, and it also makes it harder for the maintainer to not break backwards compatibility inadvertently. Anyway, I'm all for experimenting.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858761,
    "by": "debugnik",
    "timeISO": "2025-08-10T22:14:03.000Z",
    "textPlain": "You may be interested in Luau, which is the gradually-typed dialect of Lua maintained by Roblox. The game Alan Wake 2 also used it for level scripting.",
    "parent": 44857985,
    "depth": 2
  },
  {
    "id": 44858028,
    "by": "beariish",
    "timeISO": "2025-08-10T20:25:05.000Z",
    "textPlain": "I did experiment with a few different dispatch methods before settling on the one in Bolt now, though not with tailcalls specifically. The approach I landed on was largely chosen cause it in my testing competes with computed goto solutions while also compiling on msvc, but I'm absolutely open to try other things out.",
    "parent": 44857985,
    "depth": 2
  },
  {
    "id": 44858121,
    "by": "summerwant",
    "timeISO": "2025-08-10T20:42:32.000Z",
    "textPlain": "I see lua, do you know terralang?",
    "parent": 44857985,
    "depth": 2
  },
  {
    "id": 44860241,
    "by": "devmor",
    "timeISO": "2025-08-11T02:21:32.000Z",
    "textPlain": "Same here! It's very cool but my ideal use case would be on a limited ISA architecture like ESP32.",
    "parent": 44859665,
    "depth": 2
  },
  {
    "id": 44858495,
    "by": "jasonjmcghee",
    "timeISO": "2025-08-10T21:34:05.000Z",
    "textPlain": "Also autocomplete.Though I almost never manually type out imports manually anymore.",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44860622,
    "by": "Tokumei-no-hito",
    "timeISO": "2025-08-11T03:51:38.000Z",
    "textPlain": "can't the compiler process it in reverse?",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44858476,
    "by": "bbkane",
    "timeISO": "2025-08-10T21:30:04.000Z",
    "textPlain": "I really like the way Elm does it, from \"wide\" (package) to \"narrow\" (symbol). I suspect this also helps language server implementation.See https://guide.elm-lang.org/webapps/modules (scroll down to \"Using Modules\") for examples",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44858126,
    "by": "beariish",
    "timeISO": "2025-08-10T20:43:16.000Z",
    "textPlain": "Do you think approaching the way typescript does it for Bolt is a reasonable compromise here? Bolt already supports full-module renames like    import math as not_math\n\nSo supporting something along the lines of    import abs as absolute, sqrt as square_root from math\n\nWould be farily simple to accomplish.",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44859048,
    "by": "vhodges",
    "timeISO": "2025-08-10T22:54:32.000Z",
    "textPlain": "According to the Programming Guide, it supports aliases for imports\"In case of conflict or convenience, you can give modules an alias as well.\"",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44860409,
    "by": "RossBencina",
    "timeISO": "2025-08-11T02:55:10.000Z",
    "textPlain": "True. I misread it as being for embedded, especially with the term \"real-time\" in the mix. Then later when there was no ARM or RISC-V support I became very confused.",
    "parent": 44857304,
    "depth": 2
  },
  {
    "id": 44857347,
    "by": "beariish",
    "timeISO": "2025-08-10T18:56:01.000Z",
    "textPlain": "That's a good point, thank you. I've made a small edit to clarify.",
    "parent": 44857304,
    "depth": 2
  },
  {
    "id": 44858725,
    "by": "driggs",
    "timeISO": "2025-08-10T22:08:02.000Z",
    "textPlain": "> If functions don't have a return signature, does that mean everything must be satisfied in the compilation step?Functions do have a return signature.It looks like the author chose to show off the feature of return type inference in the short example README code, rather than the explicit case.https://github.com/Beariish/bolt/blob/main/doc/Bolt%20Progra...",
    "parent": 44857819,
    "depth": 2
  },
  {
    "id": 44858415,
    "by": "zygentoma",
    "timeISO": "2025-08-10T21:22:02.000Z",
    "textPlain": "Oh, not OP, but I love Koka. I should play around with it again thanks for reminding me!",
    "parent": 44857819,
    "depth": 2
  },
  {
    "id": 44859894,
    "by": "phire",
    "timeISO": "2025-08-11T01:15:53.000Z",
    "textPlain": "The class is \"embeddable interpreted scripting language\", which is not quite the same thing as just an interpreter.Embedded interpreters are that designed to be embedded into a c/c++ program (often a game) as a scripting language. They typically have as few dependencies as possible, try to be lightweight and focus on making it really easy to interopt between contexts.The comparison hits many of the major languages for this usecase. Though it probably should have included mono's interpreter mode, even if nobody really uses it since mono got AoT",
    "parent": 44859571,
    "depth": 2
  },
  {
    "id": 44858791,
    "by": "IAmLiterallyAB",
    "timeISO": "2025-08-10T22:17:59.000Z",
    "textPlain": "Yeah this is the third programming language named Bolt that I'm aware of",
    "parent": 44857208,
    "depth": 2
  },
  {
    "id": 44860419,
    "by": "mdaniel",
    "timeISO": "2025-08-11T02:58:12.000Z",
    "textPlain": "Seems to be the worst of both worlds: mutable by default, and one must add a \"const\" keyword to the \"let\", disincentivizing const behavior by making it super verbose (e.g. the \"final\" problem from Java)https://github.com/Beariish/bolt/blob/0.1.0/doc/Bolt%20Progr...",
    "parent": 44859122,
    "depth": 2
  },
  {
    "id": 44858174,
    "by": "beariish",
    "timeISO": "2025-08-10T20:51:58.000Z",
    "textPlain": "Bolt's memory usage in most cases hovers right around Lua 5.4/Luau in my own testing, but maybe I should include a few memory benchmarks to highlight that more. It does notably have a higher memory overhead during compilation than other languages in this class though.As for writeups, I'm working on putting out some material about the creation of Bolt and my learnings now that it's out there.",
    "parent": 44858159,
    "depth": 2
  },
  {
    "id": 44859174,
    "by": "beariish",
    "timeISO": "2025-08-10T23:06:55.000Z",
    "textPlain": "There's nothing like that right now, but it's absolutely something I want to explore in the future.",
    "parent": 44858932,
    "depth": 2
  },
  {
    "id": 44859189,
    "by": "beariish",
    "timeISO": "2025-08-10T23:08:43.000Z",
    "textPlain": "It depends on your exact usecase, I'm not 100% sure what you're asking. There is some overhead for invoking the compiler on a per-script basis. If you're parsing once but running a script many times, Bolt provides some tools (like reusing a preallocated thread object) to ammortize that cost",
    "parent": 44858854,
    "depth": 2
  },
  {
    "id": 44857851,
    "by": "brabel",
    "timeISO": "2025-08-10T20:02:17.000Z",
    "textPlain": "The only way to have any idea of how long a language might be still around is to look at how long it's been already around. From this perspective , you can only use older languages. The benchmarks show that Lua (and the Luau and Lua+JIT variants) is actually very competitive, so I'd stick with one of those.",
    "parent": 44857448,
    "depth": 2
  },
  {
    "id": 44857479,
    "by": "01HNNWZ0MV43FF",
    "timeISO": "2025-08-10T19:15:33.000Z",
    "textPlain": "In the end, weight is a kind of strength, and popularity is a kind of quality. It looks promising but you can't expect long-term support until there's more contributors and usersAt this point it is too early to know. Even JavaScript took like 20 years to catch on",
    "parent": 44857448,
    "depth": 2
  },
  {
    "id": 44857249,
    "by": "beariish",
    "timeISO": "2025-08-10T18:39:09.000Z",
    "textPlain": "As of right now no - my primary target when developing this was realtime and games in particular since that's what I know best, but if there's a real target in embedded that's certainly something that could be explored.",
    "parent": 44857233,
    "depth": 2
  },
  {
    "id": 44857885,
    "by": "IshKebab",
    "timeISO": "2025-08-10T20:06:24.000Z",
    "textPlain": "It's compiled in the same way that Lua is compiled. So yes, it can replace Lua.",
    "parent": 44857827,
    "depth": 2
  },
  {
    "id": 44857873,
    "by": "beariish",
    "timeISO": "2025-08-10T20:04:41.000Z",
    "textPlain": "Bolt is not compiled ahead of time, it's bytecode interpreted just like Lua",
    "parent": 44857827,
    "depth": 2
  },
  {
    "id": 44857372,
    "by": "beariish",
    "timeISO": "2025-08-10T18:59:25.000Z",
    "textPlain": "There's nothing stopping a library author from explicitly annotating return types wherever a stable interface is important, the idea is more for smaller functions or callbacks to make use of this. Perhaps I'll make the examples clearer to reflect the intention.",
    "parent": 44857326,
    "depth": 2
  },
  {
    "id": 44858844,
    "by": "jitl",
    "timeISO": "2025-08-10T22:28:19.000Z",
    "textPlain": "It’s great in TypeScript. In TypeScript your source can have inferred types returned, and then use a build step to produce resolved typings files (.d.ts) for distribution that have the fully specified type.",
    "parent": 44857326,
    "depth": 2
  }
]
[
  {
    "id": 44857985,
    "by": "haberman",
    "timeISO": "2025-08-10T20:19:51.000Z",
    "textPlain": "I love the concept -- I've often wished that lean languages like Lua had more support for static typing, especially given the potential performance benefits.I also love the focus on performance.  I'm curious if you've considered using a tail call design for the interpreter.  I've found this to be the best way to get good code out of the compiler: https://blog.reverberate.org/2021/04/21/musttail-efficient-i...  Unfortunately it's not portable to MSVC.In that article I show that this technique was able to match Mike Pall's hand-coded assembly for one example he gave of LuaJIT's interpreter.  Mike later linked to the article as a new take for how to optimize interpreters: https://github.com/LuaJIT/LuaJIT/issues/716#issuecomment-854...Python 3.14 also added support for this style of interpreter dispatch and got a modest performance win from it: https://blog.reverberate.org/2025/02/10/tail-call-updates.ht...",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858071,
    "by": "perlgeek",
    "timeISO": "2025-08-10T20:31:43.000Z",
    "textPlain": "I like 99% of this, and the thing I don't like is in the very first line of the example:> import abs, epsilon from mathIMHO it's wrong to put the imported symbols first, because the same symbol could come from two different libraries and mean different things. So the library name is pretty important, and putting it last (and burying it after a potentially long list of imported symbols) just feels wrong.I get that it has a more natural-language vibe this way, but put there's a really good reason that most of the languages I know that put the package/module name first:    import packageName.member; // java\n    from package import symbol; # python\n    use Module 'symbol'; # perl\n    \nWith Typescript being the notable exception:    import { pi as π } from \"./maths.js\";t",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857304,
    "by": "MobiusHorizons",
    "timeISO": "2025-08-10T18:48:35.000Z",
    "textPlain": "FYI \"the embedded scene\" is likely to be interpreted as \"embedded systems\" rather than \"embedded interpreters\" even by people who know about embedded interpreters, especially since all the languages you give as an example have been attempted for use on those targets (micropython, lua, and even typescript)",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44859665,
    "by": "conaclos",
    "timeISO": "2025-08-11T00:21:14.000Z",
    "textPlain": "I was quite excited by the description and then I noted that Bolt heavily relies on double floating point numbers. I am quite disappointed because this doesn't allow me to use Bolt in my context: embedded systems where floating point numbers are rarely supported... So I realized that I misinterpreted `embedded`.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44861128,
    "by": "megapoliss",
    "timeISO": "2025-08-11T06:00:53.000Z",
    "textPlain": "Run some examples, and it looks like this \"High-performance, real-time optimized, super-fast\" language is  ~ 10 times slower than luajit\n  ~ 3 times slower than lua 5.4",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44862989,
    "by": "eqvinox",
    "timeISO": "2025-08-11T11:25:14.000Z",
    "textPlain": "Why repeat JavaScript's mistake of having all numbers be floats, with no integer type? I thought that one's well known by now :(",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44860758,
    "by": "banginghead",
    "timeISO": "2025-08-11T04:28:19.000Z",
    "textPlain": "This looks so familiar that it got me thinking: who is collating all of the languages that are being invented? I must see two dozen a year on HN. I'm not dissing OP, but I've seen so many languages I'm not sure if I'm having deja vu, or vuja de.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44859571,
    "by": "JonChesterfield",
    "timeISO": "2025-08-11T00:00:31.000Z",
    "textPlain": "Outperforming languages in its class is doing some heavy lifting here. Missing comparison to wasm interpreter, any of the java or dot net interpreters, the MLs, any lisps etc.Compile to register bytecode is legitimate as a strategy but its not the fast one, as the author knows, so probably shouldn't be branding the language as fast at this point.It might be a fast language. Hard to tell from a superficial look, depends on how the type system, alias analysis and concurrency models interact. It's not a fast implementation at this point.> This means functions do not need to dynamically capture their imports, avoiding closure invocations, and are able to linearly address them in the import array instead of making some kind of environment lookup.That is suspect, could be burning function identifiers into the bytecode directly, not emitting lookups in a table.Likewise the switch on the end of each instruction is probably the wrong thing, take a look at a function per op, forced tailcalls, with the interpreter state in the argument registers of the machine function call. There's some good notes on that from some wasm interpreters, and some context on why from luajit if you go looking.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44862995,
    "by": "npn",
    "timeISO": "2025-08-11T11:25:48.000Z",
    "textPlain": "I don't understand why people still choose the syntax `import xxx from yyy` in the current year.\nIt is a major source of complaining for languages like python or javascript, because it makes autocomplete does not work well.make me instantly lost interest in the language.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857819,
    "by": "cookiengineer",
    "timeISO": "2025-08-10T19:59:05.000Z",
    "textPlain": "If functions don't have a return signature, does that mean everything must be satisfied in the compilation step?What about memory management/ownership? This would imply that everything must be copy by value in each function callsite, right? How to use references/pointers? Are they supported?I like the matchers which look similar to Rust, but I dislike the error handling because it is neither implicit, and neither explicit, and therefore will be painful to debug in larger codebases I'd imagine.Do you know about Koka? I don't like its syntax choices much but I think that an effect based error type system might integrate nicely with your design choices, especially with matchers as consumers.[1] https://koka-lang.github.io/koka/doc/index.html",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857208,
    "by": "themonsu",
    "timeISO": "2025-08-10T18:31:32.000Z",
    "textPlain": "Looks cool, but please can we stop naming things ”bolt”",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44862125,
    "by": "tekkk",
    "timeISO": "2025-08-11T09:01:11.000Z",
    "textPlain": "Really impressive, great job! I was interested to see how you had solved Result type and that seems quite developer-friendly—no wrappers just value & error union. I should try it out to see how it's to write if I can run it on ARM64. I wish Godot Script looked like this.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858260,
    "by": "freeopinion",
    "timeISO": "2025-08-10T21:04:32.000Z",
    "textPlain": "I see your benchmarks compare against other interpreted languages \"in its class\".We read here a couple days ago about Q which is compiled. Bolt claims to \"plow through code at over 500kloc/thread/second\". Q claims to compile in milliseconds--so fast that you can treat it like a script.Bolt and Q are both newborns. Perhaps you could include each other in your benchmarks to give each other a little publicity.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44860277,
    "by": "slmjkdbtl",
    "timeISO": "2025-08-11T02:29:22.000Z",
    "textPlain": "Wow a fast scripting language with normal syntax and type checking.. Really hope this can take off and be a valid Lua alternative.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44863105,
    "by": "sureglymop",
    "timeISO": "2025-08-11T11:41:31.000Z",
    "textPlain": "Super cool! Just now I am building something where I am trying to use mlua to make it scriptable with Lua. But the biggest pain point right now is trying to generate type annotations for LuaLS based on my rust structs. I will look into whether bolt could be interesting for the project.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44860755,
    "by": "wk_end",
    "timeISO": "2025-08-11T04:27:54.000Z",
    "textPlain": "I might be missing this, but I'm not seeing anything about how the type system handles (or doesn't) polymorphism - generics, traits, that sort of thing. Is that in there?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44862007,
    "by": "Warwolt",
    "timeISO": "2025-08-11T08:42:31.000Z",
    "textPlain": "Looks nice! Is there any plans on a language server and formatting tooling?Usually I feel like that's bare minimum before I'd like to try and play around with a language",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858932,
    "by": "memophysic",
    "timeISO": "2025-08-10T22:40:52.000Z",
    "textPlain": "Looks great, I'm especially a fan of the more C and Python syntax. Lua works, but its syntax has always been bugging me.On the feature side, is there any support for breakpoints or a debugging server, and if not is it planned?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858159,
    "by": "Fraterkes",
    "timeISO": "2025-08-10T20:49:47.000Z",
    "textPlain": "Really cool! Roughly how much memory does it take to include it in an engine? Also I'm really interested in the process of creating these really fast scripting languages, have you written anything about how you wrote Bolt?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44859122,
    "by": "tayistay",
    "timeISO": "2025-08-10T23:01:37.000Z",
    "textPlain": "Congrats! I think this could be quite useful for me.I noticed that `let`-declared variables seem to be mutable. I'd strongly recommend against that. Add a `var` keyword.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44860225,
    "by": "je42",
    "timeISO": "2025-08-11T02:17:20.000Z",
    "textPlain": "Nice language! I am wondering how error handling / exceptions works in bolt?Quickly scanned the programming guide - but wasn't able to find it. Did i miss a section?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858854,
    "by": "astatine",
    "timeISO": "2025-08-10T22:30:14.000Z",
    "textPlain": "This looks awesome. Would you have any data on the performance of large number of invocations of small scripts? I am wondering at startup overhead for every script run. which the 500kloc/s may not capture well.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44859220,
    "by": "merksoftworks",
    "timeISO": "2025-08-10T23:11:45.000Z",
    "textPlain": "This is really cool but it's not portable to MacOs or aarm64 yet, and that kind of portability unfortunately is what appeals to me about an embeddable scripting language.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857984,
    "by": "kiririn",
    "timeISO": "2025-08-10T20:19:22.000Z",
    "textPlain": "Nice, gives me Pawn vibes(https://www.compuphase.com/pawn/pawn.htm)",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44860202,
    "by": "capyba",
    "timeISO": "2025-08-11T02:11:56.000Z",
    "textPlain": "In terms of performance, how does it compare to compiled languages like the C it’s written in?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858184,
    "by": "Forgret",
    "timeISO": "2025-08-10T20:53:45.000Z",
    "textPlain": "It looks cool, I wish you luck in developing the language. I liked your language and I hope it becomes popular someday.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857448,
    "by": "eulgro",
    "timeISO": "2025-08-10T19:09:42.000Z",
    "textPlain": "The question I ask myself when I see this kind of project is: how long are you willing to maintain it for?My main concern about a new language is not performance, syntax, or features, but long term support and community.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857233,
    "by": "grodriguez100",
    "timeISO": "2025-08-10T18:36:24.000Z",
    "textPlain": "Sounds very good, and I can see many use cases in embedded systems. But that probably requires 32-bit arm support. Is that planned ?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857827,
    "by": "Vandash",
    "timeISO": "2025-08-10T19:59:56.000Z",
    "textPlain": "game dev for 15+ years here, love the first example on Github\nthis is compiled right? cannot replace lua?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857211,
    "by": "acron0",
    "timeISO": "2025-08-10T18:32:07.000Z",
    "textPlain": "If I was still writing games I would be alllllll over this",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44857326,
    "by": "thrance",
    "timeISO": "2025-08-10T18:52:14.000Z",
    "textPlain": "Function return type inference is funny but I don't think it's that great of a feature. It makes it harder for a library's consumer to know how to properly use a function, and it also makes it harder for the maintainer to not break backwards compatibility inadvertently. Anyway, I'm all for experimenting.",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858568,
    "by": "k__",
    "timeISO": "2025-08-10T21:43:03.000Z",
    "textPlain": "Awesome.Is it deterministic like Lua?",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44863639,
    "by": "boffinAudio",
    "timeISO": "2025-08-11T13:02:56.000Z",
    "textPlain": "Very cute language ..     match x {\n        is table {\n            print(indent_this + \"{\")\n            for pair in pairs(x) {\n                write(indent + \"   \" + to_string(pair.key) + \": \") \n                pretty_print_internal(pair.value, indent + \"   \", false)\n            }\n            print(indent + \"}\")\n        }\n\n.. okay, you got my attention (long-time Lua fan) .. will have to give this some workbench time and learn it ..",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44862745,
    "by": "amai",
    "timeISO": "2025-08-11T10:38:02.000Z",
    "textPlain": "[flagged]",
    "parent": 44856935,
    "depth": 1
  },
  {
    "id": 44858761,
    "by": "debugnik",
    "timeISO": "2025-08-10T22:14:03.000Z",
    "textPlain": "You may be interested in Luau, which is the gradually-typed dialect of Lua maintained by Roblox. The game Alan Wake 2 also used it for level scripting.",
    "parent": 44857985,
    "depth": 2
  },
  {
    "id": 44858028,
    "by": "beariish",
    "timeISO": "2025-08-10T20:25:05.000Z",
    "textPlain": "I did experiment with a few different dispatch methods before settling on the one in Bolt now, though not with tailcalls specifically. The approach I landed on was largely chosen cause it in my testing competes with computed goto solutions while also compiling on msvc, but I'm absolutely open to try other things out.",
    "parent": 44857985,
    "depth": 2
  },
  {
    "id": 44858121,
    "by": "summerwant",
    "timeISO": "2025-08-10T20:42:32.000Z",
    "textPlain": "I see lua, do you know terralang?",
    "parent": 44857985,
    "depth": 2
  },
  {
    "id": 44858495,
    "by": "jasonjmcghee",
    "timeISO": "2025-08-10T21:34:05.000Z",
    "textPlain": "Also autocomplete.Though I almost never manually type out imports manually anymore.",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44858476,
    "by": "bbkane",
    "timeISO": "2025-08-10T21:30:04.000Z",
    "textPlain": "I really like the way Elm does it, from \"wide\" (package) to \"narrow\" (symbol). I suspect this also helps language server implementation.See https://guide.elm-lang.org/webapps/modules (scroll down to \"Using Modules\") for examples",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44858126,
    "by": "beariish",
    "timeISO": "2025-08-10T20:43:16.000Z",
    "textPlain": "Do you think approaching the way typescript does it for Bolt is a reasonable compromise here? Bolt already supports full-module renames like    import math as not_math\n\nSo supporting something along the lines of    import abs as absolute, sqrt as square_root from math\n\nWould be farily simple to accomplish.",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44859048,
    "by": "vhodges",
    "timeISO": "2025-08-10T22:54:32.000Z",
    "textPlain": "According to the Programming Guide, it supports aliases for imports\"In case of conflict or convenience, you can give modules an alias as well.\"",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44860622,
    "by": "Tokumei-no-hito",
    "timeISO": "2025-08-11T03:51:38.000Z",
    "textPlain": "can't the compiler process it in reverse?",
    "parent": 44858071,
    "depth": 2
  },
  {
    "id": 44857347,
    "by": "beariish",
    "timeISO": "2025-08-10T18:56:01.000Z",
    "textPlain": "That's a good point, thank you. I've made a small edit to clarify.",
    "parent": 44857304,
    "depth": 2
  },
  {
    "id": 44860409,
    "by": "RossBencina",
    "timeISO": "2025-08-11T02:55:10.000Z",
    "textPlain": "True. I misread it as being for embedded, especially with the term \"real-time\" in the mix. Then later when there was no ARM or RISC-V support I became very confused.",
    "parent": 44857304,
    "depth": 2
  },
  {
    "id": 44860241,
    "by": "devmor",
    "timeISO": "2025-08-11T02:21:32.000Z",
    "textPlain": "Same here! It's very cool but my ideal use case would be on a limited ISA architecture like ESP32.",
    "parent": 44859665,
    "depth": 2
  },
  {
    "id": 44861895,
    "by": "jeroenhd",
    "timeISO": "2025-08-11T08:24:41.000Z",
    "textPlain": "Not bad for version 0.1.0. lua(jit) is no slowpoke and has had decades of performance improvements.",
    "parent": 44861128,
    "depth": 2
  },
  {
    "id": 44862796,
    "by": "johnisgood",
    "timeISO": "2025-08-11T10:47:29.000Z",
    "textPlain": "With this and https://github.com/Beariish/bolt/blob/main/doc/Bolt%20Perfor..., it is indeed confusing without testing it out myself.That said, somehow I do not believe it is faster than LuaJIT. We will see.",
    "parent": 44861128,
    "depth": 2
  },
  {
    "id": 44862793,
    "by": "amai",
    "timeISO": "2025-08-11T10:47:16.000Z",
    "textPlain": "Where do you get these numbers from? Looking at https://github.com/Beariish/bolt/blob/main/doc/Bolt%20Perfor... doesn’t seem to support these numbers.",
    "parent": 44861128,
    "depth": 2
  },
  {
    "id": 44864228,
    "by": "ModernMech",
    "timeISO": "2025-08-11T14:07:30.000Z",
    "textPlain": "They at least clarified it by saying \"outperforming other languages in its class\". It's a slow class so the bar is low.",
    "parent": 44861128,
    "depth": 2
  },
  {
    "id": 44859894,
    "by": "phire",
    "timeISO": "2025-08-11T01:15:53.000Z",
    "textPlain": "The class is \"embeddable interpreted scripting language\", which is not quite the same thing as just an interpreter.Embedded interpreters are that designed to be embedded into a c/c++ program (often a game) as a scripting language. They typically have as few dependencies as possible, try to be lightweight and focus on making it really easy to interopt between contexts.The comparison hits many of the major languages for this usecase. Though it probably should have included mono's interpreter mode, even if nobody really uses it since mono got AoT",
    "parent": 44859571,
    "depth": 2
  }
]
[
  {
    "id": 44898707,
    "by": "meindnoch",
    "timeISO": "2025-08-14T10:09:09.000Z",
    "textPlain": "@on user\n  > onAskAboutConvoLang() -> (\n      if(??? (+ boolean /m last:3 task:Inspecting message)\n          Did the user ask about Convo-Lang in their last message\n      ???) then (\n  \n          @ragForMsg public/learn-convo\n          ??? (+ respond /m task:Generating response about Convo-Lang)\n              Answer the users question using the following information about Convo-Lang\n          ???\n      )\n  )\n  \n  > user\n\nWho in their right mind would come up with such a \"syntax\"? An LLM?",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897422,
    "by": "Disposal8433",
    "timeISO": "2025-08-14T06:44:05.000Z",
    "textPlain": "The new COBOL. The next step is obviously to add syntax when you need to specify the type of the variables: put the type first, then the name and its value, and finish with a semicolon because it's fun, like \"int n = 0;\"",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44898938,
    "by": "brabel",
    "timeISO": "2025-08-14T10:53:01.000Z",
    "textPlain": "I like it. Much nicer than having to use some python SDK in my opinion. Is this a standalone language or it requires Python or other languages to run it?",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44898528,
    "by": "zuzuen_1",
    "timeISO": "2025-08-14T09:38:02.000Z",
    "textPlain": "Perhaps when LLMs introduce a lot more primitives for modifying behvavior such a programming language would be necessary.As such for anyone working with LLMs, they know most of the work happens before and after the LLM call, like doing REST calls, saving to database, etc. Conventional programming languages work well for that purpose.Personally, I like JSON when the data is not too huge. Its easy to read (since it is hierarchical like most declarative formats) and parse.",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897913,
    "by": "brainless",
    "timeISO": "2025-08-14T07:59:48.000Z",
    "textPlain": "I have thought of this issue quite a few times. I use Claude Code, Gemini CLI, etc. for all my new projects. Each of the typical CLAUDE.md/GEMINI.md file exists. I do not use MCPs. I ask agents to use `gh` command, all my work happens around Git/GitHub.But text is just that, while scripts are easier to rely on. I can prompt and document all mechanisms to, say, check code format. But once I add something, say a pre-commit hook, it becomes reliable.I am looking for a human readable (maybe renderable) way to codify patterns.",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44898751,
    "by": "swoorup",
    "timeISO": "2025-08-14T10:16:01.000Z",
    "textPlain": "Money Incinerator Lang would be fitting name as well.",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897781,
    "by": "khalic",
    "timeISO": "2025-08-14T07:39:59.000Z",
    "textPlain": "Cool concept that brings a little structure to prompts. I wouldn't use the semantic part that much, English is fine for this, but there is a real need for machine instructions. There is no need for an LLM guess if \"main\" is a function or a file for exemple.",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897863,
    "by": "trehans",
    "timeISO": "2025-08-14T07:51:25.000Z",
    "textPlain": "I'm not sure what this is about, would anyone mind ELI5?",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897142,
    "by": "benswerd",
    "timeISO": "2025-08-14T05:51:11.000Z",
    "textPlain": "How do you think about remote configurability?Stuff like a lot of this needing to be A/B tested, models hot swapped, and versioned in a way thats accessible to non technical people?How do you think about this in relation to tools like BAML?",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897143,
    "by": "yewenjie",
    "timeISO": "2025-08-14T05:51:16.000Z",
    "textPlain": "What is a motivating use case that this solves?",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897282,
    "by": "machiaweliczny",
    "timeISO": "2025-08-14T06:20:01.000Z",
    "textPlain": "Why not library?",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897391,
    "by": "mrs6969",
    "timeISO": "2025-08-14T06:39:10.000Z",
    "textPlain": "Nice try. We will eventually get there, but I think this can and need to get better.",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897283,
    "by": "croes",
    "timeISO": "2025-08-14T06:20:09.000Z",
    "textPlain": "Next step, an LLM that writes convo-lang programs to programs with an LLM",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897270,
    "by": "bn-l",
    "timeISO": "2025-08-14T06:18:29.000Z",
    "textPlain": "It’s a noisy / busy syntax. Just my own opinion.",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897473,
    "by": "devops000",
    "timeISO": "2025-08-14T06:53:29.000Z",
    "textPlain": "Why not as a library in Ruby or Python?",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897833,
    "by": "dmundhra",
    "timeISO": "2025-08-14T07:47:09.000Z",
    "textPlain": "How is it different than DSPy?",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44897296,
    "by": "gnubee",
    "timeISO": "2025-08-14T06:21:55.000Z",
    "textPlain": "This looks a lot like another effective way of interacting with LLMs: english-lang. Some of english-lang 's features are that it can be used to convey meaning, and it's largely accepted (network effect!). I'm excited to see what convo brings to the table /s",
    "parent": 44897098,
    "depth": 1
  },
  {
    "id": 44899851,
    "by": "ljm",
    "timeISO": "2025-08-14T12:58:14.000Z",
    "textPlain": "… I think I’ll just stick with pydantic AI for now",
    "parent": 44898707,
    "depth": 2
  },
  {
    "id": 44899408,
    "by": "lnenad",
    "timeISO": "2025-08-14T12:03:39.000Z",
    "textPlain": "I have to agree, it looks wild, even the simpler examples don't feel ergonomic.",
    "parent": 44898707,
    "depth": 2
  },
  {
    "id": 44899299,
    "by": "taneq",
    "timeISO": "2025-08-14T11:50:08.000Z",
    "textPlain": "COBOL ? Hurrah! If there’s anything that would improve vibe coding, it’s a “come from“ statement. :P",
    "parent": 44897422,
    "depth": 2
  },
  {
    "id": 44898641,
    "by": "zuzuen_1",
    "timeISO": "2025-08-14T09:59:30.000Z",
    "textPlain": "One pain point such a PL could address is encoding tribal knowledge about optimal prompting strategies for various LLMs, which changes with each new model release.",
    "parent": 44898528,
    "depth": 2
  },
  {
    "id": 44898863,
    "by": "xwowsersx",
    "timeISO": "2025-08-14T10:41:02.000Z",
    "textPlain": "Not sure I'm sold on this particular implementation, but here's my best steelman: working with LLMs through plain text prompts can be brittle...tiny wording changes can alter outputs, context handling is improvised, and tool integration often means writing one-off glue code. This is meant to be DSL to  add structure: break workflows into discrete steps, define vars, manage state, explicitly control when and how the model acts, and so on.It basically gives you a formal syntax for orchestrating multi-turn LLM interactions, integrating tool calls + managing context in a predictable, maintainable way...essentially trying being some structure to \"prompt engineering\" and make it a bit more like a proper, composable programming discipline/model.Something like that.",
    "parent": 44897863,
    "depth": 2
  },
  {
    "id": 44897295,
    "by": "otabdeveloper4",
    "timeISO": "2025-08-14T06:21:43.000Z",
    "textPlain": "Riding the LLM hype train to its exhaustion.",
    "parent": 44897143,
    "depth": 2
  },
  {
    "id": 44898890,
    "by": "xwowsersx",
    "timeISO": "2025-08-14T10:45:17.000Z",
    "textPlain": "I haven't used DSPy this much, but as I understand it: this lang is more like an orchestration DSL for writing and running LLM conversations and tools, whereas DSPy is a  framework that compiles and optimizes LLM programs into better-performing prompts...like DSPy has automatic improvement of pipelines using its compilers/optimizers. With DSPy you deal with modules and signatures.",
    "parent": 44897833,
    "depth": 2
  },
  {
    "id": 44898484,
    "by": "ttoinou",
    "timeISO": "2025-08-14T09:29:52.000Z",
    "textPlain": "You're absolutely right!",
    "parent": 44897296,
    "depth": 2
  }
]
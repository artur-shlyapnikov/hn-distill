[
  {
    "id": 44874758,
    "by": "throw0101c",
    "timeISO": "2025-08-12T11:08:50.000Z",
    "textPlain": "TeX has a default of 66 characters per line. There's been research on this:> Traditional line length research, limited to print-based text, gave a variety of results, but generally for printed text it is widely accepted that line lengths fall between 45 and 75 characters per line (cpl), though the ideal is 66 cpl (including letters and spaces).[1] For conventional books line lengths tend to be 30 times the size of the type, but between 20 and 40 times is considered acceptable (i.e., 30 × 10pt font = 300 pt line).[1]* https://en.wikipedia.org/wiki/Line_length#Printed_textThere's a section of \"electronic text\" as well which goes into some factors (flicker, glare), but the number doesn't seem to change that much.* https://webtypography.net/2.1.2",
    "parent": 44839776,
    "depth": 1
  },
  {
    "id": 44874817,
    "by": "camgunz",
    "timeISO": "2025-08-12T11:16:25.000Z",
    "textPlain": "Whenever I find myself trapped in one of these arguments, I discover pretty quickly that the difference between me (an 80 cols person) and my adversary (someone much stupider) is that they're using 1 big beautiful buffer, and I have 6-8 columns of buffers side-by-side. To which I say: we both want the same things! We both want to use as much of these ridiculously wide monitors as we can. I'm doing it much better than you are. Come on in, the water is warm. :vsplit with me",
    "parent": 44839776,
    "depth": 1
  },
  {
    "id": 44874710,
    "by": "theshrike79",
    "timeISO": "2025-08-12T11:01:30.000Z",
    "textPlain": "I massively agree with tools like black and gofmt.\"Gofmt's style is no one's favorite, yet gofmt is everyone's favorite.\"We need more of the same, I really wish C# had a similar opinionated tool I could use to bring dozens of company projects in line.Something that can be run locally and in CI and has ZERO configuration, it just enforces a static style with no possibility of bikeshedding.",
    "parent": 44839776,
    "depth": 1
  },
  {
    "id": 44874598,
    "by": "llimos",
    "timeISO": "2025-08-12T10:43:44.000Z",
    "textPlain": "It would seem that the optimal solution to both maintain readability and not waste screen space would be to start counting the characters from after the indentation.\nSince indentation is stepped, you won't (often) be jumping massive horizontal distances.",
    "parent": 44839776,
    "depth": 1
  },
  {
    "id": 44874726,
    "by": "dvh",
    "timeISO": "2025-08-12T11:03:53.000Z",
    "textPlain": "0.618 * screen width",
    "parent": 44839776,
    "depth": 1
  },
  {
    "id": 44874715,
    "by": "philipallstar",
    "timeISO": "2025-08-12T11:02:02.000Z",
    "textPlain": "> The problem with this argument is the same as the argument against “but tabs are semantic indentation”, to wit: nope, no it isn’t.Nit: to whit",
    "parent": 44839776,
    "depth": 1
  },
  {
    "id": 44874846,
    "by": "camgunz",
    "timeISO": "2025-08-12T11:19:46.000Z",
    "textPlain": "To everyone's detriment, gofmt doesn't wrap lines. That's why--combined with the truly evil entrenchment of tabs--lines in Go code tend to be ridiculously long. I'm not saying it's an easy problem (my info comes from Bob Nystrom's post [0] on it), but I do think it's table stakes for a formatter.[0]: https://journal.stuffwithstuff.com/2015/09/08/the-hardest-pr...",
    "parent": 44874710,
    "depth": 2
  },
  {
    "id": 44874782,
    "by": "camgunz",
    "timeISO": "2025-08-12T11:11:44.000Z",
    "textPlain": "I googled \"to whit vs. to wit\" and can't find anything that substantiates this. I think \"to wit\" is actually correct.",
    "parent": 44874715,
    "depth": 2
  }
]
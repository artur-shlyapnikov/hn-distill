[
  {
    "id": 44904058,
    "by": "Night_Thastus",
    "timeISO": "2025-08-14T18:42:34.000Z",
    "textPlain": "I am extremely interested in this.I am stuck in an environment with CMake, GCC and Unix Make (no clang, no ninja) and getting detailed information about WHY the build is taking so long is nearly impossible.It's also a bit of a messy build with steps like copying a bunch of files from the source into the build folder. Multiple languages (C, C++, Fortran, Python), custom cmake steps, etc.If this tool can handle that kind of mess, I'll be very interested to see what I can learn.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44906817,
    "by": "Mawr",
    "timeISO": "2025-08-14T23:11:27.000Z",
    "textPlain": "Suggestion to the blog author - put:> Here it is recording the build of a macOS app:> <gif>At the top of the page, it should be right under the header.You made a thing, so show the thing. You can waffle on about  it later. Just show the thing.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905224,
    "by": "entelechy",
    "timeISO": "2025-08-14T20:22:40.000Z",
    "textPlain": "Love it!\nWe did something similar using strace/dtruss back in 2018 with https://buildinfer.loopperfect.com/ and were generating graphs (using eg. graphviz and perfetto.dev) and BUCK files on the back of thatWhilst we regrettably never came around to package it as a propper product, we found it immensly valuable in our consulting work, to pinpoint issues and aid the conversion to BUCK/Bazel.\nWe used graphviz, https://perfetto.dev/ and couple other tools to visualise thingsRecently we cicled back to this too but with a broader usecase in mind.There are some inherent technical challanges with this approach & domain:- syscall logs can get huge - especially when saved to disk. Our strace logs would get over 100GB for some projects (llvm was around ~50GB)- some projects also use https and inter process communications and that needs ot be properly handled too. (We even had a customer that was retriving code from a firebird database via perl as part of the compilation step!)- It's runtime analysis - you might need to repeat the analysis for each configuration.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44903723,
    "by": "bgirard",
    "timeISO": "2025-08-14T18:11:47.000Z",
    "textPlain": "That's really cool. Fascinating to think about all the problems that get missed due to poor or missing visualizations like this.I did a lot of work to improve the Mozilla build system a decade ago where I would have loved this tool. Wish they would have said what problem they found.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44908042,
    "by": "bdash",
    "timeISO": "2025-08-15T02:38:22.000Z",
    "textPlain": "I've had success using https://github.com/nico/ninjatracing along with Clang's `-ftime-trace` to visualize the build performance of a C++ project using CMake. https://github.com/aras-p/ClangBuildAnalyzer helps further break down what the compiler is spending its time on.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905883,
    "by": "tom_",
    "timeISO": "2025-08-14T21:25:53.000Z",
    "textPlain": "If you use the Visual C++ compiler on Windows, vcperf is worth a look: https://github.com/microsoft/vcperf - comes with VS2022, or you can build from github.I've used it with projects generated by UBT and CMake. I can't remember if it provides any info that'd let you assess the quality of build parallelism, but it does have some compiler front end info which is pretty straightforward to read. Particularly expensive headers (whether inherently so, or just because they're included a lot) are easy to find.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44909854,
    "by": "torarnv",
    "timeISO": "2025-08-15T08:23:19.000Z",
    "textPlain": "Awesome!! Are you planning to open source this? I’ve been working on something similar and would love to join forces!",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904365,
    "by": "boris",
    "timeISO": "2025-08-14T19:09:19.000Z",
    "textPlain": "> It also has 6 seconds of inactivity before starting any useful work. For comparison, ninja takes 0.4 seconds to start compiling the 2,468,083 line llvm project. Ninja is not a 100% fair comparison to other tools, because it benefits from some “baked in” build logic by the tool that created the ninja file, but I think it’s a reasonable “speed of light” performance benchmark for build systems.This is an important observation that is often overlooked. What’s more, the changes to the information on which this “baked in” build logic is based is not tracked very precisely.How close can we get to this “speed of light” without such “baking in”? I ran a little benchmark (not 100% accurate for various reasons but good enough as a general indication) which builds the same project (Xerces-C++) both with ninja as configured by CMake and with build2, which doesn’t require a separate step and does configuration management as part of the build (and with precise change tracking). Ninja builds this project from scratch in 3.23s while build2 builds it in 3.54s. If we omit some of the steps done by CMake (like generating config.h) by not cleaning the corresponding files, then the time goes down to 3.28s. For reference, the CMake step takes 4.83s. So a fully from-scratch CMake+ninja build actually takes 8s, which is what you would normally pay if you were using this project as a dependency.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44908721,
    "by": "saagarjha",
    "timeISO": "2025-08-15T04:45:21.000Z",
    "textPlain": "I've done something similar by running Instruments during the build, which not only tells me which processes are running when but also what they're doing. Unfortunately Instruments gets upset if your build takes a long time, and it doesn't really allow filtering by process tree, but it helped shipped several major wins for our builds when I was working on Twitter's iOS codebase. Alas trying to this these days will not work because Instrument's \"All Processes\" tracing has been broken for a while (FB14533747).",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904124,
    "by": "aanet",
    "timeISO": "2025-08-14T18:48:54.000Z",
    "textPlain": "This is fabulous!!Is there a version available for MacOS today??  I'd love to give it a whirl... For Rust, C++ / Swift and other stuff.Thanks!",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44912146,
    "by": "terabytest",
    "timeISO": "2025-08-15T13:26:15.000Z",
    "textPlain": "It looks really nice. I wonder if it’d be possible to break it down even further by somehow instrumenting the actual processes and including their execution flame graphs as part of the chart. That would expose a ton of extra information about the large gaps of “inactivity”.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44909638,
    "by": "pjmlp",
    "timeISO": "2025-08-15T07:44:23.000Z",
    "textPlain": "Great piece of work.Without trying to devalue it, note that VS and XCode have similar visualization tools.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44914274,
    "by": "lsuresh",
    "timeISO": "2025-08-15T16:22:15.000Z",
    "textPlain": "Would love to have our team try this out (we have some ridiculous rust builds).",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44907773,
    "by": "JackYoustra",
    "timeISO": "2025-08-15T01:49:40.000Z",
    "textPlain": "For anyone using xcode: there's a builtin button to show a visualization for a build (not realtime afaik) for it too.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44906295,
    "by": "audiofish",
    "timeISO": "2025-08-14T22:10:51.000Z",
    "textPlain": "Really cool tool, but perhaps not for the original use-case. I often find myself trying to figure out what call tree a large Bash script creates, and this looks like it visualises it well.This would have been really useful 6 months ago, when I was trying to figure out what on earth some Jetson tools actually did to build and flash an OS image.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44909378,
    "by": "tempodox",
    "timeISO": "2025-08-15T07:00:25.000Z",
    "textPlain": "I would be interested and even pay for it, but I am not a joiner.  And I don't want Google to know any of my email addresses.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44903835,
    "by": "xuhu",
    "timeISO": "2025-08-14T18:22:44.000Z",
    "textPlain": "Is there a tool that records the timestamp of each executed command during a build, and when you rebuild, it tells you how much time is left instead of \"building obj 35 out of 1023\" ?Or (for cmake or ninja) use a CSV that says how long each object takes to build and use it to estimate how much is left ?",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904193,
    "by": "tiddles",
    "timeISO": "2025-08-14T18:54:55.000Z",
    "textPlain": "Nice, I’ve been looking for something like this for a while.I’ve noticed on my huge catkin cmake project that cmake is checking the existence of the same files hundreds of times too. Is there anything that can hook into fork() and provide a cached value after the first invocation?",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44903974,
    "by": "supportengineer",
    "timeISO": "2025-08-14T18:34:35.000Z",
    "textPlain": "Amazing!  Great job!What limits your tool to compiler/build tools, can it be used for any arbitrary process?",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44907033,
    "by": "epage",
    "timeISO": "2025-08-14T23:42:30.000Z",
    "textPlain": "How does this compare to `cargo check --timings`?It visualizes each crate's build, shows the dependencies between them, shows when the initial compilation is done that unblocks dependents, and soon will have link information.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44907175,
    "by": "rustystump",
    "timeISO": "2025-08-15T00:05:12.000Z",
    "textPlain": "10/10 this is very cool and the kind of hacking i come here for",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44908560,
    "by": "bitbasher",
    "timeISO": "2025-08-15T04:17:24.000Z",
    "textPlain": "This is cool, but for Rust you have `cargo build --timings` built in and has even more details.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44911022,
    "by": "emigre",
    "timeISO": "2025-08-15T11:28:25.000Z",
    "textPlain": "Really nice and interesting! Thanks!",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44907360,
    "by": "time4tea",
    "timeISO": "2025-08-15T00:32:25.000Z",
    "textPlain": "Then I hid it away.This is an ad not a helpful announcement.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44903970,
    "by": "corysama",
    "timeISO": "2025-08-14T18:34:24.000Z",
    "textPlain": "Looks like a general `fork()` visualizer to me. Which is great!",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44913177,
    "by": "secondcoming",
    "timeISO": "2025-08-15T14:52:41.000Z",
    "textPlain": "This looks awesome.I've used clang's -ftime-trace option in the past and that's also really good.\nIt's a pity gcc has nothing similar.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905818,
    "by": "proctorg76",
    "timeISO": "2025-08-14T21:19:53.000Z",
    "textPlain": "the parallels between tech and manufacturing never cease to amaze, this looks so much like the machine monitoring / execution system we use in the car parts plant I want to ask if you've calculated the TEEP and OEE of your build farm",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905111,
    "by": "CyberDildonics",
    "timeISO": "2025-08-14T20:13:17.000Z",
    "textPlain": "I love the visualization, I think it's great information and will be very helpful to whoever uses it.I would think about a different name. Often names are either meant to be funny or just unique nonsense but something short and elegantly descriptive (like BuildViz etc.) can go a long way to making it seem more legitimate and being more widely used.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904792,
    "by": "forrestthewoods",
    "timeISO": "2025-08-14T19:47:09.000Z",
    "textPlain": "This is great. I was skeptical from the title but the implementation is very clever. This could be a super super useful tool for the industry.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905841,
    "by": "Cloudef",
    "timeISO": "2025-08-14T21:21:58.000Z",
    "textPlain": "LLVM is taking its sweet time, brew coffee",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904182,
    "by": "mgaunard",
    "timeISO": "2025-08-14T18:54:12.000Z",
    "textPlain": "The real solution is to eliminate build systems where you have to define your own targets.Developers always get it wrong and do it badly.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905023,
    "by": "jeffbee",
    "timeISO": "2025-08-14T20:05:28.000Z",
    "textPlain": "This seems like a good place to integrate a Bazel Build Event Protocol stream consumer.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905844,
    "by": "mrlonglong",
    "timeISO": "2025-08-14T21:22:14.000Z",
    "textPlain": "Does it work with cmake?",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904968,
    "by": "kirito1337",
    "timeISO": "2025-08-14T20:00:58.000Z",
    "textPlain": "That's interesting.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904227,
    "by": "brcmthrowaway",
    "timeISO": "2025-08-14T18:58:02.000Z",
    "textPlain": "What about OSes that dont use fork()?",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44906116,
    "by": "metalliqaz",
    "timeISO": "2025-08-14T21:50:59.000Z",
    "textPlain": "Isn't `wtf` already a fairly common command?",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44903893,
    "by": "Surac",
    "timeISO": "2025-08-14T18:28:24.000Z",
    "textPlain": "but why? I have to admit it's a fun project",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904338,
    "by": "klik99",
    "timeISO": "2025-08-14T19:06:58.000Z",
    "textPlain": "Nice! Leaving a comment to easily find this later, dont have anything to add except this looks cool",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44909666,
    "by": "hagendaasalpine",
    "timeISO": "2025-08-15T07:50:46.000Z",
    "textPlain": "Tsoding wrote https://github.com/tsoding/nob.h, single header C library for cross platform builds, only requirement is cc. GDB profiling tools can then be used to look at your build step. It's a neat idea. I suspect this is not an option but Nix is great build tool if you are dealing with multiple languages.",
    "parent": 44904058,
    "depth": 2
  },
  {
    "id": 44905123,
    "by": "unddoch",
    "timeISO": "2025-08-14T20:14:22.000Z",
    "textPlain": "I wrote a little GCC plugin for compile time tracing/profiling, if that's something you're interested in: https://github.com/royjacobson/externis",
    "parent": 44904058,
    "depth": 2
  },
  {
    "id": 44910917,
    "by": "fransje26",
    "timeISO": "2025-08-15T11:15:43.000Z",
    "textPlain": "> I am stuck in an environment with CMake, GCC and Unix Make (no clang, no ninja) and getting detailed information about WHY the build is taking so long is nearly impossible.I have a similar problem, with a tangential question that I think about from time to time without really having the time to investigate it further, unfortunately.I notice sometimes that CMake recompiles files that shouldn't have been affected by the code changes made previously. Like recompiling some independent objects after only slight changes to a .cpp file without any interface changes.So I often wonder if CMake is not making some file more inter-dependent than what they are, leading to longer compilation times.",
    "parent": 44904058,
    "depth": 2
  },
  {
    "id": 44905637,
    "by": "phaedrus",
    "timeISO": "2025-08-14T21:00:20.000Z",
    "textPlain": "When I was trying to improve compile time for my game engine, I ended up using compiled size as a proxy measure.  Although it is an imperfect correlation, the fact that compiled size is deterministic across build runs and even across builds on different machines makes it easier to work with than wall clock time.",
    "parent": 44904058,
    "depth": 2
  },
  {
    "id": 44907128,
    "by": "1718627440",
    "timeISO": "2025-08-14T23:57:34.000Z",
    "textPlain": "Can you set CC=time gcc ?",
    "parent": 44904058,
    "depth": 2
  },
  {
    "id": 44907251,
    "by": "wakawaka28",
    "timeISO": "2025-08-15T00:15:44.000Z",
    "textPlain": "It's not \"nearly impossible\" but actually built in: https://cmake.org/cmake/help/latest/manual/cmake.1.html#cmdo... For the actual compile time you can easily insert a wrapper script. To be honest I haven't done that in over 4 years, but it has been done by many and it is easy.There may be times when CMake itself is the bottleneck but it is almost certainly an issue with your dependencies and so on. CMake has many features to assist you in speeding up your compile and link time too. But it would take a series of blog posts to describe how you should try to speed it up.",
    "parent": 44904058,
    "depth": 2
  },
  {
    "id": 44905796,
    "by": "pklausler",
    "timeISO": "2025-08-14T21:17:37.000Z",
    "textPlain": "strace might help, if you have it.",
    "parent": 44904058,
    "depth": 2
  },
  {
    "id": 44907589,
    "by": "dhooper",
    "timeISO": "2025-08-15T01:11:13.000Z",
    "textPlain": "Good suggestion. Updated.",
    "parent": 44906817,
    "depth": 2
  },
  {
    "id": 44909390,
    "by": "flakes",
    "timeISO": "2025-08-15T07:01:45.000Z",
    "textPlain": "Curious, what were you using for doing syscall logging? LD_PRELOAD tricks, or ebpf filtering?",
    "parent": 44905224,
    "depth": 2
  },
  {
    "id": 44903892,
    "by": "dhooper",
    "timeISO": "2025-08-14T18:28:19.000Z",
    "textPlain": "(OP here) Thanks!My call with the Mozilla engineer was cut short, so we didn't have time to go into detail about what he found, I want to look into it myself.",
    "parent": 44903723,
    "depth": 2
  },
  {
    "id": 44912437,
    "by": "muststopmyths",
    "timeISO": "2025-08-15T13:52:49.000Z",
    "textPlain": "Also Incredibuild. The free version is probably good enough to visualize your build and see any bottlenecks.",
    "parent": 44905883,
    "depth": 2
  },
  {
    "id": 44904160,
    "by": "dhooper",
    "timeISO": "2025-08-14T18:52:11.000Z",
    "textPlain": "I'll be sending out the a macOS version to another wave of beta users after I fix an outstanding issue, if you sign up (at bottom of article) and mention this comment I can make sure you're in that wave.",
    "parent": 44904124,
    "depth": 2
  }
]
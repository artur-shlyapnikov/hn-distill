[
  {
    "id": 44905818,
    "by": "proctorg76",
    "timeISO": "2025-08-14T21:19:53.000Z",
    "textPlain": "the parallels between tech and manufacturing never cease to amaze, this looks so much like the machine monitoring / execution system we use in the car parts plant I want to ask if you've calculated the TEEP and OEE of your build farm",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904058,
    "by": "Night_Thastus",
    "timeISO": "2025-08-14T18:42:34.000Z",
    "textPlain": "I am extremely interested in this.I am stuck in an environment with CMake, GCC and Unix Make (no clang, no ninja) and getting detailed information about WHY the build is taking so long is nearly impossible.It's also a bit of a messy build with steps like copying a bunch of files from the source into the build folder. Multiple languages (C, C++, Fortran, Python), custom cmake steps, etc.If this tool can handle that kind of mess, I'll be very interested to see what I can learn.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905224,
    "by": "entelechy",
    "timeISO": "2025-08-14T20:22:40.000Z",
    "textPlain": "Love it!\nWe did something similar using strace/dtruss back in 2018 with https://buildinfer.loopperfect.com/ and were generating graphs (using eg. graphviz and perfetto.dev) and BUCK files on the back of thatWhilst we regrettably never came around to package it as a propper product, we found it immensly valuable in our consulting work, to pinpoint issues and aid the conversion to BUCK/Bazel.\nWe used graphviz, https://perfetto.dev/ and couple other tools to visualise thingsRecently we cicled back to this too but with a broader usecase in mind.There are some inherent technical challanges with this approach & domain:- syscall logs can get huge - especially when saved to disk. Our strace logs would get over 100GB for some projects (llvm was around ~50GB)- some projects also use https and inter process communications and that needs ot be properly handled too. (We even had a customer that was retriving code from a firebird database via perl as part of the compilation step!)- It's runtime analysis - you might need to repeat the analysis for each configuration.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44903723,
    "by": "bgirard",
    "timeISO": "2025-08-14T18:11:47.000Z",
    "textPlain": "That's really cool. Fascinating to think about all the problems that get missed due to poor or missing visualizations like this.I did a lot of work to improve the Mozilla build system a decade ago where I would have loved this tool. Wish they would have said what problem they found.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904365,
    "by": "boris",
    "timeISO": "2025-08-14T19:09:19.000Z",
    "textPlain": "> It also has 6 seconds of inactivity before starting any useful work. For comparison, ninja takes 0.4 seconds to start compiling the 2,468,083 line llvm project. Ninja is not a 100% fair comparison to other tools, because it benefits from some “baked in” build logic by the tool that created the ninja file, but I think it’s a reasonable “speed of light” performance benchmark for build systems.This is an important observation that is often overlooked. What’s more, the changes to the information on which this “baked in” build logic is based is not tracked very precisely.How close can we get to this “speed of light” without such “baking in”? I ran a little benchmark (not 100% accurate for various reasons but good enough as a general indication) which builds the same project (Xerces-C++) both with ninja as configured by CMake and with build2, which doesn’t require a separate step and does configuration management as part of the build (and with precise change tracking). Ninja builds this project from scratch in 3.23s while build2 builds it in 3.54s. If we omit some of the steps done by CMake (like generating config.h) by not cleaning the corresponding files, then the time goes down to 3.28s. For reference, the CMake step takes 4.83s. So a fully from-scratch CMake+ninja build actually takes 8s, which is what you would normally pay if you were using this project as a dependency.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904124,
    "by": "aanet",
    "timeISO": "2025-08-14T18:48:54.000Z",
    "textPlain": "This is fabulous!!Is there a version available for MacOS today??  I'd love to give it a whirl... For Rust, C++ / Swift and other stuff.Thanks!",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904193,
    "by": "tiddles",
    "timeISO": "2025-08-14T18:54:55.000Z",
    "textPlain": "Nice, I’ve been looking for something like this for a while.I’ve noticed on my huge catkin cmake project that cmake is checking the existence of the same files hundreds of times too. Is there anything that can hook into fork() and provide a cached value after the first invocation?",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44903974,
    "by": "supportengineer",
    "timeISO": "2025-08-14T18:34:35.000Z",
    "textPlain": "Amazing!  Great job!What limits your tool to compiler/build tools, can it be used for any arbitrary process?",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44903835,
    "by": "xuhu",
    "timeISO": "2025-08-14T18:22:44.000Z",
    "textPlain": "Is there a tool that records the timestamp of each executed command during a build, and when you rebuild, it tells you how much time is left instead of \"building obj 35 out of 1023\" ?Or (for cmake or ninja) use a CSV that says how long each object takes to build and use it to estimate how much is left ?",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44903970,
    "by": "corysama",
    "timeISO": "2025-08-14T18:34:24.000Z",
    "textPlain": "Looks like a general `fork()` visualizer to me. Which is great!",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904182,
    "by": "mgaunard",
    "timeISO": "2025-08-14T18:54:12.000Z",
    "textPlain": "The real solution is to eliminate build systems where you have to define your own targets.Developers always get it wrong and do it badly.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904338,
    "by": "klik99",
    "timeISO": "2025-08-14T19:06:58.000Z",
    "textPlain": "Nice! Leaving a comment to easily find this later, dont have anything to add except this looks cool",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905111,
    "by": "CyberDildonics",
    "timeISO": "2025-08-14T20:13:17.000Z",
    "textPlain": "I love the visualization, I think it's great information and will be very helpful to whoever uses it.I would think about a different name. Often names are either meant to be funny or just unique nonsense but something short and elegantly descriptive (like BuildViz etc.) can go a long way to making it seem more legitimate and being more widely used.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905023,
    "by": "jeffbee",
    "timeISO": "2025-08-14T20:05:28.000Z",
    "textPlain": "This seems like a good place to integrate a Bazel Build Event Protocol stream consumer.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904968,
    "by": "kirito1337",
    "timeISO": "2025-08-14T20:00:58.000Z",
    "textPlain": "That's interesting.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904792,
    "by": "forrestthewoods",
    "timeISO": "2025-08-14T19:47:09.000Z",
    "textPlain": "This is great. I was skeptical from the title but the implementation is very clever. This could be a super super useful tool for the industry.",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44904227,
    "by": "brcmthrowaway",
    "timeISO": "2025-08-14T18:58:02.000Z",
    "textPlain": "What about OSes that dont use fork()?",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44903893,
    "by": "Surac",
    "timeISO": "2025-08-14T18:28:24.000Z",
    "textPlain": "but why? I have to admit it's a fun project",
    "parent": 44902127,
    "depth": 1
  },
  {
    "id": 44905637,
    "by": "phaedrus",
    "timeISO": "2025-08-14T21:00:20.000Z",
    "textPlain": "When I was trying to improve compile time for my game engine, I ended up using compiled size as a proxy measure.  Although it is an imperfect correlation, the fact that compiled size is deterministic across build runs and even across builds on different machines makes it easier to work with than wall clock time.",
    "parent": 44904058,
    "depth": 2
  },
  {
    "id": 44905796,
    "by": "pklausler",
    "timeISO": "2025-08-14T21:17:37.000Z",
    "textPlain": "strace might help, if you have it.",
    "parent": 44904058,
    "depth": 2
  },
  {
    "id": 44905123,
    "by": "unddoch",
    "timeISO": "2025-08-14T20:14:22.000Z",
    "textPlain": "I wrote a little GCC plugin for compile time tracing/profiling, if that's something you're interested in: https://github.com/royjacobson/externis",
    "parent": 44904058,
    "depth": 2
  },
  {
    "id": 44903892,
    "by": "dhooper",
    "timeISO": "2025-08-14T18:28:19.000Z",
    "textPlain": "(OP here) Thanks!My call with the Mozilla engineer was cut short, so we didn't have time to go into detail about what he found, I want to look into it myself.",
    "parent": 44903723,
    "depth": 2
  },
  {
    "id": 44904540,
    "by": "remexre",
    "timeISO": "2025-08-14T19:25:50.000Z",
    "textPlain": "> What’s more, the changes to the information on which this “baked in” build logic is based is not tracked very precisely.kbuild handles this on top of Make by having each target depend on a dummy file that gets updated when e.g. the CFLAGS change. It also treats Make a lot more like Ninja (e.g. avoiding putting the entire build graph into every Make process) -- I'd be interested to see how it compares.",
    "parent": 44904365,
    "depth": 2
  },
  {
    "id": 44904160,
    "by": "dhooper",
    "timeISO": "2025-08-14T18:52:11.000Z",
    "textPlain": "I'll be sending out the a macOS version to another wave of beta users after I fix an outstanding issue, if you sign up (at bottom of article) and mention this comment I can make sure you're in that wave.",
    "parent": 44904124,
    "depth": 2
  },
  {
    "id": 44904163,
    "by": "Night_Thastus",
    "timeISO": "2025-08-14T18:52:21.000Z",
    "textPlain": "It looks like it doesn't have a public release for any OS yet, but has a way to enter for early access.",
    "parent": 44904124,
    "depth": 2
  },
  {
    "id": 44904358,
    "by": "lights0123",
    "timeISO": "2025-08-14T19:08:33.000Z",
    "textPlain": "My tips for speeding up builds (from making this same project but with ebpf):- switch to ninja to avoid that exact issue since CMake + Make spawns a subprocess for every directory (use the binary from PyPi for jobserver integration)- catkin as in ROS? rm /opt/ros/noetic/etc/catkin/profile.d/99.roslisp.sh to remove 2 python spawns per package",
    "parent": 44904193,
    "depth": 2
  },
  {
    "id": 44904023,
    "by": "dhooper",
    "timeISO": "2025-08-14T18:39:45.000Z",
    "textPlain": "Thank you! Yeah it can be used for any type of program, but I haven't been able to think of anything besides compilation that creates enough processes to be interesting. I'm open to ideas!",
    "parent": 44903974,
    "depth": 2
  },
  {
    "id": 44903960,
    "by": "dhooper",
    "timeISO": "2025-08-14T18:33:47.000Z",
    "textPlain": "OP Here. Thats an interesting idea. What The Fork knows all the commands run, and every path they read/write, so I should be able to make it estimate build time just by looking at what files were touched.",
    "parent": 44903835,
    "depth": 2
  },
  {
    "id": 44905318,
    "by": "dhooper",
    "timeISO": "2025-08-14T20:29:58.000Z",
    "textPlain": "Thanks CyberDildoNics!",
    "parent": 44905111,
    "depth": 2
  },
  {
    "id": 44905344,
    "by": "hiccuphippo",
    "timeISO": "2025-08-14T20:31:32.000Z",
    "textPlain": "Name checks out.",
    "parent": 44905111,
    "depth": 2
  },
  {
    "id": 44905097,
    "by": "MathMonkeyMan",
    "timeISO": "2025-08-14T20:11:42.000Z",
    "textPlain": "I was going to comment that \"what the fork\" might not work for a client/server build system like Bazel, but now I have something to google instead.",
    "parent": 44905023,
    "depth": 2
  },
  {
    "id": 44904243,
    "by": "dhooper",
    "timeISO": "2025-08-14T18:59:10.000Z",
    "textPlain": "I use whatever the equivalent is on that OS.",
    "parent": 44904227,
    "depth": 2
  },
  {
    "id": 44904135,
    "by": "rvrb",
    "timeISO": "2025-08-14T18:49:46.000Z",
    "textPlain": "here, I'll copy the first paragraph of TFA for you:> Many software projects take a long time to compile. Sometimes that’s just due to the sheer amount of code, like in the LLVM project. But often a build is slower than it should be for dumb, fixable reasons.",
    "parent": 44903893,
    "depth": 2
  }
]
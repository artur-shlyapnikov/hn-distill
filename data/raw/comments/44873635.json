[
  {
    "id": 44904989,
    "by": "brettgriffin",
    "timeISO": "2025-08-14T20:02:37.000Z",
    "textPlain": "I watched the first half hour of this earlier this week. I was surprised at just how differently two people can view the world. I'm not sure I would be as dogmatic as him, but just using the first few points, I think you can make strong cases against:1. Everything is exposed as an API with little no insight to inner workings (black box)2. Everything should be broken down into modules at a level where one person works on that module3. He shows a video of his video editor, saying it supports multiple inputs (like two keyboards or two mice), then says no platform supports it, but if they ever do, it will work4. Don't implement 'good enough apis'I hope that anybody who has ever worked on software understands that there are virtues to doing exactly the opposite of what is described in each of these points. Even if you can make an argument for any of these, you would have to qualify them with so many exceptions that you would effectively negate the entire argument.I spent a lot of evenings early in my career watching similar videos, hoping to find some magic bullet in how people better than me do what I do. People make a living doing this on the conference circuit. Maybe it is a fools errand to try to distill something as complex and situationally dependent as software into a video, but I'm having a hard time finding any major insights in all of the videos I watched.",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44904706,
    "by": "mjr00",
    "timeISO": "2025-08-14T19:40:37.000Z",
    "textPlain": "> Don't ever implement good-enough-for-now APIsAgree in theory, in practice this is impossible. Even if you're an absolute domain expert in whatever you're doing, software and requirements will evolve and you will end up needing to implement something for which your current API is not suitable. Just ask S3:ListObjectsV2 or golangs' `encoding/json/v2` etc.I push back hard on this one because a lot of developers will try to be \"clever\" and basically turn their api into    def my_api(parameters: dict[str, str]) -> dict[str, str]:\n\nor an equivalent, and now you have an API which theoretically can handle any requirement, but does so in a way that's extremely unfriendly and painful to use.It's better to accept that your API will change at some point and have a versioning and deprecation strategy in place. With well-architected software this usually isn't hard.",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44910307,
    "by": "CopyOnWrite",
    "timeISO": "2025-08-15T09:37:01.000Z",
    "textPlain": "IMHO there are a lot of problems with the advice from Eskil.His ideas about abstraction of the platform made a lot of sense in the past decades, but IMHO are not that applicable nowadays: It is well understood to separate domain logic from UI and storage, and a desktop application has a very different UI from a mobile app or even a web app.My next critic point is, that Eskil assumes all domain knowledge is there from the beginning and will not change over time (his idea of having perfect APIs from the beginning).No mention about error handling, reliability, response times, atomic operations etc.To make it very clear: I believe Eskil gives his advice in good faith and his advice served him well in his own projects. In my opinion most of his advice is just not good advice in general.(Besides having modules as black box building blocks if possible).",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44904144,
    "by": "habitue",
    "timeISO": "2025-08-14T18:50:37.000Z",
    "textPlain": "Started watching, but \"C89 is the safe option for long lived software\" kind of turned me off. There are plenty of safe long lived stable languages out there where you dont have to manually manipulate memory. At the very least, this guy should be advocating for Java.But even that's too far really. Like it or not, \"shiny fad\" languages like Python & Javascript have been around forever, support for them isn't going away, this should be a non-concern at the architectural level. (Bigger language concerns: is it performant enough for my expected use? Does it have strong types to help with correctness? Can I hire programmers who know it? etc)",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44910346,
    "by": "mrkeen",
    "timeISO": "2025-08-15T09:42:53.000Z",
    "textPlain": "6:55> \"C98\"7:05> \"It's faster to write five lines of code today, than to write one line today, and have to edit it in the future\"This is my experience writing C as well, which is why I now avoid it.There are plenty of times where writing something in C seems like it would be simpler and more reliable than in other languages.  But I found I couldn't edit it.  Too many of my assumptions get baked into the code and I can't see them later.",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44906257,
    "by": "namuol",
    "timeISO": "2025-08-14T22:07:32.000Z",
    "textPlain": "Ages ago, before I had any real professional experience, I was blown away by Steenberg’s demos and enamored by his tech talks. The demos still impress me and have aged well, but today I’m glad I didn’t fall into the trap of taking his development advice as scripture.His name has been popping up a lot more recently. I would be worried about the impact he might be having on young programmers, but honestly I doubt his worst advice would survive in industry anyway. I didn’t watch this particular video but his recent talk at Better Software Conference was illuminating, in a bad way.",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44904718,
    "by": "boricj",
    "timeISO": "2025-08-14T19:41:41.000Z",
    "textPlain": "I've seen relational database schemas degenerating into untyped free-for-all key-values because they weren't expressive enough. I've seen massive code duplication (and massive amounts of bugs) because no one invested into a quality core set of libraries to address basic use-cases of a given platform. I've seen systems crumbling under tech debt because of chronic prioritization of features over maintenance.I've worked on large software projects. The only ones I've met that weren't dreadful to work on had engineering and management working together with a shared, coherent vision.",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44904202,
    "by": "kod",
    "timeISO": "2025-08-14T18:55:49.000Z",
    "textPlain": "The \"one module should be written by only one person\" dogma is kind of interesting.But I got to the \"my wrapper around SDL supports multiple simultaneous mouse inputs, even though no operating system does\" and noped out.  YAGNI, even in a large project",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44906479,
    "by": "kthxb",
    "timeISO": "2025-08-14T22:31:22.000Z",
    "textPlain": "I feel like a lot of his takes -- like c89 being the best -- may be true in the context of the kind of complex desktop applications he seems to develop, but not universally applicable.Still, he gives a lot of good advice and fundamental engineering rules.",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44908909,
    "by": "SCdF",
    "timeISO": "2025-08-15T05:28:42.000Z",
    "textPlain": "So I watched about 15 minutes. I'm not already aware of this person, and their website isn't too illuminating, and there is an hour left. So I have to confess I closed the tab.His ideas feel, frankly, like catnip for developers. Each dev writes there own modules, so you get to do whatever you want without having to deal with other people's coding styles or philosophies (or better ideas), and no meetings, and you also spend the \"right\" amount of time building everything.But it doesn't sound like it would work on \"LARGE\" (his capitals) software projects, at least none that I've worked on. In those, creating modules small enough to be built once by one dev would just push all discussion (and dreaded meetings) into the API  layer, with double the meetings because you should get it right first time, actually double them again because the strategy if someone leaves and their modules aren't right is to just reimplement them so you have to be even more sure they are thoughtfully designed.It actually sounds like a pitch for agentic coding: if you define your APIs small enough and correctly enough, you don't need to worry about implementation quality, so just let the api do it. I think it's a good way of thinking about it, and thinking about all the ways in which you might not be comfortable with that.Anyway, what do I know? Maybe he's a super expert on this stuff. I would gentle suggest, if he redid the talk, to open with a) what he means by LARGE software projects, and b) an example where this strategy he is about to explain has been implemented.",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44905080,
    "by": "gashmol",
    "timeISO": "2025-08-14T20:10:20.000Z",
    "textPlain": "Aside - Why do we need the word \"architecting\" anyway? Why not just use designing?",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44905075,
    "by": "yuvadam",
    "timeISO": "2025-08-14T20:09:39.000Z",
    "textPlain": "Obligatory mention of A Philosophy of Software Design by John Ousterhout as the arguably the most important book every developer should read to understand proper modularization and complexity management.",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44904329,
    "by": "bestspharma",
    "timeISO": "2025-08-14T19:06:13.000Z",
    "textPlain": "[dead]",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44904346,
    "by": "bestspharma",
    "timeISO": "2025-08-14T19:07:36.000Z",
    "textPlain": "[dead]",
    "parent": 44873635,
    "depth": 1
  },
  {
    "id": 44905200,
    "by": "ribelo",
    "timeISO": "2025-08-14T20:20:40.000Z",
    "textPlain": "He basically just described the FCIS[0] architecture—the same one Gary Bernhart laid out thirteen years ago. We love reinventing the wheel. Chaplicki did it with ELM, Abramov with Redux, day8 did it with re-frame, and the beat goes on.I’m still amazed it isn’t obvious: every piece of software should be a black box with a pin-hole for input and an even tinier pin-hole for output. The best code I’ve ever touched worked exactly like that and maintaining it was a pleasure, everything else was garbage. I push this rule in every project I touch.[0] https://www.destroyallsoftware.com/screencasts/catalog/funct...",
    "parent": 44904989,
    "depth": 2
  },
  {
    "id": 44905242,
    "by": "leecommamichael",
    "timeISO": "2025-08-14T20:24:59.000Z",
    "textPlain": "I think the mistake people make when trying to teach this stuff is in generalizing too much.His input layer is good because it helped him emulate local multiplayer with keyboard and mouse. It solved _his problem_.The graphics layer is good because it is so much easier to work with than OpenGL _for him_.The library wrappers are good for him because they solve _his desire_ to run portably while maintaining the smallest possible interface.This stuff matters to Eskil because he’s:\n- just one person\n- has deep expertise in what he’s wrapping (win32, OpenGL)\n- wants to make an impressive program soloI think his expertise, historical perspective, and culture make it feel as if this is the only way to do this very hard task, so he wants to share it. It helps him believe his way is right that many great, and reliable projects are done in C89.I think the truth at this point is that folks still using old versions of C have, on average, more experience than everyone else. It’s not just the language that’s making them strong, either. It’s having evolved with the platforms.Now the only question that leaves is whether it makes a huge difference to really stick with one language over the decades. I know we’ve all heard both sides of that quandary.",
    "parent": 44904989,
    "depth": 2
  },
  {
    "id": 44907596,
    "by": "SkyPuncher",
    "timeISO": "2025-08-15T01:12:22.000Z",
    "textPlain": "This type of software architecture is good when you're building stable, well known systems. Notice that none of his examples were new or novel functionality.Most people don't work in that world.",
    "parent": 44904989,
    "depth": 2
  },
  {
    "id": 44908197,
    "by": "abetusk",
    "timeISO": "2025-08-15T03:05:53.000Z",
    "textPlain": "Thanks, I'm 13m in and I haven't found anything I would consider valuable or insightful.I haven't watched many of these videos but the two that stand out for me as being genuinely helpful is Jonathan Blow's talk about software quality [0-4] and Daniel Sockwell's \"Imagining the Ideal Language for Writing Free Software\" [5].From Blow's talk, my takeaways are:* Large organizations don't necessarily know how to make software and small teams can make quality, large scale projects* Abstraction is its own form of optimization and should be used sparingly. Stripping away a level of abstraction is sometimes desirable.* Design should be data centric. That is, focus on how to pass data between different domains of concern. Don't be shy about exposing data and don't hide data. This differs slightly from \"API-centric\" approaches as the contract is in the data, not in the function call interface.* Keep inheritance to a maximum of 2-3 levels deep, with a preference of 1 or none. Not all language features should be used. Use language features sparingly, and this is one of them.* Duplicate code (e.g. \"cut-and-paste\") for clarity. Dispensing with code-reuse isn't a sin and is sometimes desirable. DRY is fine but sometimes having a common function increases cognitive load to understand what code is doing and often portions of code that look very similar are different in substantial but subtle ways that make de-duplication overly confusing to handle all cases. When reviewing a function, having all code available locally, without having to page out to different areas of the code base to see what a common function is doing, often helps with readability and isn't as detrimental to reliability as people make it out to be.From Sockwell's talk:It's a weird premise (how can software be ideal for writing FOSS?) but the point is that many software architectural concerns stem from what economic environment they're being developed in. FOSS tends to be developed by a single or small team. The focu",
    "parent": 44904989,
    "depth": 2
  },
  {
    "id": 44909006,
    "by": "deterministic",
    "timeISO": "2025-08-15T05:46:04.000Z",
    "textPlain": "> Everything is exposed as an API with little no insight to inner workingsThis is how I build large scale biz software (30+ years of experience). And I have never seen a case where it wasn't a good idea.For example, the largest software system in the world (the internet) operate this way.However I am always open to learn something new?",
    "parent": 44904989,
    "depth": 2
  },
  {
    "id": 44904943,
    "by": "imglorp",
    "timeISO": "2025-08-14T19:58:50.000Z",
    "textPlain": "Yes, and also don't try to anticipate everything by implementing features that won't be used soon, ie \"just in case\". If the soon turns to never, any unused feature is basically dead code and represents future costs and constraints to maintain or remove it.",
    "parent": 44904706,
    "depth": 2
  },
  {
    "id": 44907163,
    "by": "manoDev",
    "timeISO": "2025-08-15T00:03:42.000Z",
    "textPlain": "That’s not how I read “Don't ever implement good-enough-for-now APIs”.Requirements _may_ change, but it’s much harder to have consumers move to a new API. Once it’s published, it’s a contract you don’t want to break.That doesn’t mean you need to design an extremely flexible and future-proof API to the point it stops making sense — it’s a false dichotomy.What you can do is take your time designing an API that still makes sense as long as possible, until your understanding of the domain has changed so much that it’s a different shape altogether.Throwing your hands up and saying “it’s impossible” is easy, the art is in figuring out how much has to change until you have to say that.Design is a game of push-pull between context and form, and you can add tolerances both ways.",
    "parent": 44904706,
    "depth": 2
  },
  {
    "id": 44905409,
    "by": "leecommamichael",
    "timeISO": "2025-08-14T20:37:14.000Z",
    "textPlain": "Yeah, it’s too hard of a rule. In reality interfaces have points of resistance; where they aren’t really helping you do what you’re wanting, and they have fitting-points where they do what you need done.I’d argue it’s your job to strike some kind of balance there. If you know you’re working with something stable, why settle for good-enough? Well, because the task of assessing what is stable requires years of mistakes, and good-enough varies drastically between languages. I think I see a point here for using primitive C; there’s hardly a type-system to waste time with, but you can cut yourself with macros. This is why I use Odin.",
    "parent": 44904706,
    "depth": 2
  },
  {
    "id": 44905417,
    "by": "hk1337",
    "timeISO": "2025-08-14T20:38:03.000Z",
    "textPlain": "I would add a caveat...Don't ever implement good-enough-for-now APIs without a plan to come back and fix it and a deadline to fix itMost of the time \"good-enough-for-now\" really is just \"good-enough-forever\".",
    "parent": 44904706,
    "depth": 2
  },
  {
    "id": 44904559,
    "by": "mahalex",
    "timeISO": "2025-08-14T19:27:53.000Z",
    "textPlain": "> languages like Python & Javascript have been around forever, support for them isn't going away???\nPython 2 went out of support five years ago.",
    "parent": 44904144,
    "depth": 2
  },
  {
    "id": 44904573,
    "by": "alexott",
    "timeISO": "2025-08-14T19:28:55.000Z",
    "textPlain": "It really depends. I was at talk of architect of car company when he was talking about need to develop and support a car software for 20-30 years - few years before release, 10-20 years of production, and the critical fixes after end of support. And it includes not only soft itself, but all compilers, etc.",
    "parent": 44904144,
    "depth": 2
  },
  {
    "id": 44905821,
    "by": "tracker1",
    "timeISO": "2025-08-14T21:20:03.000Z",
    "textPlain": "I think the \"how easy will this be to replace\" question should be a guiding factor in terms of some architectural decisions.  Having modular code, and abstractions can add a lot of value, but if you do it in a way that locks you down and makes everything it touches a multiple in terms of complexity, is it really worth it.One thing I often do, in terms of modularizing, especially for re-share or external use is sit down and think about the ergonomics of what I'm creating and how I would like to be able to use/consume said module... often writing documentation before writing the code.",
    "parent": 44904718,
    "depth": 2
  },
  {
    "id": 44904728,
    "by": "leecommamichael",
    "timeISO": "2025-08-14T19:42:14.000Z",
    "textPlain": "He’s sitting at a system that thousands of people built together simultaneously. We have gripes with our OSes but they’re all capable of nearly perfect uptime (depending on the hardware and workload.) So I am not convinced individuals need to own modules. I think it’s good for things to work that way, but not necessary.I didn’t find much fault at all with what he’s saying about SDL. It’s just an example of the “layered design” he’s advocating for. You may have drawn your conclusion a little early; he immediately follows up with his API for graphics, which is actually a very practical example. He’s really just saying people should consider writing their own APIs even if it’s implemented with a library, because you can select exactly how complex the API needs to be for your app’s requirements. This makes the task of replacing a dependency much simpler.He’s actually trying to prevent relying on things you don’t need. YAGNI.",
    "parent": 44904202,
    "depth": 2
  },
  {
    "id": 44904888,
    "by": "barbazoo",
    "timeISO": "2025-08-14T19:54:49.000Z",
    "textPlain": "> YAGNI“You Aren’t Gonna Need It”",
    "parent": 44904202,
    "depth": 2
  },
  {
    "id": 44906175,
    "by": "layer8",
    "timeISO": "2025-08-14T21:58:13.000Z",
    "textPlain": "Software architecture is about the higher-level, big-picture stuff: https://stackoverflow.com/a/704909/623763",
    "parent": 44905080,
    "depth": 2
  },
  {
    "id": 44909641,
    "by": "toolslive",
    "timeISO": "2025-08-15T07:44:53.000Z",
    "textPlain": "Design and architecture are 2 different things. \nDesign is about appearance. \nArchitecture is about structure.",
    "parent": 44905080,
    "depth": 2
  },
  {
    "id": 44905457,
    "by": "leecommamichael",
    "timeISO": "2025-08-14T20:41:04.000Z",
    "textPlain": "Architecting at least somewhat harkens to engineering; where there are costs, limits, tolerances, and to some degree aesthetics.",
    "parent": 44905080,
    "depth": 2
  }
]
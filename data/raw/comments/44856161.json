[
  {
    "id": 44885951,
    "by": "agnishom",
    "timeISO": "2025-08-13T08:35:18.000Z",
    "textPlain": "This reminds me of Borel Gameshttps://gowers.wordpress.com/2013/08/23/determinacy-of-borel...",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885035,
    "by": "BrenBarn",
    "timeISO": "2025-08-13T05:52:29.000Z",
    "textPlain": "This is just a thought, but I wonder if there is a mathematical connection between this game and something like the binary representation of irrational (or maybe transcendental) numbers.The article is also notable for its consistency in spelling \"lose\" as \"loose\".",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885095,
    "by": "ahofmann",
    "timeISO": "2025-08-13T06:05:32.000Z",
    "textPlain": "> The file is a mere 512 bytes, and unpacks to a 26kb file, which again unpacks to 3Mb.My brain hurts when thinking about that. How could 512 bytes be enough to store ~3 million bytes? I know that compression is basically about finding patterns and this sequences should be very compressible.",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44856162,
    "by": "gylterud",
    "timeISO": "2025-08-10T16:14:40.000Z",
    "textPlain": "This little game I made might be one of the most tedious little games to actually play. But I found it great fun to analyse!(For the initiated, I should mention that it is related to Thue–Morse sequences.)",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885918,
    "by": "npinsker",
    "timeISO": "2025-08-13T08:30:24.000Z",
    "textPlain": "Does this have anything to do with modal logic?",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885246,
    "by": "nemosaltat",
    "timeISO": "2025-08-13T06:31:02.000Z",
    "textPlain": "very interesting, once I realized that the longer sequences were wrapping on my mobile. At first, it appeared that the “top” line was player 1 in the “bottom” line was player 2",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885299,
    "by": "danneezhao2022",
    "timeISO": "2025-08-13T06:42:09.000Z",
    "textPlain": "You can try making a chess or other physical game box, using two animals to represent",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885315,
    "by": "gylterud",
    "timeISO": "2025-08-13T06:43:53.000Z",
    "textPlain": "That's a neat thought!One could interpret the outcome of the game as a number by ○ being the digit 0 and ● being 1. For fun we could also say that if there is a repeating subsequence at the end (someone lost), then that is repeated infinitely. I suggest this because any won game has a sub-string repeated three times at the end, so we might as well repeat it to infinity!Say the example game, ● ● ○ ○ ● ● ○ ○ ● ● ○ ● ● ○ ● ○ ○ ● ● ○ ○ ● ● ○ ○ ●, would be 0.11001100110110100110011001, or perhaps 0.11001100110110(1001) where the parenthesis express infinite repetition. If we choose the first, it is 768160/959951 and the second would be 65553/81920.In any case, a won game would be a rational number, while a game which goes on forever would be an irrational! One could then wonder which irrational numbers are represented by such games.",
    "parent": 44885035,
    "depth": 2
  },
  {
    "id": 44885225,
    "by": "gylterud",
    "timeISO": "2025-08-13T06:28:07.000Z",
    "textPlain": "If it was a file filled entirely with one character, the compression could simply be to write a file saying \"this character copied 3 million times\", which is less than 512 bytes.This is not exactly what happens here, but many compression algorithms work by recognising that certain substrings are very common, and give them a \"shorter code\". In this game, there are some quite long such strings, giving a good compression rate. Furthermore, because of the recursive nature, it can find such patterns again after the common substrings are replaced by shorter codes, because these codes again form patterns with repeated substrings. This goes on until there is almost just a bit of meta data and an \"ur-pattern\".Compression is fascinating in many ways. For instance, since there are a fixed number of files of a certain size and some bigger files are made smaller, some smaller files must be made bigger by the compression! Of course, this could be as simple as attaching a header or flag which says \"I could not compress this. Here is the old file verbatim.\" But that is still a bit longer than the original!",
    "parent": 44885095,
    "depth": 2
  },
  {
    "id": 44886046,
    "by": "seanhunter",
    "timeISO": "2025-08-13T08:45:16.000Z",
    "textPlain": "You can think about the compressed size of some file as approximating the amount of information (in the Shannon sense[1]) there is in the file.  A perfect compression would reduce the file to exactly the size of the amount of information it contains.[1] https://arxiv.org/pdf/1612.09316",
    "parent": 44885095,
    "depth": 2
  },
  {
    "id": 44885170,
    "by": "kevinventullo",
    "timeISO": "2025-08-13T06:18:14.000Z",
    "textPlain": "In some sense, the program itself is a ~512 byte compression of an infinite stream of bytes.",
    "parent": 44885095,
    "depth": 2
  },
  {
    "id": 44886047,
    "by": "gylterud",
    "timeISO": "2025-08-13T08:45:19.000Z",
    "textPlain": "Yes, but the connection is not clear from what I wrote. I keep intending to make a little post about the connection, but I want it to highlight some Haskell code I wrote, but I haven't polished it yet. I want to make an update to it, using my applicative logic library[0][1].The short version: By representing the game coalgebraically, one can use modal logic to solve it (find a winning strategy for player 1) by brute force.The old code looks like:    -- Modal operators\n    e = modal any' (Coalg possible)\n    a = modal all' (Coalg possible)\n\n    -- Test for winning strategy within a limited number of moves.\n    winning :: Integer -> Player -> State -> Bool\n    winning 0 _ _ = False\n    winning n p s = wonAlready || e (a (winning (n-1) p)) s where\n           wonAlready = (winner s == Just p)\n\nWe can translate this into more standard modal logic: Letting ◇ be \"There is a move a player could make\", and □ be any move a player makes. We define the existence of a winnning strategy for player 1 inductively:    S(0) = ⊥\n    S(n+1) = W(p₁) ∨ ◇ □ S(n)\n\nIntuitively, you have a winning strategy if you won already, or if there is a move you make, such that whatever move the opponent makes you, you still have a winning strategy.[0]: https://hakon.gylterud.net/programming/applicative-logic.htm...[1]: https://github.com/typeterrorist/applicative-logic/blob/moda... – this is a branch with the modal logic operators defined.",
    "parent": 44885918,
    "depth": 2
  },
  {
    "id": 44886120,
    "by": "gylterud",
    "timeISO": "2025-08-13T08:56:20.000Z",
    "textPlain": "Ah, I hadn't tested this on mobile. I could try find some way of preventing the line break.",
    "parent": 44885246,
    "depth": 2
  }
]
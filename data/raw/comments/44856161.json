[
  {
    "id": 44885246,
    "by": "nemosaltat",
    "timeISO": "2025-08-13T06:31:02.000Z",
    "textPlain": "very interesting, once I realized that the longer sequences were wrapping on my mobile. At first, it appeared that the “top” line was player 1 in the “bottom” line was player 2",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885095,
    "by": "ahofmann",
    "timeISO": "2025-08-13T06:05:32.000Z",
    "textPlain": "> The file is a mere 512 bytes, and unpacks to a 26kb file, which again unpacks to 3Mb.My brain hurts when thinking about that. How could 512 bytes be enough to store ~3 million bytes? I know that compression is basically about finding patterns and this sequences should be very compressible.",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885035,
    "by": "BrenBarn",
    "timeISO": "2025-08-13T05:52:29.000Z",
    "textPlain": "This is just a thought, but I wonder if there is a mathematical connection between this game and something like the binary representation of irrational (or maybe transcendental) numbers.The article is also notable for its consistency in spelling \"lose\" as \"loose\".",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44856162,
    "by": "gylterud",
    "timeISO": "2025-08-10T16:14:40.000Z",
    "textPlain": "This little game I made might be one of the most tedious little games to actually play. But I found it great fun to analyse!(For the initiated, I should mention that it is related to Thue–Morse sequences.)",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885225,
    "by": "gylterud",
    "timeISO": "2025-08-13T06:28:07.000Z",
    "textPlain": "If it was a file filled entirely with one character, the compression could simply be to write a file saying \"this character copied 3 million times\", which is less than 512 bytes.This is not exactly what happens here, but many compression algorithms work by recognising that certain substrings are very common, and give them a \"shorter code\". In this game, there are some quite long such strings, giving a good compression rate. Furthermore, because of the recursive nature, it can find such patterns again after the common substrings are replaced by shorter codes, because these codes again form patterns with repeated substrings. This goes on until there is almost just a bit of meta data and an \"ur-pattern\".Compression is fascinating in many ways. For instance, since there are a fixed number of files of a certain size and some bigger files are made smaller, some smaller files must be made bigger by the compression! Of course, this could be as simple as attaching a header or flag which says \"I could not compress this. Here is the old file verbatim.\" But that is still a bit longer than the original!",
    "parent": 44885095,
    "depth": 2
  },
  {
    "id": 44885170,
    "by": "kevinventullo",
    "timeISO": "2025-08-13T06:18:14.000Z",
    "textPlain": "In some sense, the program itself is a ~512 byte compression of an infinite stream of bytes.",
    "parent": 44885095,
    "depth": 2
  }
]
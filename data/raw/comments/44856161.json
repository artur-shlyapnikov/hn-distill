[
  {
    "id": 44886919,
    "by": "level3",
    "timeISO": "2025-08-13T10:57:28.000Z",
    "textPlain": "These sequences are also known as \"cubefree,\" so you might want to continue researching along those lines.In particular, the game discussed is trying to find cubefree words over a two-letter alphabet. The sample infinite game seems to agree with the listed sequence on OEIS for the lexicographically earliest infinite cubefree word, though your method of generation appears to be different from the one in the comments. (I haven't analyzed it in detail.)https://oeis.org/A282317",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44887252,
    "by": "gcanyon",
    "timeISO": "2025-08-13T11:41:37.000Z",
    "textPlain": "One relatively common way to remove first player advantage is to have the first player place one stone, and then after that each person places two stones on their turn. SoAfter player 1s first move there is one stone in the sequence.After player 2s first move there are three stones.After player 1s next move there are five stones.After player 2s next move there are seven stones.Etc. Usually this completely removes first player advantage. It’s obvious that this removes player 1s potential advantage since black or white, his move is symmetrical without loss of generality.Player 2 actually has the first consequential move, with three possible options — again, taking player 1s move as a given color, player 2 can playDD\nDS\nSDwhere S means “same” and D means “different”. Technically player 2 has four options: he could also play SS and lose immediately :-)",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885035,
    "by": "BrenBarn",
    "timeISO": "2025-08-13T05:52:29.000Z",
    "textPlain": "This is just a thought, but I wonder if there is a mathematical connection between this game and something like the binary representation of irrational (or maybe transcendental) numbers.The article is also notable for its consistency in spelling \"lose\" as \"loose\".",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44886775,
    "by": "Michelangelo11",
    "timeISO": "2025-08-13T10:39:40.000Z",
    "textPlain": "It's not intuitively clear to me how the game can go on forever -- I would expect that, eventually, you would hit upon some valid pattern. The explanation in the text didn't really make sense to me. Could anyone help with this?",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44886660,
    "by": "agnishom",
    "timeISO": "2025-08-13T10:22:08.000Z",
    "textPlain": "> To solve this question I wrote a short Haskell program which does a brute force search to find a winning strategy.Could you tell us more about this? I am curious how this problem was formulated using modal logic. Seems fascinating",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44886610,
    "by": "Gehinnn",
    "timeISO": "2025-08-13T10:13:31.000Z",
    "textPlain": "This reminds me of primitive words [1]: A primitive word is a word that is not the (2+ times) repetition of any other word.\nThis is slightly different than a non-pattern word from the article, which is a word that is not a 3+ times repetition of any other word.The anti-pattern game is about extending words such that they do not contain a pattern word.I wonder how the situation changes if 2 times repetitions would count as pattern (i.e. non-primitive words).For primitive words, it is an open problem if the language of primitive words (over any non-trivial finite alphabet) is context free.I wonder if the language of words that don't contain patterns (or non-primitive words) is context free.[1] https://arxiv.org/abs/1104.4427",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44886664,
    "by": "davzim",
    "timeISO": "2025-08-13T10:22:50.000Z",
    "textPlain": "This reminds me of the movie \"The Oxford Murders\" with Elijah Wood, where a maths professor and their student argue if any pattern can be predicted by logic. Well worth a watch.",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885095,
    "by": "ahofmann",
    "timeISO": "2025-08-13T06:05:32.000Z",
    "textPlain": "> The file is a mere 512 bytes, and unpacks to a 26kb file, which again unpacks to 3Mb.My brain hurts when thinking about that. How could 512 bytes be enough to store ~3 million bytes? I know that compression is basically about finding patterns and this sequences should be very compressible.",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885951,
    "by": "agnishom",
    "timeISO": "2025-08-13T08:35:18.000Z",
    "textPlain": "This reminds me of Borel Gameshttps://gowers.wordpress.com/2013/08/23/determinacy-of-borel...",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44856162,
    "by": "gylterud",
    "timeISO": "2025-08-10T16:14:40.000Z",
    "textPlain": "This little game I made might be one of the most tedious little games to actually play. But I found it great fun to analyse!(For the initiated, I should mention that it is related to Thue–Morse sequences.)",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885246,
    "by": "nemosaltat",
    "timeISO": "2025-08-13T06:31:02.000Z",
    "textPlain": "very interesting, once I realized that the longer sequences were wrapping on my mobile. At first, it appeared that the “top” line was player 1 in the “bottom” line was player 2",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885918,
    "by": "npinsker",
    "timeISO": "2025-08-13T08:30:24.000Z",
    "textPlain": "Does this have anything to do with modal logic?",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44885299,
    "by": "danneezhao2022",
    "timeISO": "2025-08-13T06:42:09.000Z",
    "textPlain": "You can try making a chess or other physical game box, using two animals to represent",
    "parent": 44856161,
    "depth": 1
  },
  {
    "id": 44887533,
    "by": "gylterud",
    "timeISO": "2025-08-13T12:19:30.000Z",
    "textPlain": "Cubefree! Oh, that’s a good keyword to find more results about this.From your link it seems it is a conjecture that this is the lexicographically earliest one. Very interesting!",
    "parent": 44886919,
    "depth": 2
  },
  {
    "id": 44887566,
    "by": "gylterud",
    "timeISO": "2025-08-13T12:22:59.000Z",
    "textPlain": "Cool! I haven’t thought about varying the number of stones one could put. It’s definitely a variation to look into!Would your intuition be that this makes it so that neither player has a winning strategy? That perfect play would yield an infinite sequence?",
    "parent": 44887252,
    "depth": 2
  },
  {
    "id": 44885315,
    "by": "gylterud",
    "timeISO": "2025-08-13T06:43:53.000Z",
    "textPlain": "That's a neat thought!One could interpret the outcome of the game as a number by ○ being the digit 0 and ● being 1. For fun we could also say that if there is a repeating subsequence at the end (someone lost), then that is repeated infinitely. I suggest this because any won game has a sub-string repeated three times at the end, so we might as well repeat it to infinity!Say the example game, ● ● ○ ○ ● ● ○ ○ ● ● ○ ● ● ○ ● ○ ○ ● ● ○ ○ ● ● ○ ○ ●, would be 0.11001100110110100110011001, or perhaps 0.11001100110110(1001) where the parenthesis express infinite repetition. If we choose the first, it is 768160/959951 and the second would be 65553/81920.In any case, a won game would be a rational number, while a game which goes on forever would be an irrational! One could then wonder which irrational numbers are represented by such games.",
    "parent": 44885035,
    "depth": 2
  },
  {
    "id": 44886954,
    "by": "ludicrousdispla",
    "timeISO": "2025-08-13T11:01:54.000Z",
    "textPlain": "The game could use a better definition of what constitutes a pattern.>> A pattern is a sequence of pebbles repeated three times in a row.By that logic, player 2 would have lost at their fifth turn. ... And 'in a row' is open to interpretation since it is additional information to 'repeated three times'.",
    "parent": 44886775,
    "depth": 2
  },
  {
    "id": 44886662,
    "by": "n4r9",
    "timeISO": "2025-08-13T10:22:39.000Z",
    "textPlain": "> I wonder how the situation changes if 2 times repetitions would count as patternI might be misunderstanding, but do you mean that you cannot even have two of the same colour in a row? This is a very simple win for first player:W B W ?",
    "parent": 44886610,
    "depth": 2
  },
  {
    "id": 44885225,
    "by": "gylterud",
    "timeISO": "2025-08-13T06:28:07.000Z",
    "textPlain": "If it was a file filled entirely with one character, the compression could simply be to write a file saying \"this character copied 3 million times\", which is less than 512 bytes.This is not exactly what happens here, but many compression algorithms work by recognising that certain substrings are very common, and give them a \"shorter code\". In this game, there are some quite long such strings, giving a good compression rate. Furthermore, because of the recursive nature, it can find such patterns again after the common substrings are replaced by shorter codes, because these codes again form patterns with repeated substrings. This goes on until there is almost just a bit of meta data and an \"ur-pattern\".Compression is fascinating in many ways. For instance, since there are a fixed number of files of a certain size and some bigger files are made smaller, some smaller files must be made bigger by the compression! Of course, this could be as simple as attaching a header or flag which says \"I could not compress this. Here is the old file verbatim.\" But that is still a bit longer than the original!",
    "parent": 44885095,
    "depth": 2
  },
  {
    "id": 44885170,
    "by": "kevinventullo",
    "timeISO": "2025-08-13T06:18:14.000Z",
    "textPlain": "In some sense, the program itself is a ~512 byte compression of an infinite stream of bytes.",
    "parent": 44885095,
    "depth": 2
  },
  {
    "id": 44886046,
    "by": "seanhunter",
    "timeISO": "2025-08-13T08:45:16.000Z",
    "textPlain": "You can think about the compressed size of some file as approximating the amount of information (in the Shannon sense[1]) there is in the file.  A perfect compression would reduce the file to exactly the size of the amount of information it contains.[1] https://arxiv.org/pdf/1612.09316",
    "parent": 44885095,
    "depth": 2
  },
  {
    "id": 44886120,
    "by": "gylterud",
    "timeISO": "2025-08-13T08:56:20.000Z",
    "textPlain": "Ah, I hadn't tested this on mobile. I could try find some way of preventing the line break.",
    "parent": 44885246,
    "depth": 2
  },
  {
    "id": 44886047,
    "by": "gylterud",
    "timeISO": "2025-08-13T08:45:19.000Z",
    "textPlain": "Yes, but the connection is not clear from what I wrote. I keep intending to make a little post about the connection, but I want it to highlight some Haskell code I wrote, but I haven't polished it yet. I want to make an update to it, using my applicative logic library[0][1].The short version: By representing the game coalgebraically, one can use modal logic to solve it (find a winning strategy for player 1) by brute force.The old code looks like:    -- Modal operators\n    e = modal any' (Coalg possible)\n    a = modal all' (Coalg possible)\n\n    -- Test for winning strategy within a limited number of moves.\n    winning :: Integer -> Player -> State -> Bool\n    winning 0 _ _ = False\n    winning n p s = wonAlready || e (a (winning (n-1) p)) s where\n           wonAlready = (winner s == Just p)\n\nWe can translate this into more standard modal logic: Letting ◇ be \"There is a move a player could make\", and □ be any move a player makes. We define the existence of a winnning strategy for player 1 inductively:    S(0) = ⊥\n    S(n+1) = W(p₁) ∨ ◇ □ S(n)\n\nIntuitively, you have a winning strategy if you won already, or if there is a move you make, such that whatever move the opponent makes you, you still have a winning strategy.[0]: https://hakon.gylterud.net/programming/applicative-logic.htm...[1]: https://github.com/typeterrorist/applicative-logic/blob/moda... – this is a branch with the modal logic operators defined.",
    "parent": 44885918,
    "depth": 2
  }
]
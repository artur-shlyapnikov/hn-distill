[
  {
    "id": 44845426,
    "by": "judofyr",
    "timeISO": "2025-08-09T10:35:31.000Z",
    "textPlain": "This is one the reasons I find it so silly when people disregard Zig «because it’s just another memory unsafe language»: There’s plenty of innovation within Zig, especially related to comptime and metaprogramming. I really hope other languages are paying attention and steals some of these ideas.«inline else» is also very powerful tool to easily abstract away code with no runtime cost.",
    "parent": 44845017,
    "depth": 1
  },
  {
    "id": 44845375,
    "by": "spiffyk",
    "timeISO": "2025-08-09T10:23:00.000Z",
    "textPlain": "This post shows how versatile Zig's comptime is not only in terms of expressing what to pre-compute before the program ever runs, but also for doing arbitrary compile time bug-checks like these.  At least to me, the former is a really obvious use-case and I have no problem using that to my advantage like that.  But I often seem to overlook the latter, even though it could prove really valuable.",
    "parent": 44845017,
    "depth": 1
  },
  {
    "id": 44845978,
    "by": "veber-alex",
    "timeISO": "2025-08-09T12:25:51.000Z",
    "textPlain": "I don't understand. Isn't this only useful if the value you match on is known at compile time?",
    "parent": 44845017,
    "depth": 1
  },
  {
    "id": 44845403,
    "by": "dlahoda",
    "timeISO": "2025-08-09T10:30:37.000Z",
    "textPlain": "fn main() {    if false {\n\n        const _:() =  panic!();\n\n    }\n\n}Fails to compile in Rust.",
    "parent": 44845017,
    "depth": 1
  },
  {
    "id": 44845753,
    "by": "chrismorgan",
    "timeISO": "2025-08-09T11:43:50.000Z",
    "textPlain": "What I’ve seen isn’t people disregarding Zig because it’s just another memory-unsafe language, but rather disqualifying Zig because it’s memory-unsafe, and they don’t want to deal with that, even if some other aspects of the language are rather interesting and compelling. But once you’re sold on memory safety, it’s hard to go back.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44845553,
    "by": "diegocg",
    "timeISO": "2025-08-09T11:04:08.000Z",
    "textPlain": "As someone who uses D and has been doing things like what you see in the post for a long time, I wonder why other languages would put attention to these tricks and steal them when they have been completely ignoring them forever when done in D. Perhaps Zig will make these features more popular, but I'm skeptic.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44845848,
    "by": "pron",
    "timeISO": "2025-08-09T12:00:02.000Z",
    "textPlain": "> just another memory unsafe languageAlso, treating all languages that don't ensure full memory safety as if they're equally problematic is silly. The reason not ensuring memory safety is bad is because memory unsafety as at the root of some bugs that are both common, dangerous, and hard to catch. Only not all kinds of memory unsafety are equally problematic, Zig does ensure the lack of the the most dangerous kind of unsafety (out-of-bounds access) while making the other kind (use-after-free) easier to find.That the distinction between \"fully memory safe\" and \"not fully memory safe\" is binary is also silly not just because of the above, but because no lanugage, not even Java, is truly \"fully memory safe\", as programs continue to employ components not written in memory safe languages.Furthermore, Zig has (or intends to have) novel features (among low-level languages) that help reduce bugs beyond those caused by memory unsafety.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44845438,
    "by": "Ygg2",
    "timeISO": "2025-08-09T10:37:52.000Z",
    "textPlain": "> «inline else» is also very powerful tool to easily abstract away code with no runtime cost.Sure, but you lose the clarity of errors. The error wasn't in `comptime unreachable` but in `inline .a .b .c`.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44845401,
    "by": "dwattttt",
    "timeISO": "2025-08-09T10:29:52.000Z",
    "textPlain": "I love the idea, but something being \"provable\" in this way feels like relying on optimisations.If a dead code elimination pass didn't remove the 'comptime unreachable' statement, you'll now fail to compile (I expect?)",
    "parent": 44845375,
    "depth": 2
  },
  {
    "id": 44845492,
    "by": "Sharlin",
    "timeISO": "2025-08-09T10:49:42.000Z",
    "textPlain": "Sure, because it's compile-time code inside a (semantically) run-time check. In recent Rust versions you can do    fn main() {\n        const {\n            if false {\n                let _:() = panic!();\n            }\n        }\n    }\n\nwhich compiles as expected. (Note that if the binding were `const` instead of `let`, it'd still have failed to compile, because the semantics don't change.)",
    "parent": 44845403,
    "depth": 2
  },
  {
    "id": 44845432,
    "by": "Ygg2",
    "timeISO": "2025-08-09T10:36:52.000Z",
    "textPlain": "Why would it? If I recall correctly, const and static stuff basically gets inlined at the beginning of the program.",
    "parent": 44845403,
    "depth": 2
  }
]
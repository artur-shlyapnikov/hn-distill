[
  {
    "id": 44845426,
    "by": "judofyr",
    "timeISO": "2025-08-09T10:35:31.000Z",
    "textPlain": "This is one the reasons I find it so silly when people disregard Zig «because it’s just another memory unsafe language»: There’s plenty of innovation within Zig, especially related to comptime and metaprogramming. I really hope other languages are paying attention and steals some of these ideas.«inline else» is also very powerful tool to easily abstract away code with no runtime cost.",
    "parent": 44845017,
    "depth": 1
  },
  {
    "id": 44845375,
    "by": "spiffyk",
    "timeISO": "2025-08-09T10:23:00.000Z",
    "textPlain": "This post shows how versatile Zig's comptime is not only in terms of expressing what to pre-compute before the program ever runs, but also for doing arbitrary compile time bug-checks like these.  At least to me, the former is a really obvious use-case and I have no problem using that to my advantage like that.  But I often seem to overlook the latter, even though it could prove really valuable.",
    "parent": 44845017,
    "depth": 1
  },
  {
    "id": 44846722,
    "by": "the__alchemist",
    "timeISO": "2025-08-09T14:26:01.000Z",
    "textPlain": "I love how this opens with the acknowledgement we've made a mess of choice-like data structure terminology!",
    "parent": 44845017,
    "depth": 1
  },
  {
    "id": 44845978,
    "by": "veber-alex",
    "timeISO": "2025-08-09T12:25:51.000Z",
    "textPlain": "I don't understand. Isn't this only useful if the value you match on is known at compile time?",
    "parent": 44845017,
    "depth": 1
  },
  {
    "id": 44845403,
    "by": "dlahoda",
    "timeISO": "2025-08-09T10:30:37.000Z",
    "textPlain": "fn main() {    if false {\n\n        const _:() =  panic!();\n\n    }\n\n}Fails to compile in Rust.",
    "parent": 44845017,
    "depth": 1
  },
  {
    "id": 44846356,
    "by": "38",
    "timeISO": "2025-08-09T13:37:15.000Z",
    "textPlain": "[dead]",
    "parent": 44845017,
    "depth": 1
  },
  {
    "id": 44845753,
    "by": "chrismorgan",
    "timeISO": "2025-08-09T11:43:50.000Z",
    "textPlain": "What I’ve seen isn’t people disregarding Zig because it’s just another memory-unsafe language, but rather disqualifying Zig because it’s memory-unsafe, and they don’t want to deal with that, even if some other aspects of the language are rather interesting and compelling. But once you’re sold on memory safety, it’s hard to go back.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44847036,
    "by": "bobajeff",
    "timeISO": "2025-08-09T15:01:04.000Z",
    "textPlain": "I've seen a few new languages come along that were inspired by zig's comptime/metaprogramming in the same language concept.Zig I think has potential but it hasn't stabilized enough yet for broad adoption. That means it'll be awhile before it's built an ecosystem (libraries, engines etc.) that is useful to developers that don't care about language design.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44845553,
    "by": "diegocg",
    "timeISO": "2025-08-09T11:04:08.000Z",
    "textPlain": "As someone who uses D and has been doing things like what you see in the post for a long time, I wonder why other languages would put attention to these tricks and steal them when they have been completely ignoring them forever when done in D. Perhaps Zig will make these features more popular, but I'm skeptic.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44846406,
    "by": "ozgrakkurt",
    "timeISO": "2025-08-09T13:45:51.000Z",
    "textPlain": "This perspective that many people take on memory-safety of Rust seems really \n\"interesting\".Unfortunately for all fanatics, language really doesn't matter that much.I have been using KDE for years now and it works perfectly good for me. It has no issues/crashes, it has many features in terms of desktop environment and also many programs that come with it like music player, video player, text editor, terminal etc. and they all work perfectly well for me. Almost all of this is written in C++. No need to mention the classic linux/chromium etc. etc which are all written in c++/c.I use Ghostty which is written in zig, it is amazingly polished and works super well as well.I have built and used a lot of software written in Rust as well and they worked really well too.At some point you have to admit, what matters is the people writing software, the amount of effort that goes into it etc. it is not the langauge.As far as memory-safety goes, it really isn't close to being the most important thing unless you are writing security critical stuff. Even then just using Rust isn't as good as you might think, I uncountered a decent amount of segfaults, random crashes etc. using very popular Rust libraries as well. In the end just need to put in the effort.I'm not saying language doesn't matter but it isn't even close to being the most important thing.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44846740,
    "by": "the__alchemist",
    "timeISO": "2025-08-09T14:28:03.000Z",
    "textPlain": "Concur. This is a great feature I wish rust had. I've been bitten by the unpleasant syntax this article laments.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44846930,
    "by": "surajrmal",
    "timeISO": "2025-08-09T14:48:25.000Z",
    "textPlain": "I can't take zig as seriously as rust due to lack of data race safety. There are just too many bugs that can happen when you have threads, share state between those threads and manually manage memory. There are so many bugs I've written because I did this wrong for many years but didn't realize until I wrote rust. I don't trust myself or anyone to get this right.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44845848,
    "by": "pron",
    "timeISO": "2025-08-09T12:00:02.000Z",
    "textPlain": "> just another memory unsafe languageAlso, treating all languages that don't ensure full memory safety as if they're equally problematic is silly. The reason not ensuring memory safety is bad is because memory unsafety as at the root of some bugs that are both common, dangerous, and hard to catch. Only not all kinds of memory unsafety are equally problematic, Zig does ensure the lack of the the most dangerous kind of unsafety (out-of-bounds access) while making the other kind (use-after-free) easier to find.That the distinction between \"fully memory safe\" and \"not fully memory safe\" is binary is also silly not just because of the above, but because no lanugage, not even Java, is truly \"fully memory safe\", as programs continue to employ components not written in memory safe languages.Furthermore, Zig has (or intends to have) novel features (among low-level languages) that help reduce bugs beyond those caused by memory unsafety.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44846830,
    "by": "CyberDildonics",
    "timeISO": "2025-08-09T14:38:06.000Z",
    "textPlain": "If you make advancements but disregard the advancements that came before you, you have a research language, not a modern usable language.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44845438,
    "by": "Ygg2",
    "timeISO": "2025-08-09T10:37:52.000Z",
    "textPlain": "> «inline else» is also very powerful tool to easily abstract away code with no runtime cost.Sure, but you lose the clarity of errors. The error wasn't in `comptime unreachable` but in `inline .a .b .c`.",
    "parent": 44845426,
    "depth": 2
  },
  {
    "id": 44845401,
    "by": "dwattttt",
    "timeISO": "2025-08-09T10:29:52.000Z",
    "textPlain": "I love the idea, but something being \"provable\" in this way feels like relying on optimisations.If a dead code elimination pass didn't remove the 'comptime unreachable' statement, you'll now fail to compile (I expect?)",
    "parent": 44845375,
    "depth": 2
  },
  {
    "id": 44846560,
    "by": "sekao",
    "timeISO": "2025-08-09T14:06:32.000Z",
    "textPlain": "The code example will work even if `u` is only known at runtime. That's because the inner switch is not matching on `u`, it's matching on `ab`, which is known at compile time due to the use of `inline`.That may be confusing, but basically `inline` is generating different code for the branches .a and .b, so in those cases the value of `ab` is known at compile time. So, the inner switch is running at compile time too. In the .a branch it just turns into a call to handle_a(), and in the .b branch it turns into a call to handle_b().",
    "parent": 44845978,
    "depth": 2
  },
  {
    "id": 44846380,
    "by": "alpinisme",
    "timeISO": "2025-08-09T13:40:17.000Z",
    "textPlain": "The problem this is meant to solve is that sometimes a human thinking about the logic of the program can see it is impossible to reach some code (ie it is statically certain) but the language syntax and type system alone would not see the impossibility. So you can help the compiler along.It is not meant for asserting dynamic “unreachability” (which is more like an assertion than a proof).",
    "parent": 44845978,
    "depth": 2
  },
  {
    "id": 44847231,
    "by": "the__alchemist",
    "timeISO": "2025-08-09T15:21:38.000Z",
    "textPlain": "I have no idea what that's trying to do. A demonstration that rust is a large language with different dialects!",
    "parent": 44845403,
    "depth": 2
  },
  {
    "id": 44845492,
    "by": "Sharlin",
    "timeISO": "2025-08-09T10:49:42.000Z",
    "textPlain": "Sure, because it's compile-time code inside a (semantically) run-time check. In recent Rust versions you can do    fn main() {\n        const {\n            if false {\n                let _:() = panic!();\n            }\n        }\n    }\n\nwhich compiles as expected. (Note that if the binding were `const` instead of `let`, it'd still have failed to compile, because the semantics don't change.)",
    "parent": 44845403,
    "depth": 2
  },
  {
    "id": 44845432,
    "by": "Ygg2",
    "timeISO": "2025-08-09T10:36:52.000Z",
    "textPlain": "Why would it? If I recall correctly, const and static stuff basically gets inlined at the beginning of the program.",
    "parent": 44845403,
    "depth": 2
  }
]
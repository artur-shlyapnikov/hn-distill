[
  {
    "id": 44822158,
    "by": "anonymoushn",
    "timeISO": "2025-08-07T08:49:07.000Z",
    "textPlain": "I have read the examples, and it seems like this cannot be used for aggressive hoisting of conditionals by writing \"if (comptime foo)\", resulting in the the body of the if statement being executed unconditionally or omitted. So it cannot replace my current use of C preprocessor macros in Javascript, though Zig's actual comptime feature could.",
    "parent": 44778898,
    "depth": 1
  },
  {
    "id": 44818627,
    "by": "apatheticonion",
    "timeISO": "2025-08-06T22:32:04.000Z",
    "textPlain": "I literally just want Rust style macros and proc macros in JavaScript. e.g. using```\nconst MyComponent = () => jsx!(<div></div>)\n```rather than a .tsx file.That or wasm to be usable so I can just write my web apps in Rust",
    "parent": 44778898,
    "depth": 1
  },
  {
    "id": 44819381,
    "by": "spankalee",
    "timeISO": "2025-08-07T00:27:03.000Z",
    "textPlain": "import {sum} from './sum.js' with {type: 'comptime'};\n\nis an unfortunate abuse of the `type` import attribute. `type` is the one spec-defined attribute and it's supposed to correspond to the mime-type of the imported module, thus the two web platform supported types are \"json\" and \"css\". The mime-type of the imported file in this case is still `application/javascript`, so if this module had a type it would be \"js\".It would have been better to choose a different import attribute altogether.",
    "parent": 44778898,
    "depth": 1
  },
  {
    "id": 44818675,
    "by": "stevage",
    "timeISO": "2025-08-06T22:38:01.000Z",
    "textPlain": "I could imagine this being useful for pre-compiling markdown.",
    "parent": 44778898,
    "depth": 1
  },
  {
    "id": 44818559,
    "by": "mdarens",
    "timeISO": "2025-08-06T22:23:01.000Z",
    "textPlain": "One of the most exciting features of Zig, but am I correct that this doesn’t apply to types themselves like comptime generics in Zig? I find that to be one of the most powerful ideas: type level mappings that have the same syntax as the runtime code where you can just set an iteration limit. This would be a great way to get around the “too large union” problem in TS, for example.",
    "parent": 44778898,
    "depth": 1
  },
  {
    "id": 44817032,
    "by": "Thom2000",
    "timeISO": "2025-08-06T20:04:40.000Z",
    "textPlain": "Interesting. I've never seen the import-with syntax, though and it's hard to find any documentation on it. Is this a syntax extension?",
    "parent": 44778898,
    "depth": 1
  },
  {
    "id": 44820493,
    "by": "revskill",
    "timeISO": "2025-08-07T04:12:22.000Z",
    "textPlain": "Sweet. No need a framework to do that.",
    "parent": 44778898,
    "depth": 1
  },
  {
    "id": 44819780,
    "by": "shortrounddev2",
    "timeISO": "2025-08-07T01:49:55.000Z",
    "textPlain": "Would be really great if it could return named functions",
    "parent": 44778898,
    "depth": 1
  },
  {
    "id": 44821354,
    "by": "kitd",
    "timeISO": "2025-08-07T06:48:22.000Z",
    "textPlain": "No need for macros.https://github.com/lite-jsx/core",
    "parent": 44818627,
    "depth": 2
  },
  {
    "id": 44820224,
    "by": "krukah",
    "timeISO": "2025-08-07T03:17:24.000Z",
    "textPlain": "Maybe the (relative) lack of ecosystem has kept you away, but I really recommend checking out both Dioxus and Leptos. Leptos is incredibly similar to React, but with Rust ergonomics, and it's been a pleasure to learn and use. With an LLM by my side that knows React and Rust pretty well, I've found myself not even needing the React libraries that I thought I would, since I can easily build on the fly the features/components I actually need.I too, eventually gave up on React <> WASM <> Rust but I was able to port all my existing React over into Leptos in a few hours.",
    "parent": 44818627,
    "depth": 2
  },
  {
    "id": 44821971,
    "by": "Wintamute",
    "timeISO": "2025-08-07T08:20:19.000Z",
    "textPlain": "Writing a web app at the moment with C++/Emscripten. What makes wasm unusable in Rust?",
    "parent": 44818627,
    "depth": 2
  },
  {
    "id": 44820360,
    "by": "sriku",
    "timeISO": "2025-08-07T03:41:35.000Z",
    "textPlain": "The bun and other authors would probably do well to not repurpose already understood terminology. \"Macros\" are already understood to be code that produces other code. \"Comptime\" is a nice alternative, but bun's \"macros\" aren't macros in that sense.We had sweet-js macros as a library many years ago but it looks like it went nowhere, especially after an incompatible rewrite that (afaik) remains broken for even basic cases. (Caveat: been a while since I looked at it)",
    "parent": 44818627,
    "depth": 2
  },
  {
    "id": 44819743,
    "by": "alpinisme",
    "timeISO": "2025-08-07T01:42:54.000Z",
    "textPlain": "That particular example is odd. What are you gaining by having a macro that needs a compile step vs no macro and just configuring your compile step to use a JSX loader for js files?",
    "parent": 44818627,
    "depth": 2
  },
  {
    "id": 44820297,
    "by": "JoelMcCracken",
    "timeISO": "2025-08-07T03:30:31.000Z",
    "textPlain": "Every once in a while I get a strong urge to hack on sweet.js to add typescript support",
    "parent": 44818627,
    "depth": 2
  },
  {
    "id": 44818872,
    "by": "teaearlgraycold",
    "timeISO": "2025-08-06T23:04:46.000Z",
    "textPlain": "You want manual memory management for your web apps?",
    "parent": 44818627,
    "depth": 2
  },
  {
    "id": 44819723,
    "by": "alpinisme",
    "timeISO": "2025-08-07T01:38:33.000Z",
    "textPlain": "You’re projecting the mimetype idea from two examples but the proposal is intentionally agnostic about what type might be used for:> This proposal does not specify behavior for any particular attribute key or value. The JSON modules proposal will specify that type: \"json\" must be interpreted as a JSON module, and will specify common semantics for doing so. It is expected the type attribute will be leveraged to support additional module types in future TC39 proposals as well as by hosts.",
    "parent": 44819381,
    "depth": 2
  },
  {
    "id": 44817100,
    "by": "nrabulinski",
    "timeISO": "2025-08-06T20:09:51.000Z",
    "textPlain": "It’s been introduced as part of ecmascript 2026 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Refe...",
    "parent": 44817032,
    "depth": 2
  },
  {
    "id": 44821162,
    "by": "trgwii",
    "timeISO": "2025-08-07T06:09:55.000Z",
    "textPlain": "I have had many discussions with the author and we ultimately decided not to support those kinds of usecases until we have a very solid set of guarantees. Supporting closures can quickly become very tricky when you need to preserve a function across JS processes.",
    "parent": 44819780,
    "depth": 2
  }
]
[
  {
    "id": 44870562,
    "by": "LegionMammal978",
    "timeISO": "2025-08-11T23:20:02.000Z",
    "textPlain": "Several people in this thread are saying that tail recursion is superior to imperative iteration in that it explicitly specifies which variables may change in each iteration (assuming a broadly immutable language).To the contrary, I'd argue that immutability isn't the only alternative to universal mutability: many newer imperative languages (such as Rust) have various forms of controlled mutability, where one must explicitly declare which variables may be modified by imperative assignments.IME, controlled mutability captures just about all the benefit of immutable languages, without requiring any special data structures or sufficiently-smart compiler analyses to ensure good performance. I've never really understood the desire for tail-recursive versions of iterative algorithms, except if one is already committed to functional programming.",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44869452,
    "by": "hinkley",
    "timeISO": "2025-08-11T21:03:55.000Z",
    "textPlain": "Practically the day after I learned about tail recursion in CS class, I learned that almost all recursive calls can be translated to iteration, that in many cases the iterative version is easier to scan, is as fast if not faster, and that they can usually handle much much larger inputs than recursion due to avoiding stack overflow.Tail recursion is meant to fix the latter. But what we mean to happen and what actually happens ain't ever exactly similar.Tail recursion IME is a bigger foot gun than relying on someone to add a new conditional branch at the end of a block in an iterative algorithm without fucking it up in the process. And iteration responds generally better to Extract Function. And while I can think of counter cases easily enough, in the large iteration is less work and less vigilance. And you cannot scale a project up without the vigilance requirement amortizing basically to 0 per line of code.",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44869480,
    "by": "tombert",
    "timeISO": "2025-08-11T21:06:54.000Z",
    "textPlain": "I'm a pretty big functional programming nerd and I want to like tail recursion, but I honestly kind of feel like I agree with Guido on it, which is that it kind of breaks the typical stack-trace patterns.I have kind of grown to prefer Clojure's loop/recur construct, since it gives you something more or less akin to tail recursion but it doesn't pretend to be actually recursive.",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44870387,
    "by": "mehulashah",
    "timeISO": "2025-08-11T22:54:22.000Z",
    "textPlain": "Tail recursion is beautifully deep and simple. It (and as a corollary CPS) makes clear what state matters to your loop (and function) and avoids extraneous variables in loops as well as implicit unneeded state in functions. It also makes it easier to show the correctness of your loops. Sure, there are other functional language constructs like fold and map, if your problem is amenable to them. Tail recursion is more general and simpler.",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44869916,
    "by": "munchler",
    "timeISO": "2025-08-11T21:56:51.000Z",
    "textPlain": "Every developer should know how to write a tail-recursive function and understand why it is equivalent to a loop. That said, tail recursion is rarely needed in modern functional programming. For example, why write out a recursive function when a call to `fold` or `map` will do the same thing?",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44870385,
    "by": "wagwang",
    "timeISO": "2025-08-11T22:54:10.000Z",
    "textPlain": "Normal recursion is just a loop and a stack, turns out, if you can optimize recursion without a stack, it just becomes a loop.",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44870159,
    "by": "username3",
    "timeISO": "2025-08-11T22:23:39.000Z",
    "textPlain": "> I wrote up a detailed blog post about tail call optimization in Elixir/Erlang and its performance. The TLDR; sort of is that none tail call optimized recursive functions (body-recursive) can be faster and more memory efficient than TCO functions. This is something that I never thought before, that TCO is always faster seems to be a common misconception. My example is also not contrived - it’s an implementation of map.https://pragtob.wordpress.com/2016/06/16/tail-call-optimizat...",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44870415,
    "by": "tylerhou",
    "timeISO": "2025-08-11T22:58:58.000Z",
    "textPlain": "I disagree with the title; loops are tail-recursive functions, but tail-recursive functions are not loops (in the sense that squares are rectangles, but rectangles are not squares).It is true that every tail recursive function can be converted into a semantically equivalent loop via a transformation like CPS (which the author mentions). However, for mutually tail-recursive functions, this conversion loses control flow information. This is because after the CPS transformation, calls to the other function become calls to a continuation; this call usually must be implemented as an indirect jump. On the other hand, mutually tail-recursive functions can call each other with direct/statically-known jumps.This loss of information might appear trivial, but in practice it has some important consequences. Classic examples are interpreter loops. It is well-known that computed gotos can result in modest to large speedups for interpreters [1]. The reason why is that computed gotos create an indirect jump per opcode, so a branch predictor can take advantage of correlations between opcodes. For example, looking at Python disassembly, the header of a standard range for loop compiles down to three opcodes: GET_ITER, FOR_ITER, STORE_FAST in sequence [2]. A branch predictor can recognize that the target of the \"FOR_ITER\" indirect jump will likely be the \"STORE_FAST\" instruction pointer; it cannot predict this in the naive implementation where jumps for all instructions are \"merged\" into a single indirect jump / switch at the top of the loop body. In this case, computed goto is effectively equivalent to a CPS transformation whose closures require no storage on the heap.Suppose, however, we know even more information about the instruction sequence; for example, we know ahead of time that every FOR_ITER opcode will be followed by a STORE_FAST opcode. We could completely replace the indirect jump with a direct jump to the instruction pointer for the STORE_FAST opcode. Because modern branc",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44870124,
    "by": "aryonoco",
    "timeISO": "2025-08-11T22:20:45.000Z",
    "textPlain": "For what it’s worth, in F#, tail recursive functions are  turned into equivalent loops by the .NET CLR.I actually like the compromise. I get to write safe functional code while getting all the benefits of a highly optimised iterative operation.",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44870539,
    "by": "odyssey7",
    "timeISO": "2025-08-11T23:16:28.000Z",
    "textPlain": "Another foot-gun is to try to know your code is correct without mathematical induction. With loops, we implicitly reason in terms of loop-invariant properties of mutating variables, and using function calls instead makes those invariances explicit.Not every loop should be a recursive call, but labeling universally bad a foundational technique for rigorously thoughtful programming isn’t a good idea, either.You could view this in terms of levels of abstraction. Yes, you can translate tail recursion to a “jump,” just like you can translate C++ to assembly, but that doesn’t mean C++ is therefore a foot-gun to be avoided in favor of writing assembly.If you’re working with business logic, loops are pretty okay most of the time. If you’re working with complex algorithms, in many cases you’ll have a much easier time proving an implementation mathematically correct if you define it recursively.",
    "parent": 44869452,
    "depth": 2
  },
  {
    "id": 44869505,
    "by": "tombert",
    "timeISO": "2025-08-11T21:10:03.000Z",
    "textPlain": "In my mind, the biggest advantage to using tail recursion over vanilla loops is the ability to keep using persistent data structures without any (apparent) mutation.At least in theory, a tail recursive call will be converted into a dumb jump, so there shouldn't be a performance penalty, but since from your code's perspective you're passing in the stuff for the next iteration, you can keep using the pretty and easy-to-reason-about structures without creating any kind of mutable reference.I'm not 100% sold on tail recursion in a broader sense, but at least with Clojure's loop/recur stuff it is kind of cool to be able to keep using persistent data structures across iterations of loops.",
    "parent": 44869452,
    "depth": 2
  },
  {
    "id": 44870082,
    "by": "bjoli",
    "timeISO": "2025-08-11T22:15:52.000Z",
    "textPlain": "I am in the other camp. I prefer tail recursion and recursion over loops. However: For the simple cases it can and should probably be abstracted away like the racket for loops or my own goof-loop [1].I just feel that a recursive calls makes state much more clear, but then again I am no fan of mutation in general. In my old python days I think a good 60% of my bugs were due to me being bad at managing state.[1] https://rikspucko.koketteriet.se/bjoli/goof-loop",
    "parent": 44869452,
    "depth": 2
  },
  {
    "id": 44869756,
    "by": "javcasas",
    "timeISO": "2025-08-11T21:37:07.000Z",
    "textPlain": "Recursion deals with recursive data structures, and iteration deals with \"plain old\" data structures.When you use one to process the other, you get into trouble. For example, you need to manage a stack to do iteration on your binary tree. Or you need to construct slices to recurse on your arrays.It's all about ergonomics.",
    "parent": 44869452,
    "depth": 2
  },
  {
    "id": 44869605,
    "by": "CalChris",
    "timeISO": "2025-08-11T21:21:41.000Z",
    "textPlain": "I must have missed this class. How does one convert a recursive descent parser into an iterative one?",
    "parent": 44869452,
    "depth": 2
  },
  {
    "id": 44869980,
    "by": "Spivak",
    "timeISO": "2025-08-11T22:04:17.000Z",
    "textPlain": "I'm in your camp, recursive code is hard for the next reader, which might be you, to understand. It's a bit too magic looking for my taste. If you're looping it should look like a loop, if you're pushing  onto a stack you should get to see the stack. It's also safe against modifications which might silently break the tail-call nature of it until you blow out the stack later. It also gives you much saner and more debuggable stack traces because all the state is in the current frame.",
    "parent": 44869452,
    "depth": 2
  },
  {
    "id": 44869917,
    "by": "dreamcompiler",
    "timeISO": "2025-08-11T21:57:01.000Z",
    "textPlain": "Clojure does it this way because the JVM stupidly doesn't support tail call optimization.It is true that TCO messes up your stack traces. It is also true that loops mess up your stack traces, because they don't even create a stack trace. In many languages that support TCO, TCO can be turned off for debugging and enabled for production, so Guido's characterization of the issue is ridiculous.",
    "parent": 44869480,
    "depth": 2
  },
  {
    "id": 44870050,
    "by": "kmicinski",
    "timeISO": "2025-08-11T22:12:49.000Z",
    "textPlain": "I agree with you--that's a topic I will definitely cover in my blog, too. You make a good point: I know some folks who worked at big financial orgs, writing hundreds of thousands of lines of code, and never wrote general-recursive functions (only used simple recursors like foldl).",
    "parent": 44869916,
    "depth": 2
  },
  {
    "id": 44870033,
    "by": "Eji1700",
    "timeISO": "2025-08-11T22:10:18.000Z",
    "textPlain": "> For example, why write out a recursive function when a call to `fold` or `map` will do the same thing?Yeah this was a big help when I started F#.  Basically \"if you're using the rec keyword, you're probably missing something\" and hell that even goes for a lot of uses of fold, from the beginners perspective.",
    "parent": 44869916,
    "depth": 2
  },
  {
    "id": 44869999,
    "by": "xdavidliu",
    "timeISO": "2025-08-11T22:06:05.000Z",
    "textPlain": "it's not entirely true that it does the same thing: even if it gives the same result. For many programming languages, fold and map can only act on non-lazy data structures, so require O(N) memory for the data that needs to be folded over, while tail-recursive functions usually only use O(1) memory, even stack memory.Notable exceptions to the above are python3 with generators, which I believe truly use O(1) memory with map and fold. Haskell has lists that are lazy by default, but if you fold or map over them, it still \"forces the thunk\" for each element and thus you still end up using O(N) memory.",
    "parent": 44869916,
    "depth": 2
  }
]
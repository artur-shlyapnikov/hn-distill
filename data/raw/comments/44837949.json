[
  {
    "id": 44869452,
    "by": "hinkley",
    "timeISO": "2025-08-11T21:03:55.000Z",
    "textPlain": "Practically the day after I learned about tail recursion in CS class, I learned that almost all recursive calls can be translated to iteration, that in many cases the iterative version is easier to scan, is as fast if not faster, and that they can usually handle much much larger inputs than recursion due to avoiding stack overflow.Tail recursion is meant to fix the latter. But what we mean to happen and what actually happens ain't ever exactly similar.Tail recursion IME is a bigger foot gun than relying on someone to add a new conditional branch at the end of a block in an iterative algorithm without fucking it up in the process. And iteration responds generally better to Extract Function. And while I can think of counter cases easily enough, in the large iteration is less work and less vigilance. And you cannot scale a project up without the vigilance requirement amortizing basically to 0 per line of code.",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44869480,
    "by": "tombert",
    "timeISO": "2025-08-11T21:06:54.000Z",
    "textPlain": "I'm a pretty big functional programming nerd and I want to like tail recursion, but I honestly kind of feel like I agree with Guido on it, which is that it kind of breaks the typical stack-trace patterns.I have kind of grown to prefer Clojure's loop/recur construct, since it gives you something more or less akin to tail recursion but it doesn't pretend to be actually recursive.",
    "parent": 44837949,
    "depth": 1
  },
  {
    "id": 44869505,
    "by": "tombert",
    "timeISO": "2025-08-11T21:10:03.000Z",
    "textPlain": "In my mind, the biggest advantage to using tail recursion over vanilla loops is the ability to keep using persistent data structures without any (apparent) mutation.At least in theory, a tail recursive call will be converted into a dumb jump, so there shouldn't be a performance penalty, but since from your code's perspective you're passing in the stuff for the next iteration, you can keep using the pretty and easy-to-reason-about structures without creating any kind of mutable reference.I'm not 100% sold on tail recursion in a broader sense, but at least with Clojure's loop/recur stuff it is kind of cool to be able to keep using persistent data structures across iterations of loops.",
    "parent": 44869452,
    "depth": 2
  }
]
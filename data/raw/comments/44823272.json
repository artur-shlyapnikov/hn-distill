[
  {
    "id": 44860379,
    "by": "yuliyp",
    "timeISO": "2025-08-11T02:49:20.000Z",
    "textPlain": "In Hack, collection objects were one of the biggest early mistakes that the took a huge amount of effort to undo. It turns out that the copy-on-write semantics of PHP array were extremely important for performance and good APIs. Being able to pass arrays to things without fear of mutation allowed for tons of optimizations and not needing to copy things just in case. This is why Hack switched to using `dict`, `vec`, and `keyset` rather than collection objects.More generally, it's weird to see a whole blog post about generics for PHP not even mentioning Hack's generics designs. A lot of thought and iteration went into this like 5-10 years ago.See https://docs.hhvm.com/hack/arrays-and-collections/object-col... and https://docs.hhvm.com/hack/arrays-and-collections/vec-keyset...",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44858958,
    "by": "tobinfekkes",
    "timeISO": "2025-08-10T22:43:45.000Z",
    "textPlain": "Can someone smarter than me explain what they mean by \"reified generics\", \"erased generics\", and a use case for when to use one over the other?",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44859395,
    "by": "twiss",
    "timeISO": "2025-08-10T23:33:29.000Z",
    "textPlain": "I may be missing something about how the PHP compiler/interpreter works, but I don't quite understand why this is apparently feasible to implement:    class BlogPostRepository extends BaseRepository<BlogPost> { ... }\n    $repo = new BlogPostRepository();\n\nbut the following would be very hard:    $repo = new Repository<BlogPost>();\n\nThey write that the latter would need runtime support, instead of only compile time support. But why couldn't the latter be (compile time) syntactic sugar for the former, so to speak?(As long as you don't allow the generic parameter to be dynamic / unknown at compile time, of course.)",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44859717,
    "by": "SoftTalker",
    "timeISO": "2025-08-11T00:34:54.000Z",
    "textPlain": "In the sense of an affirmative vote, the proper word is \"yea.\"",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44859845,
    "by": "calvinmorrison",
    "timeISO": "2025-08-11T01:05:37.000Z",
    "textPlain": "write PHP a lot. every day.I wish we had typed arrays. Totally not gonna happen, theres been RFCs but I have enough boilerplate classes that are likeClass Option\nClass Options implements Iterator, countable, etc.Options[0], Options[1], Options[2]or Options->getOption('some.option.something');A lot of wrapper stuff like that is semi tedious, the implementation can vary wildly.Also because a lot of times in php you start with a generic array and decide you need structure around it so you implement a class, then you need an array of class,Not to mention a bunch of WSDLs that autogenerate ArrayOfString classes...",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44860733,
    "by": "somat",
    "timeISO": "2025-08-11T04:21:05.000Z",
    "textPlain": "I am not much of a programmer so I was trying to figure out what generics are. And I am sure they are great, but my inner gremlin goes in sarcastic tone \"we want these elaborate type systems, but we also want typeless because that is far more convenient to use, so we invented generics, a method to untype your type system\"But really while I was reading up on what generics are I went, isn't that just python, strongly typed but your functions don't have built in type checks.",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44860910,
    "by": "maxloh",
    "timeISO": "2025-08-11T05:14:42.000Z",
    "textPlain": "I thought Hack is dead or not intended for public use anymore.But after some quick checking, I learned that Hack is still actively maintained, surprisingly.",
    "parent": 44860379,
    "depth": 2
  },
  {
    "id": 44859047,
    "by": "gloryjulio",
    "timeISO": "2025-08-10T22:54:23.000Z",
    "textPlain": "Example, Java is using erased generics. Once the code is compiled, the generics information is no longer in the bytecode. List<String> becomes List<>. This is called type erasure.C# is using reified generics where this information is preserved. List<String> is still List<String> after compilation",
    "parent": 44858958,
    "depth": 2
  },
  {
    "id": 44859080,
    "by": "Gibbon1",
    "timeISO": "2025-08-10T22:57:33.000Z",
    "textPlain": "I'm not smarter than you but.I believe the terms reified generics and erased generics is the type sweaty donkey ball terminology you get for professional CS academics.Sticking my neck out further.Reified generics means the type is available at run time. In C# you can write if(obj.GetType() == typeof(typename))Erased generics the type information is not available at run time. That's the way Java does it and it kinda sucks.",
    "parent": 44858958,
    "depth": 2
  },
  {
    "id": 44859653,
    "by": "jasone",
    "timeISO": "2025-08-11T00:19:13.000Z",
    "textPlain": "The former merely exposes a `BlogPostRepository` class. The latter requires some mechanism for creating a generic object of concrete type, which is a lot bigger change to the implementation. Does each parametrized generic type have its own implementation? Or does each object have sufficient RTTI to dynamically dispatch? And what are the implications for module API data structures? Etc. In other words, this limitation avoids tremendously disruptive implementation impacts. Not pretty, but we're talking PHP here anyway. ;-)",
    "parent": 44859395,
    "depth": 2
  },
  {
    "id": 44860741,
    "by": "baobun",
    "timeISO": "2025-08-11T04:24:40.000Z",
    "textPlain": "Usually you are right. I assume the inability to sugar would be that \"because PHP\", the value/type of BlogPost can not be derived at compile-time?",
    "parent": 44859395,
    "depth": 2
  },
  {
    "id": 44860086,
    "by": "wesammikhail",
    "timeISO": "2025-08-11T01:47:21.000Z",
    "textPlain": "Nailed it.This is the core problem with PHP for me.I love PHP and use it every day. Part of that is the strength and versatility of the arrays implementation (i.e. hashmap). However, the problem is always the fact that an array cant be typed.IF they could just introduce that, it would solve 80% of user-land issues over night.",
    "parent": 44859845,
    "depth": 2
  },
  {
    "id": 44861290,
    "by": "masklinn",
    "timeISO": "2025-08-11T06:32:59.000Z",
    "textPlain": "> \"we want these elaborate type systems, but we also want typeless because that is far more convenient to use, so we invented generics, a method to untype your type system\"It's rather the exact opposite. Parametric types are a way to properly type \"deeply\" instead of just the topmost layer. Just like inference, type parameters don't remove types.> isn't that just python, strongly typed but your functions don't have built in type checks.That doesn't really make any sense? Static types mean you don't have runtime type checks, since the types are known statically.",
    "parent": 44860733,
    "depth": 2
  },
  {
    "id": 44860814,
    "by": "tibbar",
    "timeISO": "2025-08-11T04:49:26.000Z",
    "textPlain": "As you say, generics really only apply to typed languages, and they help solve very legitimate annoyance in most of those languages -- you often have some library helper or algorithm that can apply to a wide range of things, but those things differ in some way that's irrelevant to the algorithm.For example, a mergesort algorithm works on any kind of array, as long as you can compare the elements in the array to each other. There's no point in re-implementing the algorithm for each kind of array. Yet, without generics, you'd need to do just that. At the same time, the generated code for sorting each different kind of array might need to be a little different - comparing strings and floats isn't the same assembly, for instance. So the programming language and compiler work together: you specify the algorithm once in a certain way, and the compiler can generate the right version of algorithm for each way that you need to use it.There are many, many good reasons why you might want to work in a typed language, even though specifying the types is a bit of extra book-keeping; generics are one way to keep the pointless work down. Of course, if you can get away with a python script, there's no need to bother with all this typing business just yet, either.",
    "parent": 44860733,
    "depth": 2
  }
]
[
  {
    "id": 44860379,
    "by": "yuliyp",
    "timeISO": "2025-08-11T02:49:20.000Z",
    "textPlain": "In Hack, collection objects were one of the biggest early mistakes that the took a huge amount of effort to undo. It turns out that the copy-on-write semantics of PHP array were extremely important for performance and good APIs. Being able to pass arrays to things without fear of mutation allowed for tons of optimizations and not needing to copy things just in case. This is why Hack switched to using `dict`, `vec`, and `keyset` rather than collection objects.More generally, it's weird to see a whole blog post about generics for PHP not even mentioning Hack's generics designs. A lot of thought and iteration went into this like 5-10 years ago.See https://docs.hhvm.com/hack/arrays-and-collections/object-col... and https://docs.hhvm.com/hack/arrays-and-collections/vec-keyset...",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44861863,
    "by": "rob74",
    "timeISO": "2025-08-11T08:17:51.000Z",
    "textPlain": "So, PHP started off as a loosely typed language, then got types... and now they want to implement generics to have more loosely typed code? But as I understand it, types are still optional, so you can still use untyped variables for \"generic\" code? I'm probably missing something here, is it because of performance concerns? Or the edge case of absolutely wanting strongly typed PHP throughout (except for the part where they want generics)?",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44858958,
    "by": "tobinfekkes",
    "timeISO": "2025-08-10T22:43:45.000Z",
    "textPlain": "Can someone smarter than me explain what they mean by \"reified generics\", \"erased generics\", and a use case for when to use one over the other?",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44861481,
    "by": "johnisgood",
    "timeISO": "2025-08-11T07:08:32.000Z",
    "textPlain": "Nay, enough of complexity as it is, for now.",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44859395,
    "by": "twiss",
    "timeISO": "2025-08-10T23:33:29.000Z",
    "textPlain": "I may be missing something about how the PHP compiler/interpreter works, but I don't quite understand why this is apparently feasible to implement:    class BlogPostRepository extends BaseRepository<BlogPost> { ... }\n    $repo = new BlogPostRepository();\n\nbut the following would be very hard:    $repo = new Repository<BlogPost>();\n\nThey write that the latter would need runtime support, instead of only compile time support. But why couldn't the latter be (compile time) syntactic sugar for the former, so to speak?(As long as you don't allow the generic parameter to be dynamic / unknown at compile time, of course.)",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44859717,
    "by": "SoftTalker",
    "timeISO": "2025-08-11T00:34:54.000Z",
    "textPlain": "In the sense of an affirmative vote, the proper word is \"yea.\"",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44860733,
    "by": "somat",
    "timeISO": "2025-08-11T04:21:05.000Z",
    "textPlain": "I am not much of a programmer so I was trying to figure out what generics are. And I am sure they are great, but my inner gremlin goes in sarcastic tone \"we want these elaborate type systems, but we also want typeless because that is far more convenient to use, so we invented generics, a method to untype your type system\"But really while I was reading up on what generics are I went, isn't that just python, strongly typed but your functions don't have built in type checks.",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44859845,
    "by": "calvinmorrison",
    "timeISO": "2025-08-11T01:05:37.000Z",
    "textPlain": "write PHP a lot. every day.I wish we had typed arrays. Totally not gonna happen, theres been RFCs but I have enough boilerplate classes that are likeClass Option\nClass Options implements Iterator, countable, etc.Options[0], Options[1], Options[2]or Options->getOption('some.option.something');A lot of wrapper stuff like that is semi tedious, the implementation can vary wildly.Also because a lot of times in php you start with a generic array and decide you need structure around it so you implement a class, then you need an array of class,Not to mention a bunch of WSDLs that autogenerate ArrayOfString classes...",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44861359,
    "by": "noelwelsh",
    "timeISO": "2025-08-11T06:45:59.000Z",
    "textPlain": "The introduction to me reads as very confused:One of the most sought-after features for PHP is Generics: The ability to have a type that takes another type as a parameter. It's a feature found in most compiled languages by now, but implementing generics in an interpreted language like PHP, where all the type checking would have to be done at runtime, has always proven Really Really Hard(tm), Really Really Slow(tm), or both.* The topic of the article is implementing generics at compile time, but this claims that PHP is not compiled.* Type checking is orthogonal to compilation vs interpreter.* Types are not checked at runtime. It is kinda the point of types that they are checked before code runs. Runtime checks are on values. You can reify types at runtime but this breaks a useful property of generics (parametricity) and it prevents the very useful feature of types without a runtime representation (often known as newtypes).* If you want to use types in the colloquial \"dynamic type\" meaning as tags on values, and you also want to talk about generics (a feature that only makes sense for types-as-compile-time-properties) you need to be really careful in your terminology or confusion will abound!",
    "parent": 44823272,
    "depth": 1
  },
  {
    "id": 44860910,
    "by": "maxloh",
    "timeISO": "2025-08-11T05:14:42.000Z",
    "textPlain": "I thought Hack is dead or not intended for public use anymore.But after some quick checking, I learned that Hack is still actively maintained, surprisingly.",
    "parent": 44860379,
    "depth": 2
  },
  {
    "id": 44862016,
    "by": "purerandomness",
    "timeISO": "2025-08-11T08:43:48.000Z",
    "textPlain": "Today, the vast majority of commercial PHP projects are developed enforcing the use of strong types by static analyzers like PHPStan in the CI pipeline, and having the strict_types declaration set.As a community, we've seen enough untyped PHP spaghetti code in the early 2000s and never want to go back there.",
    "parent": 44861863,
    "depth": 2
  },
  {
    "id": 44862107,
    "by": "actionfromafar",
    "timeISO": "2025-08-11T08:58:28.000Z",
    "textPlain": "Generics are not equivalent to loose types.",
    "parent": 44861863,
    "depth": 2
  },
  {
    "id": 44862267,
    "by": "meindnoch",
    "timeISO": "2025-08-11T09:21:12.000Z",
    "textPlain": "With reified generics, the code  class Foo<X> {\n    X x;\n  }\n\n  Foo<int> fooInt;\n  fooInt.x = 5;\n  Foo<float> fooFloat;\n  fooFloat.x = 5.0;\n\ncompiles to:  class Foo_int {\n    int x;\n  }\n\n  class Foo_float {\n    float x;\n  }\n\n  Foo_int fooInt;\n  fooInt.x = 5;\n  Foo_float fooFloat;\n  fooFloat.x = 5.0;\n\nOn the other hand, erased generics compiles to this:  class Foo {\n    void* x;\n  }\n\n  Foo fooInt;\n  fooInt.x = new int(5);\n  Foo fooFloat;\n  fooFloat.x = new float(5.0);",
    "parent": 44858958,
    "depth": 2
  },
  {
    "id": 44859047,
    "by": "gloryjulio",
    "timeISO": "2025-08-10T22:54:23.000Z",
    "textPlain": "Example, Java is using erased generics. Once the code is compiled, the generics information is no longer in the bytecode. List<String> becomes List<>. This is called type erasure.C# is using reified generics where this information is preserved. List<String> is still List<String> after compilation",
    "parent": 44858958,
    "depth": 2
  },
  {
    "id": 44859080,
    "by": "Gibbon1",
    "timeISO": "2025-08-10T22:57:33.000Z",
    "textPlain": "I'm not smarter than you but.I believe the terms reified generics and erased generics is the type sweaty donkey ball terminology you get for professional CS academics.Sticking my neck out further.Reified generics means the type is available at run time. In C# you can write if(obj.GetType() == typeof(typename))Erased generics the type information is not available at run time. That's the way Java does it and it kinda sucks.",
    "parent": 44858958,
    "depth": 2
  },
  {
    "id": 44859653,
    "by": "jasone",
    "timeISO": "2025-08-11T00:19:13.000Z",
    "textPlain": "The former merely exposes a `BlogPostRepository` class. The latter requires some mechanism for creating a generic object of concrete type, which is a lot bigger change to the implementation. Does each parametrized generic type have its own implementation? Or does each object have sufficient RTTI to dynamically dispatch? And what are the implications for module API data structures? Etc. In other words, this limitation avoids tremendously disruptive implementation impacts. Not pretty, but we're talking PHP here anyway. ;-)",
    "parent": 44859395,
    "depth": 2
  },
  {
    "id": 44860741,
    "by": "baobun",
    "timeISO": "2025-08-11T04:24:40.000Z",
    "textPlain": "Usually you are right. I assume the inability to sugar would be that \"because PHP\", the value/type of BlogPost can not be derived at compile-time?",
    "parent": 44859395,
    "depth": 2
  },
  {
    "id": 44860814,
    "by": "tibbar",
    "timeISO": "2025-08-11T04:49:26.000Z",
    "textPlain": "As you say, generics really only apply to typed languages, and they help solve very legitimate annoyance in most of those languages -- you often have some library helper or algorithm that can apply to a wide range of things, but those things differ in some way that's irrelevant to the algorithm.For example, a mergesort algorithm works on any kind of array, as long as you can compare the elements in the array to each other. There's no point in re-implementing the algorithm for each kind of array. Yet, without generics, you'd need to do just that. At the same time, the generated code for sorting each different kind of array might need to be a little different - comparing strings and floats isn't the same assembly, for instance. So the programming language and compiler work together: you specify the algorithm once in a certain way, and the compiler can generate the right version of algorithm for each way that you need to use it.There are many, many good reasons why you might want to work in a typed language, even though specifying the types is a bit of extra book-keeping; generics are one way to keep the pointless work down. Of course, if you can get away with a python script, there's no need to bother with all this typing business just yet, either.",
    "parent": 44860733,
    "depth": 2
  },
  {
    "id": 44861290,
    "by": "masklinn",
    "timeISO": "2025-08-11T06:32:59.000Z",
    "textPlain": "> \"we want these elaborate type systems, but we also want typeless because that is far more convenient to use, so we invented generics, a method to untype your type system\"It's rather the exact opposite. Parametric types are a way to properly type \"deeply\" instead of just the topmost layer. Just like inference, type parameters don't remove types.> isn't that just python, strongly typed but your functions don't have built in type checks.That doesn't really make any sense? Static types mean you don't have runtime type checks, since the types are known statically.",
    "parent": 44860733,
    "depth": 2
  },
  {
    "id": 44862208,
    "by": "bakje",
    "timeISO": "2025-08-11T09:12:54.000Z",
    "textPlain": "We used to have a lot of classes like that, but for us PHPStan is sufficient and we effectively have generics now through static analysis warning us of improper usage of types in our CI and IDEs.Is this not suitable for you?",
    "parent": 44859845,
    "depth": 2
  },
  {
    "id": 44860086,
    "by": "wesammikhail",
    "timeISO": "2025-08-11T01:47:21.000Z",
    "textPlain": "Nailed it.This is the core problem with PHP for me.I love PHP and use it every day. Part of that is the strength and versatility of the arrays implementation (i.e. hashmap). However, the problem is always the fact that an array cant be typed.IF they could just introduce that, it would solve 80% of user-land issues over night.",
    "parent": 44859845,
    "depth": 2
  },
  {
    "id": 44862055,
    "by": "noelwelsh",
    "timeISO": "2025-08-11T08:48:55.000Z",
    "textPlain": "Addition, as I missed the edit window.I wish they would elaborate on what Really Really Hard(tm) means. From a high-level I believe everything they are concerned with has been researched as part of the work on contract by Robby Findler and collaborators. E.g. https://users.cs.northwestern.edu/~robby/pubs/papers/popl201...",
    "parent": 44861359,
    "depth": 2
  },
  {
    "id": 44861899,
    "by": "oaiey",
    "timeISO": "2025-08-11T08:25:21.000Z",
    "textPlain": "PHP afair compiles the textual PHP into some intermediate which is then run. So there is a compilation stage.",
    "parent": 44861359,
    "depth": 2
  }
]
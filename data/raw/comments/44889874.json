[
  {
    "id": 44898983,
    "by": "santa_boy",
    "timeISO": "2025-08-14T11:00:51.000Z",
    "textPlain": "Yet to explore but just reading few snippets ... is this good for offline first apps?If not, any others you recommend for that use-case?If yet, is this ready enough for production use?",
    "parent": 44889874,
    "depth": 1
  },
  {
    "id": 44898937,
    "by": "RestartKernel",
    "timeISO": "2025-08-14T10:53:00.000Z",
    "textPlain": "I love the API, but it's a tough sell as a SaaS first — who knows if you'll still be around after I've built my infra around your SDK?",
    "parent": 44889874,
    "depth": 1
  },
  {
    "id": 44897760,
    "by": "taherchhabra",
    "timeISO": "2025-08-14T07:37:28.000Z",
    "textPlain": "Just yesterday my son built a zombie shooter game in chatgpt, then shared the link with his friend, both were able to play individually, then my son asked can we play together and shoot each other. I was wondering is there something like localstorage but for network which chatgpt can easily use it. Can this work for my son's use case?",
    "parent": 44889874,
    "depth": 1
  },
  {
    "id": 44898749,
    "by": "larikk",
    "timeISO": "2025-08-14T10:15:53.000Z",
    "textPlain": "[dead]",
    "parent": 44889874,
    "depth": 1
  },
  {
    "id": 44899076,
    "by": "adrai",
    "timeISO": "2025-08-14T11:14:42.000Z",
    "textPlain": "Hey, thanks for the great questions!Offline-first: That's a key distinction. The Vaultrice SDK is currently designed for \"online-first\" and \"offline-sometimes\" use cases. Its main strength is real-time, consistent synchronization that relies on an active connection.Proper offline-first support with automatic conflict resolution is on our roadmap, as we have a backlog item for it ;-) However, you can easily achieve a robust offline capability in your own code today by using localStorage as a fallback.Here’s a simple wrapper pattern (not tested, just for illustration) that reads from Vaultrice when online and falls back to a local cache when offline:import { NonLocalStorage } from '@vaultrice/sdk';// --- A simple offline-first wrapper ---\nfunction createOfflineStore(credentials, id) {\n  const vaultriceStore = new NonLocalStorage(credentials, id);\n  const localCacheKey = `vaultrice_cache_${id}`;  // Helper to get local data\n  const getLocal = () => JSON.parse(localStorage.getItem(localCacheKey) || '{}');\n\n  return {\n    // SET: Write to both Vaultrice (if online) and localStorage\n    async setItem(key, value) {\n      // Always update the local cache immediately\n      const localData = getLocal();\n      localData[key] = value;\n      localStorage.setItem(localCacheKey, JSON.stringify(localData));\n\n      try {\n        // Attempt to write to the cloud\n        await vaultriceStore.setItem(key, value);\n      } catch (error) {\n        console.warn('Offline: Data saved locally.', error.message);\n      }\n    },\n\n    // GET: Try Vaultrice first, fallback to localStorage\n    async getItem(key) {\n      try {\n        const item = await vaultriceStore.getItem(key);\n        if (item) {\n            // Optional: Update local cache with fresh data\n            const localData = getLocal();\n            localData[key] = item.value;\n            localStorage.setItem(localCacheKey, JSON.stringify(localData));\n            return item.value;\n        }\n      } catch (error) {\n        console.war",
    "parent": 44898983,
    "depth": 2
  },
  {
    "id": 44898953,
    "by": "adrai",
    "timeISO": "2025-08-14T10:55:19.000Z",
    "textPlain": "The team behind vaultrice.com is the same team behind locize.com and i18next.com...",
    "parent": 44898937,
    "depth": 2
  },
  {
    "id": 44898143,
    "by": "adrai",
    "timeISO": "2025-08-14T08:31:41.000Z",
    "textPlain": "Yes — that’s exactly the kind of thing Vaultrice is designed for.Think of it like localStorage, but instead of being tied to one browser on one device, the data lives in a globally-available, real-time object. Any change one player makes (like moving their character or firing a shot) can be sent instantly to the other player’s browser — without having to set up your own server or WebSocket layer.For your son’s zombie shooter:\n • Each game session could be one Vaultrice “object” (with an id like game-123).\n • Each player writes their position, health, actions to that object.\n • The other player’s browser listens for changes and updates the game state instantly.\n • Presence tracking is built-in, so you can show “who’s in the game” without extra code.The nice part is that the SDK’s API feels familiar — setItem, getItem, and on() for events — so you can get a working multiplayer prototype with just a few lines. If you want even less boilerplate, the SyncObject API lets you just set properties on a shared object and Vaultrice syncs it behind the scenes.It won’t handle game physics for you, but it’s a fast, simple way to make a turn-based or moderately real-time multiplayer experience without hosting your own backend.",
    "parent": 44897760,
    "depth": 2
  }
]
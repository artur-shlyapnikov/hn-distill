[
  {
    "id": 44865251,
    "by": "teo_zero",
    "timeISO": "2025-08-11T15:28:46.000Z",
    "textPlain": "Clever, but it misses the very goal of option/maybe types: forcing the user to check the result. In this implementation nothing stops the user from omitting the \"if (p.ok)\" part and directly using \"p.value\".It could work if \"maybe(T)\" is completely opaque to the user; both checking and accessing its payload must happen through helper macros; the checking macro ticks an invisible flag if ok; the accessing macro returns the payload only if the invisible flag is ticked, otherwise it triggers a runtime error/exception.Not impossible. However, you would need to replace all \"p.ok\" with \"maybe_check(p)\", which is not unreasonable, and all \"p.value\" with \"maybe_value(p)\", which might be too much for the final user...",
    "parent": 44860908,
    "depth": 1
  },
  {
    "id": 44861689,
    "by": "nly",
    "timeISO": "2025-08-11T07:45:52.000Z",
    "textPlain": "GCC generates essentially the same assembly for C++'s std::optional<int> with the exception that the result can't be returned in a register (a problem which will go away if the function is inlined)https://gcc.godbolt.org/z/vfzK9Toz4",
    "parent": 44860908,
    "depth": 1
  },
  {
    "id": 44862441,
    "by": "nextaccountic",
    "timeISO": "2025-08-11T09:45:28.000Z",
    "textPlain": ">  Here, instead of handling the error condition, I create an lvalue that points nowhere in case of an error because it then corresponds to (({ (void)0; })), relying on the null sanitizer to transform it into a run-time trap for safety.Isn't this undefined behavior?",
    "parent": 44860908,
    "depth": 1
  },
  {
    "id": 44863221,
    "by": "BiraIgnacio",
    "timeISO": "2025-08-11T11:58:26.000Z",
    "textPlain": "I love seeing the creative ways people implement these types of, if I can say, high level abstractions in C.\nThanks for sharing",
    "parent": 44860908,
    "depth": 1
  },
  {
    "id": 44863074,
    "by": "yobbo",
    "timeISO": "2025-08-11T11:37:54.000Z",
    "textPlain": "It might be more useful with a signature like maybe_divide -> maybe(int) -> maybe(int) -> maybe(int) ... and then a set of operations over maybe, and functions/macros for and_then(), or_else(), etc. It would be interesting to see how ergonomic it could get.",
    "parent": 44860908,
    "depth": 1
  },
  {
    "id": 44862546,
    "by": "rowanG077",
    "timeISO": "2025-08-11T10:03:08.000Z",
    "textPlain": "At this point I always wonder why people who write stuff like this don't just move to a different language. You are introducing insane amounts of hidden complexity(see also the other posts on that blog). For something that just exists in other languages. Or maybe this is just a fun puzzle for the author, in which case it's totally fine.",
    "parent": 44860908,
    "depth": 1
  },
  {
    "id": 44862681,
    "by": "pjmlp",
    "timeISO": "2025-08-11T10:25:46.000Z",
    "textPlain": "Proving the point that better type system and abstractions don't necessarly produce bad Assembly, and if constexpr is used, there won't be anything on the final executable other than the actual value.https://gcc.godbolt.org/z/31o75W5xxhttps://gcc.godbolt.org/z/av6a43WeY",
    "parent": 44861689,
    "depth": 2
  },
  {
    "id": 44863067,
    "by": "account42",
    "timeISO": "2025-08-11T11:36:52.000Z",
    "textPlain": "> with the exception that the result can't be returned in a register (a problem which will go away if the function is inlined)It's still a damned shame. Same for not being able to pass optional/unique_ptr/etc in a register.We really need a trivially_relocatable attribute.",
    "parent": 44861689,
    "depth": 2
  },
  {
    "id": 44862019,
    "by": "uecker",
    "timeISO": "2025-08-11T08:44:43.000Z",
    "textPlain": "Yeah it a amazing a far C++ has come, soon it will be almost as good as C.",
    "parent": 44861689,
    "depth": 2
  },
  {
    "id": 44862196,
    "by": "wahern",
    "timeISO": "2025-08-11T09:11:13.000Z",
    "textPlain": "Is this because std::optional isn't trivially constructible?",
    "parent": 44861689,
    "depth": 2
  },
  {
    "id": 44863550,
    "by": "uecker",
    "timeISO": "2025-08-11T12:48:01.000Z",
    "textPlain": "It is only undefined behavior if it is dereferenced, in which case the null sanitizer can be used to define it to trap, so safely terminate the program. But the example then also shows how you can make sure that this case is not even possible in the final program.",
    "parent": 44862441,
    "depth": 2
  },
  {
    "id": 44864193,
    "by": "layer8",
    "timeISO": "2025-08-11T14:04:29.000Z",
    "textPlain": "The null sanitizer is used to define the behavior, which is one of the ways a C implementation is allowed to handle situations whose behavior the C standard leaves undefined.",
    "parent": 44862441,
    "depth": 2
  },
  {
    "id": 44862462,
    "by": "lmm",
    "timeISO": "2025-08-11T09:49:25.000Z",
    "textPlain": "In standard C yes. But any decent C compiler will offer stronger guarantees than the minimum that the standard requires, and presumably the \"null sanitizer\" they're referring to is one of them.",
    "parent": 44862441,
    "depth": 2
  },
  {
    "id": 44862516,
    "by": "shakna",
    "timeISO": "2025-08-11T09:58:30.000Z",
    "textPlain": "Maybe, but it is defined for GCC:> You can store a null pointer in any lvalue whose data type is a pointer type. [0]Though, I would expect a complaint from clang, and clang-tidy.[0] https://www.gnu.org/software/c-intro-and-ref/manual/html_nod...",
    "parent": 44862441,
    "depth": 2
  },
  {
    "id": 44863483,
    "by": "munchler",
    "timeISO": "2025-08-11T12:37:49.000Z",
    "textPlain": "I await the first “Monads in C” tutorial with mixed feelings.",
    "parent": 44863074,
    "depth": 2
  },
  {
    "id": 44863940,
    "by": "dazzawazza",
    "timeISO": "2025-08-11T13:38:27.000Z",
    "textPlain": "Other languages internalise that complexity. C leaves it bare, human scale and understandable.The speed at which you can write great C code often far outstrips other languages which are applicable to the problem domain.All languages are a compromise, there are no silver bullets.",
    "parent": 44862546,
    "depth": 2
  },
  {
    "id": 44862571,
    "by": "throw-qqqqq",
    "timeISO": "2025-08-11T10:09:04.000Z",
    "textPlain": "You don’t always get to choose your language. Especially in the embedded/firmware area of software development, C is the most widely available option, if not the only option besides ASM shrugs",
    "parent": 44862546,
    "depth": 2
  },
  {
    "id": 44862997,
    "by": "amiga386",
    "timeISO": "2025-08-11T11:25:54.000Z",
    "textPlain": "Quite. There's standard POSIX behaviour for this. Divide by zero and execution continues, safely, in your SIGFPE exception handler.",
    "parent": 44862546,
    "depth": 2
  },
  {
    "id": 44863097,
    "by": "uecker",
    "timeISO": "2025-08-11T11:40:39.000Z",
    "textPlain": "Because the different languages suck much more.",
    "parent": 44862546,
    "depth": 2
  }
]
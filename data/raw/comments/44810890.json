[
  {
    "id": 44853819,
    "by": "hesus_ruiz",
    "timeISO": "2025-08-10T08:56:20.000Z",
    "textPlain": "It is very strange that a post trying to explain the concept of \"let it crash\" in Elixir (which runs on the BEAM VM) does not mention the doctoral thesis of Joe Armstrong: \"Making reliable distributed systems in the presence of software errors\".It must be compulsory lecture for anybody interested in reliable systems, even if they do not use the BEAM VM.https://www.diva-portal.org/smash/record.jsf?pid=diva2%3A104...",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852934,
    "by": "valenterry",
    "timeISO": "2025-08-10T05:17:39.000Z",
    "textPlain": "There are a few stages, and each improves on the previous ones:1. Detect crashes at runtime and by default stop/crash to prevent continuing with invalid program state2. Detect crashes at runtime and handle them according to the business context (e.g. crash or retry or fallback-to or ...) to prevent bad UX through crashes.3. Detect potential crashes at compile-time to prevent the dev from forgetting to handle them according to the business context4. Don't just detect the possibility of crashes but also the specific type and context to prevent the dev from making a logical mistake and causing a potential runtime error during error handling according to the business contextAn example for stage 4 would be that the compiler checks that a fall-back option will actually always resolve the errors and not potentially introduce a new error / error type. Such as falling back to another URL does not actually always resolve the problem, there still needs to be handling for when the request to the alternative URL fails.The philosophy described in the article is basically just stage 1 and a (partial) default restart instead of a default crash, which is maybe a slight improvement but not really sufficient, at least not by my personal standards.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852658,
    "by": "goosejuice",
    "timeISO": "2025-08-10T03:59:21.000Z",
    "textPlain": "https://erlang.org/pipermail/erlang-questions/2003-March/007...The origin, as far as I know it. I think it still holds, is insightful, as a general case. Let it heal seems pretty close to what Joe was getting at.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44854620,
    "by": "stcg",
    "timeISO": "2025-08-10T12:01:39.000Z",
    "textPlain": "\"Let it crash\" is a sentence that gets attention. It makes a person want to know more about it, as it sounds controversial and different. \"Let it heal\" doesn't have that.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44854260,
    "by": "tmcb",
    "timeISO": "2025-08-10T10:40:18.000Z",
    "textPlain": "It is very common to interpret taglines by their face value, and I believe the author did just that, although the point brought up is valid.In order to “let it crash”, we must design the system in a way that crashes would not be catastrophic, stability wise. Letting it crash is not a commandment, though: it is a reminder that, in most cases, a smart healing strategy might be overkill.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852737,
    "by": "HexDecOctBin",
    "timeISO": "2025-08-10T04:23:07.000Z",
    "textPlain": "How does restarting the process fix the crash? If the process crashed because a file was missing, it will still be missing when the process is restarted. Is an infinite crash-loop considered success in Erlang?",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44854207,
    "by": "IshKebab",
    "timeISO": "2025-08-10T10:28:58.000Z",
    "textPlain": "Ah this makes sense. I always thought \"let it crash\" made it sound like Elixir devs just don't bother with error checking, like writing Java without any `catch`es, or writing Rust that only uses `.unwrap()`.If they just mean \"processes should be restartable\" then that sounds way more reasonable. Similar idea to this but less fancy: https://flawless.dev/It's a pretty terrible slogan if it makes your language sound worse than it actually is.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852463,
    "by": "bgdkbtv",
    "timeISO": "2025-08-10T03:01:11.000Z",
    "textPlain": "This is great, thanks for sharing! I've been thinking about improving error handling in my liveview app and this might be a nice way to start.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44853160,
    "by": "praptak",
    "timeISO": "2025-08-10T06:20:11.000Z",
    "textPlain": "A condition that \"should not happen\" might still be a problem specific to a particular request. If you \"just crash\" it turns this request from one that only triggers a http 500 response to one that crashes the process. This increases the risk of Query of Death scenarios where the frontend that needs to serve this particular request starts retrying it with different backends and triggers restarts faster than the processes come back up.So being too eager to \"just crash\" may turn a scenario where you fail to serve 1% of requests into a scenario where you serve none because all your processes keep restarting.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852663,
    "by": "refactor_master",
    "timeISO": "2025-08-10T04:01:11.000Z",
    "textPlain": "Question as a complete outsider: If I run idempotent Python applications in Kubernetes containers and they crash, Kubernetes will eventually restart them. Of course, knowing what to do on IO errors is nicer than destroying and restarting everything with a really bigger hammer (as the article also mentions, you can serve a better error message for whoever has to “deal” with the problem), but eventually they should end up in the same workable state.Is this conceptually similar, but perhaps at code-level instead?",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44855148,
    "by": "juped",
    "timeISO": "2025-08-10T13:43:11.000Z",
    "textPlain": "There's really not more that's useful to say than the relevant section (4.4) of Joe Armstrong's thesis says:>How does our philosophy of handling errors fit in with coding practices? What kind of code must the programmer write when they find an error? The philosophy is let some other process fix the error, but what does this mean for their code? The answer is let it crash. By this I mean that in the event of an error, then the program should just crash. But what is an error? For programming purpose we can say that:>• exceptions occur when the run-time system does not know what to do.>• errors occur when the programmer doesn’t know what to do.>If an exception is generated by the run-time system, but the programmer had foreseen this and knows what to do to correct the condition that caused the exception, then this is not an error. For example, opening a file which does not exist might cause an exception, but the programmer might decide that this is not an error. They therefore write code which traps this exception and takes the necessary corrective action.>Errors occur when the programmer does not know what to do. Programmers are supposed to follow specifications, but often the specification does not say what to do and therefore the programmer does not know what to do.>[...]>The defensive code detracts from the pure case and confuses the reader—the diagnostic is often no better than the diagnostic which the compiler supplies automatically.Note that this \"program\" is a process. For a process doing work, encountering something it can't handle is an error per the above definitions, and the process should just die, since there's nothing better for it to do; for a supervisor process supervising such processes-doing-work, \"my child process exited\" is an exception at worst, and usually not even an exception since the standard library supervisor code already handles that.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852961,
    "by": "monkeyelite",
    "timeISO": "2025-08-10T05:26:12.000Z",
    "textPlain": "This seems specific to BEAM as crashing a fast-cgi process is fine and response will be handled correctly with Apache or nginx.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44853716,
    "by": "anthk",
    "timeISO": "2025-08-10T08:29:33.000Z",
    "textPlain": "Unix/BSD -> Crash, fix, restart.GNU/MIT/Lisp -> Detect, offer a fix, continue.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852730,
    "by": "adastra22",
    "timeISO": "2025-08-10T04:21:29.000Z",
    "textPlain": "“Reset on error” might be a better phrasing.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852476,
    "by": "bitwize",
    "timeISO": "2025-08-10T03:04:52.000Z",
    "textPlain": "I don't code in Erlang or Elixir, aside from messing about. But I've found that letting an entire application crash is something that I can do under certain circumstances, especially when \"you have a very big problem and will not go to space today\". For example, if there's an error reading some piece of data that's in the application bundle and is needed to legitimately start up in the first place (assets for my game for instance). Then upon error it just \"screams and dies\" (spits out a stack trace and terminates).",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852820,
    "by": "BobbyTables2",
    "timeISO": "2025-08-10T04:48:50.000Z",
    "textPlain": "Hackers also love auto-restarting services.Exploitation of vulnerabilities isn’t always 100% reliable.  Heap grooming might be limited or otherwise inadequate.A quick automatic restart keeps them in business without any other human interaction involved.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44853844,
    "by": "PicassoCTs",
    "timeISO": "2025-08-10T09:02:02.000Z",
    "textPlain": "https://fsharpforfunandprofit.com/rop/Railway orientated programming to the rescue?",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44853280,
    "by": "atoav",
    "timeISO": "2025-08-10T06:51:19.000Z",
    "textPlain": "The truth is that different errors have to lead to different results if you want a good organisational outcome. These could be:- Fundamental/Fatal error: something without the process cannot function, e.g. we are missing an essential config option. Exiting with an error is totally adequate. You can't just heal from that as it would involve guessing information you don't have. Admins need to fix it- Critical error: something that should not ever occur, e.g. having an active user without password and email. You don't exit, you skip it if thst is possible and ensure the first occurance is logged and admins are contacted- Expected/Regular error: something that is expected to happen during the normal operations of the service, e.g. the other server you make requests to is being restarted and thus unreachable. Here the strategy may vary, but it could be something like retrying with random exponential backoff. Or you could briefly accept the values provided by that server are unknown and periodically retry to fill the unknown values. Or you could escalate that into a critical error after a certain amount of retries.- Warnings: These are usually about something being not exactly ideal, but do not impede with the flow of the program at all. Usually has to do with bad data qualityIf you can proceed without degrading the integrity of the system you should, the next thing is to decide jow important it is for humans to hear about it.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44853095,
    "by": "snickerbockers",
    "timeISO": "2025-08-10T06:04:35.000Z",
    "textPlain": ">When people say “let it crash”, they are referring to the fact that practically any exited process in your application will be subsequently restarted. Because of this, you can often be much less defensive around unexpected errors. You will see far fewer try/rescue, or matching on error states in Elixir code.I just threw up in my mouth when I read this.  I've never used this language so maybe my experience doesn't apply here but I'm imagining all the different security implications that ive seen arise from failing to check error codes.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44853782,
    "by": "creatonez",
    "timeISO": "2025-08-10T08:43:42.000Z",
    "textPlain": "Based on your list there is an opportunity to define stage -1 of error handling sanity, the Eval-Rinse-Reload loop, as implemented by FuckItJS, the original Javascript Error Steamroller: https://github.com/mattdiamond/fuckitjs> Through a process known as Eval-Rinse-Reload-And-Repeat, FuckItJS repeatedly compiles your code, detecting errors and slicing those lines out of the script. To survive such a violent process, FuckItJS reloads itself after each iteration, allowing the onerror handler to catch every single error in your terribly written code.> [...]> This will keep evaluating your code until all errors have been sliced off like mold on a piece of perfectly good bread. Whether or not the remaining code is even worth executing, we don't know. We also don't particularly care.",
    "parent": 44852934,
    "depth": 2
  },
  {
    "id": 44853728,
    "by": "vrnvu",
    "timeISO": "2025-08-10T08:31:22.000Z",
    "textPlain": ">>This organization  corresponds   nicely  to   a   idealized  human\norganization of  bosses and workers -  bosses say what is  to be done,\nworkers do stuff.  Bosses do quality control and check that things get\ndone, if not they fire people  re-organize and tell other people to do\nthe stuff.  If  they fail (the bosses) they get  sacked etc.  <<note I\nsaid, idealized organization, usually  if projects fail the bosses get\npromoted and given more workers for their next project>>We miss you Joe :)",
    "parent": 44852658,
    "depth": 2
  },
  {
    "id": 44855290,
    "by": "jonhohle",
    "timeISO": "2025-08-10T14:07:47.000Z",
    "textPlain": "It also has a deeper philosophical meaning of unexpected software bugs should be noisy and obvious instead of causing silently corruption or misleading user experience. If monitoring doesn’t catch the failure, customers will and it can be fixed right away (whether it’s the software, a hardware error, dependency issue, etc.).A web service returning a 500 error code is a lot more obvious than a 200 with an invalid payload. A crashed app with a stack trace is easier to debug and will cause more user feedback than an app than hangs in a retry loop.When I had to deal with these things in the Java world, it meant not blindly handling or swallowing exceptions that business code had no business caring about. Does your account management code really think it knows how to properly handle an InterruptedException? Unless your answer is rollback and reset the interrupted flag it’s probably wrong. Can’t write a test for a particular failure scenario? That better blow up loudly with enough context that makes it possible to understand the error condition (and then write a test for it).",
    "parent": 44854620,
    "depth": 2
  },
  {
    "id": 44854293,
    "by": "borromakot",
    "timeISO": "2025-08-10T10:46:36.000Z",
    "textPlain": "Author: I'm literally explaining not to interpret the tag line at face value.",
    "parent": 44854260,
    "depth": 2
  },
  {
    "id": 44852975,
    "by": "corysama",
    "timeISO": "2025-08-10T05:28:38.000Z",
    "textPlain": "I’m only an armchair expert on Erlang. But, having looked into it repeatedly for a couple decades, my take-away is the “Let it crash” slogan is good. But, also presented a bit out of context. Or, at least assuming context that most people don’t have.Erlang is used in situations involving a zillion incoming requests. If an individual request fails… Maybe it was important. Maybe it wasn’t.  If it was important, it’s expected they’ll try again. What’s most important is that the rest of the requests are not interrupted.What makes Erlang different is that it is natural and trivial to be able to shut down an individual request on the event of an error without worrying about putting any other part of the system into a bad state.You can pull this off in other languages via careful attention to the details of your request-handling code. But, the creators of the Erlang language and foundational frameworks have set their users up for success via careful attention to the design of the system as a whole.That’s great in the contexts in which Erlang is used. But, in the context of a Java desktop app like Open Office, it’s more like saying “Let it throw”. “It” being some user action. And, the slogan being to have a language and framework with such robust exception handling built-in that error handling becomes trivial and nearly invisible.",
    "parent": 44852737,
    "depth": 2
  },
  {
    "id": 44855610,
    "by": "jlouis",
    "timeISO": "2025-08-10T14:53:50.000Z",
    "textPlain": "It's not going to be missing the next time around. Usually the file is missing due to some concurrency-problem where the file only gets to exist a little later. A process restart certainly fixes this.If the problem persists, a larger part of the supervision tree is restarted. This eventually leads to a crash of the full application, if nothing can proceed without this application existing in the Erlang release.The key point is that there's a very large class of errors which is due to the concurrent interaction of different parts of the system. These problems often go away on the next try, because the risk of them occurring is low.",
    "parent": 44852737,
    "depth": 2
  },
  {
    "id": 44853734,
    "by": "victorbjorklund",
    "timeISO": "2025-08-10T08:33:42.000Z",
    "textPlain": "Elixir dev: It does not solve all issues. But sometimes you have some kind of rare bug that just happens once X,Z and Y happens in a specific order. If it is restarted it might not happen that way again. Or it might be a temporary problem. You are reaching for an API and it temporarily has issues. It might not have it anymore in 50 ms.But of course if it crashes because you are reading a file that does not exist it doesnt solve the issue (but it avoids crashing the whole system).",
    "parent": 44852737,
    "depth": 2
  },
  {
    "id": 44853599,
    "by": "masklinn",
    "timeISO": "2025-08-10T08:05:10.000Z",
    "textPlain": "> Is an infinite crash-loop considered success in Erlang?Of course not, but usually that's not what happens, instead a process crashes because some condition was not considered, the corresponding request is aborted, and a supervisor restarts the process (or doesn't because the acceptor spawns a process per request / client).Or a long-running worker got into an incorrect state and crashed, and a supervisor will restart it in a known good state (that's a pretty common thing to do in hardware, BEAM makes that idiomatic in software).",
    "parent": 44852737,
    "depth": 2
  },
  {
    "id": 44852805,
    "by": "ramchip",
    "timeISO": "2025-08-10T04:42:54.000Z",
    "textPlain": "I recommend https://ferd.ca/the-zen-of-erlang.html starting from \"if my configuration file is corrupted, restarting won't fix anything\". The tl;dr is it helps with transient bugs.",
    "parent": 44852737,
    "depth": 2
  },
  {
    "id": 44853829,
    "by": "conradfr",
    "timeISO": "2025-08-10T08:57:53.000Z",
    "textPlain": "If the rest of the program is still running while you fix it, yes?Also, restarting endlessly is just one strategy between multiple others.",
    "parent": 44852737,
    "depth": 2
  },
  {
    "id": 44852777,
    "by": "lawn",
    "timeISO": "2025-08-10T04:34:57.000Z",
    "textPlain": "Typically you then let the error bubble up in the supervisor tree if restarting multiple times doesn't fix it.Of course there are still errors that can't be recovered from, in which case the whole program may finally crash.",
    "parent": 44852737,
    "depth": 2
  },
  {
    "id": 44854513,
    "by": "vendiddy",
    "timeISO": "2025-08-10T11:39:08.000Z",
    "textPlain": "I think the slogan was meant to be provocative but unfortunately it has been misinterpreted more often than not.For example, imagine you're working with a 3rd party API and, according to the documentation, it is supposed to return responses in a certain format. What if suddenly that API stops working? Or what if the format changes?You could write code to handle that \"what if\" scenario, but then trying to handle every hypothetical your code becomes bloated, more complicated, and hard to understand.So in these cases, you accept that the system will crash. But to ensure reliability, you don't want to bring down the whole system. So there are primitives that let you control the blast radius of the crash if something unexpected happens.Let it crash does not mean you skip validating user input. Those are issues that you expect to happen. You handle those just as you would in any programming language.",
    "parent": 44854207,
    "depth": 2
  },
  {
    "id": 44854321,
    "by": "johnisgood",
    "timeISO": "2025-08-10T10:53:48.000Z",
    "textPlain": "As someone has linked it: https://erlang.org/pipermail/erlang-questions/2003-March/007...It is about self-healing, too.",
    "parent": 44854207,
    "depth": 2
  },
  {
    "id": 44854505,
    "by": "zmgsabst",
    "timeISO": "2025-08-10T11:38:03.000Z",
    "textPlain": "I think it’s more subtle:Imagine that you’re trying to access an API, which for some reason fails.“Let it crash” isn’t an argument against handling the timeout, but rather that you should only retry a few, bounded times rather than (eg) exponentially back off indefinitely.When you design from that perspective, you just fail your request processing (returning the request to the queue) and make that your manager’s problem. Your managing process can then restart you, reassign the work to healthy workers, etc. If your manager can’t get things working and the queue overflows, it throws it into dead letters and crashes. That might restart the server, it might page oncall, etc.The core idea is that within your business logic is the wrong place to handle system health — and that many problems can be solved by routing around problems (ie, give task to a healthy worker) or restarting a process. A process should crash when it isn’t scoped to handle the problem it’s facing (eg, server OOM, critical dependency offline, bad permissions). Crashing escalates the problem until somebody can resolve it.",
    "parent": 44854207,
    "depth": 2
  },
  {
    "id": 44853459,
    "by": "davidclark",
    "timeISO": "2025-08-10T07:34:02.000Z",
    "textPlain": "You should try to do some load testing of a real Erlang system and compare how it handles this scenario against other languages/frameworks. What you are describing is one of the exact things the Erlang system is strong against due to the scheduler.",
    "parent": 44853160,
    "depth": 2
  },
  {
    "id": 44853248,
    "by": "josevalim",
    "timeISO": "2025-08-10T06:42:57.000Z",
    "textPlain": "Processes can be marked as temporary, which means they are not restarted, and that’s what is used when managing http connections, as you can’t really restart a request on the server without the client.  So the scenario above wouldn’t happen.You still want those processes to crash though, as it allows it to automatically clean up any concurrent work. For example, if during a request you start three processes to do concurrent work, like fetching APIs, then the request process crashes, the concurrent processes are automatically cleaned up.",
    "parent": 44853160,
    "depth": 2
  },
  {
    "id": 44854575,
    "by": "sarchertech",
    "timeISO": "2025-08-10T11:51:38.000Z",
    "textPlain": "> If you \"just crash\" it turns this request from one that only triggers a http 500 response to one that crashes the process.In phoenix each request has its own process and crashing that process will result in a 500 being sent to the client.",
    "parent": 44853160,
    "depth": 2
  },
  {
    "id": 44853325,
    "by": "rtpg",
    "timeISO": "2025-08-10T07:03:20.000Z",
    "textPlain": "My impression is that in Erlang land each process handler is really cheap so you can just keep on showing up with process handlers and not reach exhaustion like you do with other systems (at least in pre-async worlds...)",
    "parent": 44853160,
    "depth": 2
  },
  {
    "id": 44853197,
    "by": "zwnow",
    "timeISO": "2025-08-10T06:28:30.000Z",
    "textPlain": "This is funny given Elixir/Erlangs whole idea is \"let it crash\". In Go I just have a Recovery Middleware for any type of problem. Don't know how other langs do it tho",
    "parent": 44853160,
    "depth": 2
  },
  {
    "id": 44853243,
    "by": "cyberax",
    "timeISO": "2025-08-10T06:41:59.000Z",
    "textPlain": "\"Let it crash\" in Erlang/Elixir means that the process that serves the request is allowed to crash. It then will be restarted by the supervisor.Supervisors themselves form a tree, so for a crash to take down the whole app, it needs to propagate all the way to the top.Another explanation for people familiar with exceptions in other languages: \"Don't try to catch the exception inside a request handler\".",
    "parent": 44853160,
    "depth": 2
  },
  {
    "id": 44852679,
    "by": "goosejuice",
    "timeISO": "2025-08-10T04:07:09.000Z",
    "textPlain": "Somewhat, yes but it's much less powerful. In the BEAM these are trees of supervisors and monitors/links that choose how to restart and receive the stacktrace/error reason of the failure respectively. This gives a lot of freedom on how to handle the failure. In k8s, it's often just a dumb monitor/controller that knows little about how to remediate the issue on boot. Nevermind the boot time penalty.https://hexdocs.pm/elixir/1.18.4/Supervisor.htmlBEAM apps run great on k8s.",
    "parent": 44852663,
    "depth": 2
  }
]
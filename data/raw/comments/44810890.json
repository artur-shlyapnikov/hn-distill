[
  {
    "id": 44853160,
    "by": "praptak",
    "timeISO": "2025-08-10T06:20:11.000Z",
    "textPlain": "A condition that \"should not happen\" might still be a problem specific to a particular request. If you \"just crash\" it turns this request from one that only triggers a http 500 response to one that crashes the process. This increases the risk of Query of Death scenarios where the frontend that needs to serve this particular request starts retrying it with different backends and triggers restarts faster than the processes come back up.So being too eager to \"just crash\" may turn a scenario where you fail to serve 1% of requests into a scenario where you serve none because all your processes keep restarting.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852934,
    "by": "valenterry",
    "timeISO": "2025-08-10T05:17:39.000Z",
    "textPlain": "There are a few stages, and each improves on the previous ones:1. Detect crashes at runtime and by default stop/crash to prevent continuing with invalid program state2. Detect crashes at runtime and handle them according to the business context (e.g. crash or retry or fallback-to or ...) to prevent bad UX through crashes.3. Detect potential crashes at compile-time to prevent the dev from forgetting to handle them according to the business context4. Don't just detect the possibility of crashes but also the specific type and context to prevent the dev from making a logical mistake and causing a potential runtime error during error handling according to the business contextAn example for stage 4 would be that the compiler checks that a fall-back option will actually always resolve the errors and not potentially introduce a new error / error type. Such as falling back to another URL does not actually always resolve the problem, there still needs to be handling for when the request to the alternative URL fails.The philosophy described in the article is basically just stage 1 and a (partial) default restart instead of a default crash, which is maybe a slight improvement but not really sufficient, at least not by my personal standards.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852737,
    "by": "HexDecOctBin",
    "timeISO": "2025-08-10T04:23:07.000Z",
    "textPlain": "How does restarting the process fix the crash? If the process crashed because a file was missing, it will still be missing when the process is restarted. Is an infinite crash-loop considered success in Erlang?",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852658,
    "by": "goosejuice",
    "timeISO": "2025-08-10T03:59:21.000Z",
    "textPlain": "https://erlang.org/pipermail/erlang-questions/2003-March/007...The origin, as far as I know it. I think it still holds, is insightful, as a general case. Let it heal seems pretty close to what Joe was getting at.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852463,
    "by": "bgdkbtv",
    "timeISO": "2025-08-10T03:01:11.000Z",
    "textPlain": "This is great, thanks for sharing! I've been thinking about improving error handling in my liveview app and this might be a nice way to start.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852663,
    "by": "refactor_master",
    "timeISO": "2025-08-10T04:01:11.000Z",
    "textPlain": "Question as a complete outsider: If I run idempotent Python applications in Kubernetes containers and they crash, Kubernetes will eventually restart them. Of course, knowing what to do on IO errors is nicer than destroying and restarting everything with a really bigger hammer (as the article also mentions, you can serve a better error message for whoever has to “deal” with the problem), but eventually they should end up in the same workable state.Is this conceptually similar, but perhaps at code-level instead?",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852961,
    "by": "monkeyelite",
    "timeISO": "2025-08-10T05:26:12.000Z",
    "textPlain": "This seems specific to BEAM as crashing a fast-cgi process is fine and response will be handled correctly with Apache or nginx.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852730,
    "by": "adastra22",
    "timeISO": "2025-08-10T04:21:29.000Z",
    "textPlain": "“Reset on error” might be a better phrasing.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852476,
    "by": "bitwize",
    "timeISO": "2025-08-10T03:04:52.000Z",
    "textPlain": "I don't code in Erlang or Elixir, aside from messing about. But I've found that letting an entire application crash is something that I can do under certain circumstances, especially when \"you have a very big problem and will not go to space today\". For example, if there's an error reading some piece of data that's in the application bundle and is needed to legitimately start up in the first place (assets for my game for instance). Then upon error it just \"screams and dies\" (spits out a stack trace and terminates).",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44852820,
    "by": "BobbyTables2",
    "timeISO": "2025-08-10T04:48:50.000Z",
    "textPlain": "Hackers also love auto-restarting services.Exploitation of vulnerabilities isn’t always 100% reliable.  Heap grooming might be limited or otherwise inadequate.A quick automatic restart keeps them in business without any other human interaction involved.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44853095,
    "by": "snickerbockers",
    "timeISO": "2025-08-10T06:04:35.000Z",
    "textPlain": ">When people say “let it crash”, they are referring to the fact that practically any exited process in your application will be subsequently restarted. Because of this, you can often be much less defensive around unexpected errors. You will see far fewer try/rescue, or matching on error states in Elixir code.I just threw up in my mouth when I read this.  I've never used this language so maybe my experience doesn't apply here but I'm imagining all the different security implications that ive seen arise from failing to check error codes.",
    "parent": 44810890,
    "depth": 1
  },
  {
    "id": 44853197,
    "by": "zwnow",
    "timeISO": "2025-08-10T06:28:30.000Z",
    "textPlain": "This is funny given Elixir/Erlangs whole idea is \"let it crash\". In Go I just have a Recovery Middleware for any type of problem. Don't know how other langs do it tho",
    "parent": 44853160,
    "depth": 2
  },
  {
    "id": 44852975,
    "by": "corysama",
    "timeISO": "2025-08-10T05:28:38.000Z",
    "textPlain": "I’m only an armchair expert on Erlang. But, having looked into it repeatedly for a couple decades, my take-away is the “Let it crash” slogan is good. But, also presented a bit out of context. Or, at least assuming context that most people don’t have.Erlang is used in situations involving a zillion incoming requests. If an individual request fails… Maybe it was important. Maybe it wasn’t.  If it was important, it’s expected they’ll try again. What’s most important is that the rest of the requests are not interrupted.What makes Erlang different is that it is natural and trivial to be able to shut down an individual request on the event of an error without worrying about putting any other part of the system into a bad state.You can pull this off in other languages via careful attention to the details of your request-handling code. But, the creators of the Erlang language and foundational frameworks have set their users up for success via careful attention to the design of the system as a whole.That’s great in the contexts in which Erlang is used. But, in the context of a Java desktop app like Open Office, it’s more like saying “Let it throw”. “It” being some user action. And, the slogan being to have a language and framework with such robust exception handling built-in that error handling becomes trivial and nearly invisible.",
    "parent": 44852737,
    "depth": 2
  },
  {
    "id": 44852805,
    "by": "ramchip",
    "timeISO": "2025-08-10T04:42:54.000Z",
    "textPlain": "I recommend https://ferd.ca/the-zen-of-erlang.html starting from \"if my configuration file is corrupted, restarting won't fix anything\". The tl;dr is it helps with transient bugs.",
    "parent": 44852737,
    "depth": 2
  },
  {
    "id": 44852777,
    "by": "lawn",
    "timeISO": "2025-08-10T04:34:57.000Z",
    "textPlain": "Typically you then let the error bubble up in the supervisor tree if restarting multiple times doesn't fix it.Of course there are still errors that can't be recovered from, in which case the whole program may finally crash.",
    "parent": 44852737,
    "depth": 2
  },
  {
    "id": 44852679,
    "by": "goosejuice",
    "timeISO": "2025-08-10T04:07:09.000Z",
    "textPlain": "Somewhat, yes but it's much less powerful. In the BEAM these are trees of supervisors and monitors/links that choose how to restart and receive the stacktrace/error reason of the failure respectively. This gives a lot of freedom on how to handle the failure. In k8s, it's often just a dumb monitor/controller that knows little about how to remediate the issue on boot. Nevermind the boot time penalty.https://hexdocs.pm/elixir/1.18.4/Supervisor.htmlBEAM apps run great on k8s.",
    "parent": 44852663,
    "depth": 2
  },
  {
    "id": 44852743,
    "by": "adastra22",
    "timeISO": "2025-08-10T04:24:32.000Z",
    "textPlain": "Conceptually similar, different implementation. The perhaps most visible difference is that supervisors aren’t polling application state but are rather notified about errors (crashes), and restarting is extremely low latency.  Erlang/BEAM was invented for telephony, and it is possible for this to happen on the middle of a protocol and the user not even notice.",
    "parent": 44852663,
    "depth": 2
  },
  {
    "id": 44852512,
    "by": "borromakot",
    "timeISO": "2025-08-10T03:14:13.000Z",
    "textPlain": "Errors during initialization of a BEAM language application will crash the entire program, and you can decide to exit/crash a program if you get into some unrecoverable state. The important thing is the design of individual crashable/recoverable units.",
    "parent": 44852476,
    "depth": 2
  },
  {
    "id": 44853117,
    "by": "teiferer",
    "timeISO": "2025-08-10T06:10:10.000Z",
    "textPlain": "Took me a minute to realize what you meant with \"hackers\". Quite the irony, given the name of the site we are having this conversation on.",
    "parent": 44852820,
    "depth": 2
  },
  {
    "id": 44853199,
    "by": "josevalim",
    "timeISO": "2025-08-10T06:29:11.000Z",
    "textPlain": "That’s actually a good example. Imagine someone forgot to check the error code from an API response. In some languages, they may attempt to parse it as if it was successful request, and succeed, leading to a result with nulls, empty arrays, or missing data that then spreads through the system. In Elixir, parsing would most likely fail thanks to pattern matching [1] and if it by any chance that fails in a core part of the system, that failure will be isolated and that particular component can be restarted.Elixir is not about willingly ignoring error codes or failure scenarios. It is about naturally limiting the blast radius of errors without a need to program defensively (as in writing code for scenarios you don’t know “just in case”).1: https://dashbit.co/blog/writing-assertive-code-with-elixir",
    "parent": 44853095,
    "depth": 2
  }
]
[
  {
    "id": 44873773,
    "by": "kazinator",
    "timeISO": "2025-08-12T08:26:24.000Z",
    "textPlain": "[delayed]",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44873493,
    "by": "uecker",
    "timeISO": "2025-08-12T07:45:01.000Z",
    "textPlain": "One has to add that from the 218 UB in the ISO C23,  87 are in the core language. From those we already removed 26 and are in progress of removing many others. You can find my latest update here (since then there was also some progress):  https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3529.pdf",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44841999,
    "by": "VivaTechnics",
    "timeISO": "2025-08-08T21:43:59.000Z",
    "textPlain": "We switched to Rust.\nGenerally, are there specific domains or applications where C/C++ remain preferable? Many exist—but are there tasks Rust fundamentally cannot handle or is a weak choice?",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44873417,
    "by": "fattah25",
    "timeISO": "2025-08-12T07:32:22.000Z",
    "textPlain": "Rust here rust there. We are just talking about C not rust. Why we have to using rust. If you talking memory safety why there is no one recommends Ada language instead of rust.We have zig, Hare, Odin, V too.",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44873789,
    "by": "bluetomcat",
    "timeISO": "2025-08-12T08:28:32.000Z",
    "textPlain": "Rust encourages a rather different \"high-level\" programming style that doesn't suit the domains where C excels. Pattern matching, traits, annotations, generics and functional idioms make the language verbose and semantically-complex. C is a different kind of animal that encourages terseness and economy of expression. When you know what you are doing with C pointers, the compiler just doesn't get in the way.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44873523,
    "by": "uecker",
    "timeISO": "2025-08-12T07:48:55.000Z",
    "textPlain": "Advantages of C are short compilation time, portability, long-term stability, widely available expertise and training materials, less complexity.IMHO you can today deal with UB just fine in C if you want to by following best practices, and the reasons given when those are not followed would also rule out use of most other safer languages.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44873736,
    "by": "pizza234",
    "timeISO": "2025-08-12T08:20:27.000Z",
    "textPlain": "Yes, based on a few attempts chronicled in articles from different sources, Rust is a weak choice for game development, because it's too time-consuming to refactor.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44873704,
    "by": "mrheosuper",
    "timeISO": "2025-08-12T08:16:15.000Z",
    "textPlain": "Rust can do inline ASM, so finding a task Rust \"fundamentally cannot handle\" is almost impossible.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44842977,
    "by": "imadr",
    "timeISO": "2025-08-09T00:13:51.000Z",
    "textPlain": "I haven't used Rust extensively so I can't make any criticism besides that I find compilation times to be slower than C",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44873466,
    "by": "ViewTrick1002",
    "timeISO": "2025-08-12T07:40:55.000Z",
    "textPlain": "> Ada language instead of rustBecause it never achieved mainstream success?And Zig for example is very much not memory safe. Which a cursory search for ”segfault” in the Bun repo quickly tells you.https://github.com/oven-sh/bun/issues?q=is%3Aissue%20state%3...",
    "parent": 44873417,
    "depth": 2
  }
]
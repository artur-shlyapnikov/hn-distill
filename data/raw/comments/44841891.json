[
  {
    "id": 44873493,
    "by": "uecker",
    "timeISO": "2025-08-12T07:45:01.000Z",
    "textPlain": "One has to add that from the 218 UB in the ISO C23,  87 are in the core language. From those we already removed 26 and are in progress of removing many others. You can find my latest update here (since then there was also some progress):  https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3529.pdf",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44874034,
    "by": "safercplusplus",
    "timeISO": "2025-08-12T09:08:01.000Z",
    "textPlain": "A couple of solutions in development (but already usable) that more effectively address UB:i) \"Fil-C is a fanatically compatible memory-safe implementation of C and C++. Lots of software compiles and runs with Fil-C with zero or minimal changes. All memory safety errors are caught as Fil-C panics.\"\n\"Fil-C only works on Linux/X86_64.\"ii) \"scpptool is a command line tool to help enforce a memory and data race safe subset of C++. It's designed to work with the SaferCPlusPlus library. It analyzes the specified C++ file(s) and reports places in the code that it cannot verify to be safe. By design, the tool and the library should be able to fully ensure \"lifetime\", bounds and data race safety.\"\n\"This tool also has some ability to convert C source files to the memory safe subset of C++ it enforces\"",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44873848,
    "by": "kazinator",
    "timeISO": "2025-08-12T08:37:57.000Z",
    "textPlain": "Undefined behavior only means that ISO C doesn't give requirements, not that nobody gives requirements. Many useful extensions are instances where undefined behavior is documented by an implementation.Including a header that is not in the program, and not in ISO C, is undefined behavior. So is calling a function that is not in ISO C and not in the program. (If the function is not anywhere, the program won't link. But if it is somewhere, then ISO C has nothing to say about its behavior.)Correct, portable POSIX C programs have undefined behavior in ISO C; only if we interpret them via IEEE 1003 are they defined by that document.If you invent a new platform with a C compiler, you can have it such that #include <windows.h> reformats all the attached storage devices. ISO C allows this because it doesn't specify what happens if #include <windows.h> successfully resolves to a file and includes its contents. Those contents could be anything, including some compile-time instruction to do harm.Even if a compiler's documentationd doesn't grant that a certain instance of undefined behavior is a documented extension, the existence of a de facto extension can be inferred empirically through numerous experiments: compiling test code and reverse engineering the object code.Moreover, the source code for a compiler may be available; the behavior of something can be inferred from studying the code. The code could change in the next version. But so could the documentation; documentation can take away a documented extension the same way as a compiler code change can take away a de facto extension.Speaking of object code: if you follow a programming paradigm of verifying the object code, then undefined behavior becomes moot, to an extent. You don't trust the compiler anyway. If the machine code has the behavior which implements the requirements that your project expects of the source code, then the necessary thing has been somehow obtained.",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44873816,
    "by": "laauraa",
    "timeISO": "2025-08-12T08:32:54.000Z",
    "textPlain": ">Uninitialized dataThey at least fixed this in c++26.\nNo longer UB, but \"erroneous behavior\".\nStill some random garbage value (so an uninitialized pointer will likely lead to disastrous results still), but the compiler isn't allowed to fuck up your code, it has to generate code as if it had some value.",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44841999,
    "by": "VivaTechnics",
    "timeISO": "2025-08-08T21:43:59.000Z",
    "textPlain": "We switched to Rust.\nGenerally, are there specific domains or applications where C/C++ remain preferable? Many exist—but are there tasks Rust fundamentally cannot handle or is a weak choice?",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44873773,
    "by": "kazinator",
    "timeISO": "2025-08-12T08:26:24.000Z",
    "textPlain": "In C, using uninitialized data is undefined behavior only if:- it is an automatic variable whose address has not been taken; or- the uninitialized object' bits are such that it takes on a non-value representation.",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44873417,
    "by": "fattah25",
    "timeISO": "2025-08-12T07:32:22.000Z",
    "textPlain": "Rust here rust there. We are just talking about C not rust. Why we have to using rust. If you talking memory safety why there is no one recommends Ada language instead of rust.We have zig, Hare, Odin, V too.",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44874971,
    "by": "IshKebab",
    "timeISO": "2025-08-12T11:38:17.000Z",
    "textPlain": "This asserts that UB was deliberately created for optimisation purposes; not to handle implementation differences. It doesn't provide any evidence though and that seems unlikely to me.The spec even says:> behavior, upon use of a nonportable or erroneous program construct or of erroneous data, for which this International Standard imposes no requirementsNo motivation is given that I could find, so the actual difference between undefined and implementation defined behaviour seems to be based on whether the behaviour needs to be documented.",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44874612,
    "by": "roman_soldier",
    "timeISO": "2025-08-12T10:46:23.000Z",
    "textPlain": "Just use Zig, it fixes all this",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44874015,
    "by": "pizlonator",
    "timeISO": "2025-08-12T09:05:57.000Z",
    "textPlain": "I don’t buy the “it’s because of optimization argument”.And I especially don’t buy that UB is there for register allocation.First of all, that argument only explains UB of OOB memory accesses at best.Second, you could define the meaning of OOB by just saying “pointers are integers” and then further state that nonescaping locals don’t get addresses. Many ways you could specify that, if you cared badly enough. My favorite way to do it involves saying that pointers to locals are lazy thunks that create addresses on demand.",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44874835,
    "by": "grougnax",
    "timeISO": "2025-08-12T11:18:35.000Z",
    "textPlain": "Worse languages ever.",
    "parent": 44841891,
    "depth": 1
  },
  {
    "id": 44874182,
    "by": "tialaramex",
    "timeISO": "2025-08-12T09:31:02.000Z",
    "textPlain": "A lot of that work is basically fixing documentation bugs, labelled \"ghosts\" in your text. Places where the ISO document is so bad as a description of C that you would think there's Undefined Behaviour but it's actually just poorly written.Fixing the document is worthwhile, and certainly a reminder that WG21's equivalent effort needs to make the list before it can even begin that process on its even longer document, but practical C programmers don't read the document and since this UB was a \"ghost\" they weren't tripped by it. Removing items from the list this way does not translate to the meaningful safety improvement you might imagine.There's not a whole lot of movement there towards actually fixing the problem. Maybe it will come later?",
    "parent": 44873493,
    "depth": 2
  },
  {
    "id": 44873975,
    "by": "ncruces",
    "timeISO": "2025-08-12T08:57:40.000Z",
    "textPlain": "And yet, I see P1434R0 seemingly trying to introduce new undefined behavior, around integer-to-pointer conversions, where previously you had reasonably sensible implementation defined behavior (the conversions “are intended to be consistent with the addressing structure of the execution environment\").https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p14...",
    "parent": 44873493,
    "depth": 2
  },
  {
    "id": 44874253,
    "by": "tialaramex",
    "timeISO": "2025-08-12T09:41:49.000Z",
    "textPlain": "Fil-C is interesting because as you'd expect it takes a significant performance penalty to deliver this property, if it's broadly adopted that would suggest that - at least in this regard - C programmers genuinely do prioritise their simpler language over mundane ideas like platform support or performance.The resulting language doesn't make sense for commercial purposes but there's no reason it couldn't be popular with hobbyists.",
    "parent": 44874034,
    "depth": 2
  },
  {
    "id": 44874224,
    "by": "throw-qqqqq",
    "timeISO": "2025-08-12T09:38:21.000Z",
    "textPlain": "> Undefined behavior only means that ISO C doesn't give requirements, not that nobody gives requirements. Many useful extensions are instances where undefined behavior is documented by an implementation.True, most compilers have sane defaults in many cases for things that are technically undefined (like take sizeof(void) or do pointer arithmetic on something other than a char). But not all of these cases can be saved by sane defaults.Undefined behavior means the compiler can replace the code with whatever. So if you e.g. compile optimizing for size, the compiler will rip out the offending code, as replacing it with nothing yields the greatest size optimization.See also John Regehr's collection of UB-Canaries: https://github.com/regehr/ub-canariesSnippets of software exhibiting undefined behavior, executing e.g. both the true and the false branch of an if-statement or none etc. UB should not be taken lightly IMO...",
    "parent": 44873848,
    "depth": 2
  },
  {
    "id": 44874122,
    "by": "pjmlp",
    "timeISO": "2025-08-12T09:22:40.000Z",
    "textPlain": "Unfortunely it also means that when the programmer fails to understand what undefined behaviour is exposed on their code, the compiler is free to take advantage of that to do the ultimate performance optimizations as means to beat compiler benchmarks.The code change might come in something as innocent as a bug fix to the compiler.",
    "parent": 44873848,
    "depth": 2
  },
  {
    "id": 44874794,
    "by": "quietbritishjim",
    "timeISO": "2025-08-12T11:13:15.000Z",
    "textPlain": "> Including a header that is not in the program, and not in ISO C, is undefined behavior.What is this supposed to mean? I can't think of any interpretation that makes sense.I think ISO C defines the executable program to be something like the compiled translation units linked together. But header files do not have to have any particular correspondence to translation units. For example, a header might declare functions whose definitions are spread across multiple translation units, or define things that don't need any definitions in particular translation units (e.g. enum or struct definitions). It could even play macro tricks which means it declares or defines different things each time you include it.Maybe you mean it's undefined behaviour to include a header file that declares functions that are not defined in any translation unit. I'm not sure even that is true, so long as you don't use those functions. It's definitely not true in C++, where it's only a problem (not sure if it's undefined exactly) if you ODR-rule use a function that has been declared but not defined anywhere. (Examples of ODR-rule use are calling or taking the address of the function, but not, for example, using sizeof on an expression that includes it.)",
    "parent": 44873848,
    "depth": 2
  },
  {
    "id": 44874290,
    "by": "tialaramex",
    "timeISO": "2025-08-12T09:50:54.000Z",
    "textPlain": "It won't be a \"random garbage value\" but is instead a value the compiler chose.In effect if you don't opt out your value will always be initialized but not to a useful value you chose. You can think of this as similar to the (current, defanged and deprecated as well as unsafe) Rust std::mem::uninitialized()There were earlier attempts to make this value zero, or rather, as many 0x00 bytes as needed, because on most platforms that's markedly cheaper to do, but unfortunately some C++ would actually have worse bugs if the \"forgot to initialize\" case was reliably zero instead.",
    "parent": 44873816,
    "depth": 2
  },
  {
    "id": 44873859,
    "by": "kazinator",
    "timeISO": "2025-08-12T08:40:06.000Z",
    "textPlain": "C also fixed it in its way.Access to an uninitialized object defined in automatic storage, whose address is not taken, is UB.Access to any uninitialized object whose bit pattern is a non-value, likewise.Otherwise, it's good: the value implied by the bit pattern is obtained and computation goes on its merry way.",
    "parent": 44873816,
    "depth": 2
  },
  {
    "id": 44874147,
    "by": "pjmlp",
    "timeISO": "2025-08-12T09:25:46.000Z",
    "textPlain": "Yes, all the industries where C and C++ are the industry standards like Khronos APIs, POSIX, CUDA, DirectX, Metal, console devkits, LLVM and GCC implementation,....Not only you are faced with creating your own wrappers, if no one else has done it already.The tooling, for IDEs and graphical debuggers, assumes either C or C++, so it won't be there for Rust.Ideally the day will come where those ecosystems might also embrace Rust, but that is still decades away maybe.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44873789,
    "by": "bluetomcat",
    "timeISO": "2025-08-12T08:28:32.000Z",
    "textPlain": "Rust encourages a rather different \"high-level\" programming style that doesn't suit the domains where C excels. Pattern matching, traits, annotations, generics and functional idioms make the language verbose and semantically-complex. When you follow their best practices, the code ends up more complex than it really needs to be.C is a different kind of animal that encourages terseness and economy of expression. When you know what you are doing with C pointers, the compiler just doesn't get in the way.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44873523,
    "by": "uecker",
    "timeISO": "2025-08-12T07:48:55.000Z",
    "textPlain": "Advantages of C are short compilation time, portability, long-term stability, widely available expertise and training materials, less complexity.IMHO you can today deal with UB just fine in C if you want to by following best practices, and the reasons given when those are not followed would also rule out use of most other safer languages.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44873736,
    "by": "pizza234",
    "timeISO": "2025-08-12T08:20:27.000Z",
    "textPlain": "Yes, based on a few attempts chronicled in articles from different sources, Rust is a weak choice for game development, because it's too time-consuming to refactor.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44874020,
    "by": "mgaunard",
    "timeISO": "2025-08-12T09:06:29.000Z",
    "textPlain": "Rust forces you to code in the Rust way, while C or C++ let you do whatever you want.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44874640,
    "by": "eru",
    "timeISO": "2025-08-12T10:51:29.000Z",
    "textPlain": "> Generally, are there specific domains or applications where C/C++ remain preferable?Well, anything were your people have more experience in the other language or the libraries are a lot better.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44874529,
    "by": "m-schuetz",
    "timeISO": "2025-08-12T10:31:22.000Z",
    "textPlain": "Prototyping in any domain. It's nice to do some quick&dirty way to rapidly evaluate ideas and solutions.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44842977,
    "by": "imadr",
    "timeISO": "2025-08-09T00:13:51.000Z",
    "textPlain": "I haven't used Rust extensively so I can't make any criticism besides that I find compilation times to be slower than C",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44873704,
    "by": "mrheosuper",
    "timeISO": "2025-08-12T08:16:15.000Z",
    "textPlain": "Rust can do inline ASM, so finding a task Rust \"fundamentally cannot handle\" is almost impossible.",
    "parent": 44841999,
    "depth": 2
  },
  {
    "id": 44873466,
    "by": "ViewTrick1002",
    "timeISO": "2025-08-12T07:40:55.000Z",
    "textPlain": "> Ada language instead of rustBecause it never achieved mainstream success?And Zig for example is very much not memory safe. Which a cursory search for ”segfault” in the Bun repo quickly tells you.https://github.com/oven-sh/bun/issues?q=is%3Aissue%20state%3...",
    "parent": 44873417,
    "depth": 2
  },
  {
    "id": 44874163,
    "by": "pjmlp",
    "timeISO": "2025-08-12T09:27:38.000Z",
    "textPlain": "None of them solve use after free, for example.Ada would rather be a nice choice, but most hackers love their curly brackets.",
    "parent": 44873417,
    "depth": 2
  },
  {
    "id": 44875034,
    "by": "flohofwoe",
    "timeISO": "2025-08-12T11:46:39.000Z",
    "textPlain": "I'd say the original intent of UB was not the sort of \"optimizer exploits\" we see today, but to allow wiggle room for supporting vastly different CPUs without having to compromise runtime performance or increasing compiler complexity to balance performance versus correctness. Basically an escape hatch for compilers. The difference to IB also has always been quite fuzzy.Also the C spec has always been a pragmatic afterthought, created and maintained to establish at least a minimal common feature set expected of C compilers.The really interesting stuff still only exists outside the spec in vendor language extensions.",
    "parent": 44874971,
    "depth": 2
  },
  {
    "id": 44874544,
    "by": "j16sdiz",
    "timeISO": "2025-08-12T10:34:31.000Z",
    "textPlain": "> First of all, that argument only explains UB of OOB memory accesses at best.It explains many loop-unroll and integer overflow as well.",
    "parent": 44874015,
    "depth": 2
  },
  {
    "id": 44874827,
    "by": "gpderetta",
    "timeISO": "2025-08-12T11:17:15.000Z",
    "textPlain": "> nonescaping locals don’t get addressesinlining, interprocedural optimizations.For example, something as an trivial accessor member function would be hard to optimize.",
    "parent": 44874015,
    "depth": 2
  },
  {
    "id": 44874679,
    "by": "tialaramex",
    "timeISO": "2025-08-12T10:57:40.000Z",
    "textPlain": "> Second, you could define the meaning of OOB by just saying “pointers are integers\"This means losing a lot of optimisations, so in fact when you say you \"don't buy\" this argument you only mean that you don't care about optimisation. Which is fine, but this does mean the \"improved\" C isn't very useful in a lot of applications, might as well choose Java.",
    "parent": 44874015,
    "depth": 2
  },
  {
    "id": 44875119,
    "by": "compiler-guy",
    "timeISO": "2025-08-12T11:57:49.000Z",
    "textPlain": "Jack Sparrow: “… but you have heard of them.”The dustbin of programming languages is jam packed with elegant, technically terrific, languages that never went anywhere.",
    "parent": 44874835,
    "depth": 2
  },
  {
    "id": 44874909,
    "by": "OskarS",
    "timeISO": "2025-08-12T11:29:01.000Z",
    "textPlain": "C and C++ are languages that brought us UNIX, the Linux kernel, macOS and Windows, the interpreters of virtually every other language in the world, powering virtually all software in the world as well as the vast majority of embedded devices.Chill the fuck out.",
    "parent": 44874835,
    "depth": 2
  }
]
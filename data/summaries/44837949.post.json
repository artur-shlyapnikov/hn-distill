{
  "id": 44837949,
  "lang": "ru",
  "summary": "Хвостовая рекурсия превращает рекурсию в цикл: компилятор заменяет вызов на безусловный `jmp`, поэтому стек не растёт.  \n\nОбычная рекурсия кладёт промежуточные значения в стек, тратит O(n) памяти и вытесняет кэш.  \nЦикл же держит результат в аккумуляторе, использует O(1) памяти и линейное время.\n\n**Ключевое правило хвостовой рекурсии:**  \nвызов должен быть последним выражением функции. Тогда компилятор может выбросить текущий фрейм и передать управление напрямую.\n\n**Пример суммы списка**\n\nОбычная версия:\n```racket\n(define (sum l)\n  (if (empty? l) 0\n      (+ (first l) (sum (rest l)))))\n```\n\nХвостовая версия:\n```racket\n(define (sum l acc)\n  (if (empty? l) acc\n      (sum (rest l) (+ acc (first l)))))\n```\nАргументы `l` и `acc` перезаписываются «на месте», как переменные цикла.\n\n**Упражнение 1** — счётчик чётных/нечётных:\n```racket\n(define (even-odd l [e 0] [o 0])\n  (if (empty? l) (cons e o)\n      (let ([x (first l)])\n        (if (even? x)\n            (even-odd (rest l) (add1 e) o)\n            (even-odd (rest l) e (add1 o))))))\n```\n\n**Упражнение 2** — сглаживание дерева:  \nиспользуйте аккумулятор-список и обход в обратном порядке, чтобы сохранить хвостовой вызов.",
  "inputHash": "e0da77d7333b346469892db7db622bd025efad6048b980382264aa11bc869ec4",
  "model": "moonshotai/kimi-k2:free",
  "createdISO": "2025-08-11T21:21:04.824Z"
}
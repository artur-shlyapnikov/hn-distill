{
  "id": 44815702,
  "lang": "ru",
  "summary": "Моя предыдущая статья о обобщённых структурах данных в C готовила почву к теме: структура, которая заменяет динамические массивы, даёт стабильные указатели и хорошо работает с аренными аллокаторами. Её переоткрывали много раз под разными именами: “levelwise-allocated pile” (2001), в Zig — Segmented List, частично похожая на C++ std::deque. Мне нравится название Per Vognsen — Segment Array.\n\nСкачать мой однофайловый заголовок segment_array.h можно, подписавшись на рассылку.\n\nИдея проста: фиксированный массив указателей на сегменты; каждый следующий сегмент вдвое больше предыдущего; новые сегменты выделяются по мере необходимости. Поскольку элементы не двигаются, указатели на них стабильны, не остаются “дыры” в арене, а доступ по индексу — за O(1).\n\nРеализация\n\nСтруктура на C:\n\ntypedef struct {\n    u32 count;\n    int used_segments;\n    u8 *segments[26];\n} SegmentArrayInternal;\n\nПочему всего 26 сегментов? Из 64 бит указателя обычно реально используются 48, так что 49 сегментов уже перекрывают адресное пространство (~256 ТиБ). Я предпочитаю индекс u32 (до ~4 млрд элементов) — это даёт 32 сегмента. Ещё убираем 6 маленьких (1..32), начинаем с 64, остаётся 26 сегментов — хватает для 4 294 967 232 элементов (чуть меньше UINT32_MAX). Фиксированный массив рядом со структурой снижает риск промаха кэша.\n\nРазмеры сегментов — степени двойки: проще математика и быстрые сдвиги для индексов.\n\n#define SMALL_SEGMENTS_TO_SKIP 6\n\n#define log2i(X) ((u32) (8*sizeof(unsigned long long) \\\n    - __builtin_clzll((X)) - 1))\n\nu32 capacity_for_segment_count(int segment_count) {\n    return ((1 << SMALL_SEGMENTS_TO_SKIP) << segment_count)\n        - (1 << SMALL_SEGMENTS_TO_SKIP);\n}\n\nvoid *_sa_get(SegmentArrayInternal *sa, u32 index, size_t item_size) {\n    int segment = log2i((index >> SMALL_SEGMENTS_TO_SKIP) + 1);\n    u32 slot = index - capacity_for_segment_count(segment);\n    return sa->segments[segment] + item_size*slot;\n}\n\nlog2i использует __builtin_clzll (подсчёт ведущих нулей) для быстрого вычисления номера сегмента.\n\nClang оптимизирует _sa_get до ~10 инструкций x86-64 (-O3), так что узким местом будет память, а не вычисления индекса. При последовательной итерации можно обходить сегменты напрямую; в segment_array.h есть макрос.\n\nВыделение нового элемента:\n\nu32 slots_in_segment(int segment_index) {\n    return (1 << SMALL_SEGMENTS_TO_SKIP) << segment_index;\n}\n\nvoid *_sa_alloc(SegmentArrayInternal *sa, size_t item_size) {\n    if (sa->count >= capacity_for_segment_count(sa->used_segments)) {\n        size_t segment_size = item_size * slots_in_segment(sa->used_segments);\n        sa->segments[sa->used_segments++] = malloc(segment_size);\n    }\n    sa->count++;\n    return _sa_get(sa, sa->count-1, item_size);\n}\n\nЗамечание: можно сделать ёмкость строго степенью двойки, если первые два сегмента одинакового размера. Код станет менее изящным, но это спасает от ~50% потерь памяти при использовании как массива бакетов в хеш-таблице со степенью двойки.\n\nДженерики\n\nЯ применяю технику из прошлой статьи для типобезопасного хранения любого типа. Макрос связывает тип с общей структурой:\n\n#define SegmentArray(type) \\\n    union { \\\n        SegmentArrayInternal internal; \\\n        type *payload; \\\n    }\n\nДальше макросы используют payload, чтобы передавать сведения о типе…",
  "inputHash": "ef336de56544b04634f8bf67dc6db128e08eae2d8e6aaf42d0a3a394079a75cb",
  "model": "openrouter/horizon-beta",
  "createdISO": "2025-08-07T09:12:14.112Z"
}
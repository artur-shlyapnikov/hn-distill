{
  "id": 44840398,
  "lang": "ru",
  "summary": "**HTTP не простой протокол**  \nЧасто слышу, что HTTP «прост», но после 30 лет работы с клиентским кодом и участия в IETF с 2008-го, уверен: это не так. Даже HTTP/1.\n\nПочему кажется простым:\n- читаемый текст;\n- базовый запрос `GET /` легко набрать в telnet;\n- браузеры и curl скрывают сложность.\n\nНа деле:\n\n- **Строки и переводы строк**  \n  Заголовки не ограничены длиной, но реализации должны ставить лимит. Конец строки — CRLF, но иногда достаточно LF. Заголовки — не UTF-8, а произвольные байты.\n\n- **Пробелы и кавычки**  \n  Между полями могут быть пробелы, но не всегда. Значения могут быть без пробелов или в кавычках.\n\n- **Конец тела**  \n  Три способа: `Content-Length`, chunked, закрытие соединения. Парсинг размеров из текста — источник уязвимостей.\n\n- **Числа**  \n  Медленный и ненадёжный парсинг, переполнения, пробелы, знаки, ведущие нули.\n\n- **Сложности заголовков**  \n  - Можно «складывать» несколько заголовков в один через запятую (но не cookie).  \n  - Продолжение заголовка ведущими пробелами почти не используется, но поддерживать надо.\n\n- **Неиспользуемые фичы**  \n  HTTP/1.1 добавил pipelining и код 100, но они не работают в реальном мире и усложняют код.\n\n- **Куча RFC**  \n  «HTTP/1.1» описан минимум в 40 RFC, плюс куки, аутентификация, NTLM и т.д.\n\n- **Методы разные**  \n  Синтаксис должен быть единым, но, например, тело у GET почти не поддерживается.\n\nИтого: идея HTTP проста, реализация — нет.",
  "inputHash": "1ad0b3eb9fcf77ad367fe809a79e24f180e493ee16d2fa43ba29748b18affacf",
  "model": "moonshotai/kimi-k2:free",
  "createdISO": "2025-08-08T19:27:33.876Z"
}
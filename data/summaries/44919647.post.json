{
  "id": 44919647,
  "lang": "ru",
  "summary": "## Двухуровневая модель  \n**Основной агент** ведёт диалог, помнит контекст, раздаёт задачи.  \n**Под-агенты** — чистые функции: получили вход, вернули результат, забыли всё.  \nБольше двух уровней — лишние точки отказа.\n\n## Под-агенты без состояния  \nКаждый вызов — как вызов функции:  \n- одинаковый вход → одинаковый выход  \n- легко кешировать, тестировать, запускать параллельно  \nПример сообщения:  \n```json\n{\"task\": \"sentiment\", \"data\": [...], \"constraints\": {\"timeout\": 5}}\n```\n\n## Разбиение задач  \n- **Вертикальное**: последовательные шаги (сбор → извлечение → сравнение).  \n- **Горизонтальное**: параллельные ветки (исследовать 5 конкурентов одновременно).  \nСмешиваем: сначала параллельная категоризация фидбека, потом последовательная приоритизация.\n\n## Протокол общения  \nКаждая команда содержит:  \n- цель, входные данные, ограничения, формат вывода.  \nОтвет: `status`, `result`, `confidence`, `processing_time`.  \nБолтовни и «помни, что мы обсуждали» — нет.\n\n## Специализация агентов  \n- **Research** — поиск по базе фидбека.  \n- **Analysis** — извлечение тем и настроений.  \n- **Summary** — генерация отчётов и changelog.  \nОдин агент = одна чёткая функция.\n\n## Оркестрация  \n- **Round-robin** — когда порядок важен.  \n- **Priority queue** — сначала критичные фидбеки.  \n- **Fan-out/fan-in** — параллельные под-агенты, потом сбор результатов.  \nСостояние хранит только основной агент; под-агенты не знают о существовании друг друга.\n\n## Управление контекстом  \n- Сжатие: оставляем только релевантные куски.  \n- Слайды: отправляем под-агенту только нужную подборку.  \n- Версионирование: каждый результат имеет `id`, чтобы легко откатиться.\n\n## Обработка ошибок  \n- Повторы с экспоненциальной задержкой (до 3 раз).  \n- Fallback-агенты: если «анализатор» упал, включаем «резервный».  \n- Circuit breaker: после N ошибок отключаем агента и пишем алерт.\n\n## Производительность  \n- Кешируем по хешу запроса.  \n- Параллельные вызовы без блокировок.  \n- Пакетная обработка: отправляем 50 фидбеков за раз, а не по одному.\n\n## Мониторинг  \nОтслеживаем:  \n- latency под-агентов,  \n- точность (сравниваем с разметкой),  \n- частота ошибок,  \n- объём контекста (токенов).  \nВсё пишем в Prometheus + Grafana.\n\n## Уроки из продакшена  \n- Начинайте с 2–3 под-агентов, добавляйте постепенно.  \n- Пишите юнит-тесты для каждого под-агента.  \n- Не давайте агентам доступ к внешним API без rate-limit.  \n- Держите промпты в git; версионируйте как код.\n\n## Принципы  \n1. Простота > масштаб.  \n2. Чистые функции > разделяемое состояние.  \n3. Структурированные сообщения > свободный текст.  \n4. Мониторинг с первого дня > дебаг в проде.\n\n## Частые ошибки  \n- «Умные» под-агенты с памятью → гонки и непредсказуемость.  \n- Слишком большой контекст → таймауты и лишние токены.  \n- Отсутствие таймаутов → зависшие цепочки.  \n- Игнорирование кеширования → лишние $$$ на API.\n\n## Как начать  \n1. Определите 1–2 ключевые задачи (например, «суммаризировать фидбек»).  \n2. Создайте под-агентов: `research`, `summarize`.  \n3. Напишите структурированные схемы входа/выхода.  \n4. Покройте тестами, добавьте метрики.  \n5. Подключите к реальному потоку данных и наблюдайте.",
  "inputHash": "324231f37447e7423a24004f34977980332f3b6fbdfaaf9f1783d9aefc7f51c4",
  "model": "moonshotai/kimi-k2:free",
  "createdISO": "2025-08-16T04:30:42.596Z"
}
{
  "id": 44849834,
  "lang": "ru",
  "summary": "**1. «Float неточен»**  \n- 2.0 + 2.0 всегда 4.0; погрешности не появляются «из ниоткуда».  \n- Проблемы возникают:  \n  – десятичные дроби (0.1) не кладутся точно в двоичный формат;  \n  – 32-битный float точен только до 16 777 216; сверху шаг сначала 2, потом 4 и т.д.  \n- Поэтому счётчик цикла лучше держать float’ом, если значения помещаются в диапазон точности.  \n- 64-битный double точен до 9 007 199 254 740 992 — для большинства задач достаточно.\n\n**2. «Float недетерминирован»**  \n- Один и тот же код с теми же входными данными всегда выдаёт один результат.  \n- Различия возможны:  \n  – оптимизатор может заменить `a*b+c` на FMA-инструкцию с другой точностью;  \n  – функции вроде sin/cos на разных CPU/GPU дают ±1 LSB.  \n- Реальный кейс: хэши от float-результатов в распределённой системе не совпадали на разных машинах.  \n- В шейдере `fract(sin(uv.x*2300*12000))` на AMD при `uv.x > 306` возвращал 0 из-за огромного аргумента (~27 600 000), где sin уже «зашумлён».",
  "inputHash": "27b7d4da7ee7112ff009f9f29bdeaddbc3394a85b786b95d3b2c2486b829d335",
  "model": "moonshotai/kimi-k2:free",
  "createdISO": "2025-08-13T13:40:23.391Z"
}
{
  "id": 44812985,
  "lang": "ru",
  "summary": "Введение\n\nЯ часто использую отладчик, но привык и к выводной отладке, особенно в юнит-тестах. Хотелось улучшить её и чаще подключать отладчик.\n\nУлучшение выводной отладки\n\nГлавная проблема — «шум»: в цикле интересна одна итерация, а печатается всё. Или удобнее читать форматированную структуру, но приходится раскидывать print’ы по коду. В Zig тесты используют error’ы, значит можно печатать только при падении теста через errdefer:\n\ntest {\n    errdefer std.debug.print(\"{f}\", .{ast});\n    // ...\n}\n\nТак контекст появляется только при ошибке, без засорения лога.\n\nЗапуск тестов в отладчике\n\nПросто запустить seergdb или gdb -tui неудобно: тестовые бинарники лежат в zig-cache. Трюк из ziggит: build.zig может запускать команды и передавать путь артефакта:\n\n// seergdb — GUI фронтенд для gdb\nconst debugger = b.addSystemCommand(&.{ \"seergdb\", \"--run\", \"--\" });\ndebugger.addArtifactArg(exe_unit_tests);\n\nconst debug_step = b.step(\"debug\", \"Run unit tests under debugger\");\ndebug_step.dependOn(&debugger.step);\n\nЭто запускает правильный бинарник. Но отладчик сработает лишь на брейкпоинте или панике, тогда как раннер тестов «проглатывает» ошибки.\n\nКомбинация трюков\n\nДобавим @breakpoint через errdefer:\n\ntest {\n    errdefer @breakpoint();\n}\n\nТак мы попадаем в точку ошибки, видим контекст и вывод std.testing.expect*. Минус: при zig build test отчёт показывает падение всего шага тестов, а не отдельных кейсов. Нужна возможность включать брейкпоинты выборочно.\n\nУсловная компиляция\n\nЧерез build options пробрасываем флаг, решающий, вызывать ли @breakpoint в тестах.\n\nМинимальный скрипт сборки, запускающий тесты, дополняем опциями:\n\nconst std = @import(\"std\");\n\npub fn build(b: *std.Build) void {\n    const target = b.standardTargetOptions(.{});\n    const optimize = b.standardOptimizeOption(.{});\n\n    const lib = b.addModule(\"zig-test-patterns\", .{\n        .root_source_file = b.path(\"src/root.zig\"),\n        .target = target,\n        .optimize = optimize,\n    });\n\n    const options = b.addOptions();\n    options.addOption(bool, \"debugger\", false);\n    lib.addImport(\"config\", options.createModule());\n\n    const mod_tests = b.addTest(.{ .root_module = lib });\n    const run_mod_tests = b.addRunArtifact(mod_tests);\n\n    const test_step = b.step(\"test\", \"Run tests\");\n    test_step.dependOn(&run_mod_tests.step);\n}\n\nВ коде тестов:\n\nconst std = @import(\"std\");\nconst config = @import(\"config\");\n\ntest \"errdefer @breakpoint()\" {\n    errdefer if (config.debugger) @breakpoint();\n    return error.FixMe;\n}\n\ntest \"no breakpoint\" {\n    return error.FixMe;\n}\n\nzig build test — без брейкпоинтов. Но менять значение флага так — значит пересобирать build.zig. Добавим опцию прямо в систему сборки:\n\nvar options = b.addOptions();\nconst use_debugger = b.option(\n    bool,\n    \"debugger\",\n    \"Enables code intended to only run under a debugger\",\n) orelse false;\noptions.addOption(bool, \"debugger\", use_debugger);\n\nТеперь можно переключать поведением командой:\n\nzig build -Ddebugger test\n\nИ, при желании, привязать шаг запуска отладчика к этому флагу.",
  "inputHash": "85d2df33224b9b4a1581e6017e3d3e3e51fa6b6b160020249b40beaf656047ee",
  "model": "openrouter/horizon-beta",
  "createdISO": "2025-08-07T09:14:54.190Z"
}
{
  "id": 44841891,
  "lang": "ru",
  "summary": "**Неопределённое поведение (UB)** в C/C++ — это ситуация, когда стандарт языка не накладывает никаких требований на результат. Компилятор вправе считать, что такой код никогда не выполнится, и оптимизировать «на смерть», вплоть до полного удаления проверок.\n\n### Классические примеры UB\n- Разыменование неверного указателя  \n- Чтение неинициализированных данных  \n- Переполнение знакового целого (`INT_MAX + 1`)  \n- Сдвиг вне диапазона `0 … width-1`  \n- Нарушение правил aliasing (чтение `int` по указателю `float*`)  \n\n### Почему это сделано\nНе ради экзотического железа, а ради **скорости**: зная, что UB невозможно, компилятор может убрать лишние проверки, векторизовать циклы и т. д.  \nПример:  \n```c\nint succ(int a){\n    if(a+1 < a) error(); // UB при переполнении\n    return a+1;\n}\n```\nGCC ‑O3 превращает в просто `lea eax, [rdi+1]` — проверка исчезла.\n\n### Как не стрелять себе в ногу\n- Включайте **-Wall -Wextra -Werror**  \n- Используйте **ASan/UBSan/MSan** (`-fsanitize=address,undefined`)  \n- Проверяйте границы: `std::span`, `gsl::span`, `std::vector::at`  \n- Статические анализаторы: Clang Static Analyzer, Coverity, PVS-Studio  \n- Для отладки можно **выключить оптимизацию** (`-O0`)  \n- Если UB неизбежно — рассмотрите другой язык (Rust, Zig, Swift, Go)",
  "inputHash": "911fe5600bd71347d76dff0ee9a3211140c431401558d3d40cd3b3b2db155b87",
  "model": "moonshotai/kimi-k2:free",
  "createdISO": "2025-08-12T07:26:41.120Z"
}
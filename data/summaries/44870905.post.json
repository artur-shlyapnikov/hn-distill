{
  "id": 44870905,
  "lang": "ru",
  "summary": "**Двоичная куча в SIMD**\n\nКуча — почти полное бинарное дерево, линейно размещённое в массиве:  \nродитель `i` → дети `2i+1`, `2i+2`; дети всегда меньше родителя (max-heap).\n\nРассмотрим две операции:\n\n- `is_heap` — проверка массива на корректность кучи;  \n- `push_heap` — добавление элемента.\n\n---\n\n### is_heap\n\nПростой сканированный алгоритм не векторизуется.  \nВекторизуемый вариант: два «указателя» — родители и дети, шаг +1 и +2.\n\n**Шаблон для forward-итераторов:**\n```cpp\ntemplate <typename It, typename Cmp = std::less<>>\nbool is_heap_fwd(It b, It e, Cmp cmp) {\n    if (b == e) return true;\n    auto p = b, c = std::next(b);\n    while (c != e) {\n        if (cmp(*p, *c)) return false;\n        ++c; if (c == e) break;\n        if (cmp(*p, *c)) return false;\n        ++p; ++c;\n    }\n    return true;\n}\n```\n\n**SIMD-схема (8-элементный вектор):**\n\n1. Загружаем 8 родителей `p`.  \n2. Загружаем два вектора детей `c0`, `c1`.  \n3. Дублируем каждый родитель: `p0=[a,a,b,b,…]`, `p1=[e,e,f,f,…]`.  \n4. Сравниваем `p0 ≥ c0`, `p1 ≥ c1` — одной инструкцией проверяем 8 пар.\n\n---\n\n### push_heap\n\nМожно выразить через gather/scatter, но производительность низкая.  \nПриведена реализация на AVX-512 для полноты картины.\n\n---\n\n**Итог:**  \n- `is_heap` ускоряется в 2–4 раза на AVX2/AVX-512.  \n- `push_heap` и `pop_heap` векторизуются плохо, выгода минимальна.",
  "inputHash": "52f739b2b48db239c360add5e54c9afc13c3684ecf7a804bcb5bee76b5a343c2",
  "model": "moonshotai/kimi-k2:free",
  "createdISO": "2025-08-14T14:25:40.192Z"
}
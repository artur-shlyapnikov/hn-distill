{
  "id": 44820341,
  "lang": "ru",
  "summary": "- Rust-фреймворк для распознавания файлов с высокой расширяемостью и кастомизацией.\n\nУровни использования\n\n- Уровень 1: встроенное определение по сигнатурам (~50 типов).\n  - Используйте API `magical_rs`, список поддерживаемых форматов см. по ссылке в репо.\n  - Можно вносить новые сигнатуры через PR.\n  - Пример:\n    ```\n    use magical_rs::magical::bytes_read::{read_file_header, with_bytes_read};\n    use magical_rs::magical::magic::FileKind;\n\n    let max_byte_read = with_bytes_read();\n    let bytes = read_file_header(\"img/2.iso\", max_byte_read).unwrap();\n\n    match FileKind::match_types(&bytes) {\n        Some(k) => println!(\"{k:?}\"),\n        None => println!(\"Could not detect ISO file.\"),\n    }\n    ```\n  - Больше примеров в examples/dyn_magic.\n  - Поддерживает no_std.\n\n- Уровень 2: безграничная компиляционная кастомизация с функциями-указателями.\n  - Кастомные сигнатуры, смещения, сложная логика через указатели на функции и макросы.\n  - Позволяет детектировать любые типы на этапе компиляции.\n  - Пример:\n    ```\n    use magical_rs::{any_matches, magic_custom, match_custom};\n\n    #[derive(Clone, Copy, PartialEq, Eq, Debug)]\n    enum FileKind { Shoujo, UnknownFallback }\n\n    fn is_shoujo(bytes: &[u8]) -> bool { bytes.starts_with(b\"Magic!\") }\n    fn is_not_shoujo(bytes: &[u8]) -> bool { !bytes.starts_with(b\"Magic!\") }\n\n    pub fn magic_custom_any() {\n        let rule = magic_custom!(\n            signatures: [],\n            offsets: [0],\n            max_bytes_read: 2451,\n            kind: FileKind::Shoujo,\n            rules: any_matches!(is_shoujo, is_not_shoujo)\n        );\n\n        let result = match_custom!(\n            bytes: b\"Magic!\",\n            rules: [rule],\n            fallback: FileKind::UnknownFallback\n        );\n\n        assert_eq!(result, FileKind::Shoujo);\n    }\n    ```\n  - Варианты реализации в examples/magic_custom.\n  - Поддерживает no_std.\n\n- Уровень 3: произвольная логика во время выполнения.\n  - Полная свобода: любые проверки, ИИ, сетевые запросы, процессы и т.д.\n  - Включение: `cargo add magical_rs --features magical_dyn`\n  - Пример:\n    ```\n    use magical_rs::magical::dyn_magic::DynMagicCustom;\n\n    fn my_detect_rule() -> impl Fn(&[u8]) -> bool {\n        let require_bytes = b\"MagicalGirl\";\n        |bytes: &[u8]| bytes.starts_with(require_bytes) && bytes.len() == require_bytes.len()\n    }\n\n    fn detect_custom_file(file_bytes: &'static [u8]) -> bool {\n        let detect_fn = my_detect_rule();\n        let rule = DynMagicCustom::new(detect_fn, String::from(\"Is Mahou Shoujo Detect.\"), 32);\n\n        let kind = rule.kind_downcast_ref::<String>();\n        match kind {\n            Some(k) => println!(\"{k}\"),\n            None => println!(\"Kind not found.\"),\n        }\n        rule.matches(file_bytes)\n    }\n    ```\n  - Примеры в examples/dyn_magic.\n  - Предупреждение: использовать, только если понимаете последствия.\n\n- Уровень 4: асинхронные правила без ограничений.\n  - Проектирование правил в async-среде любой сложности. Используйте, только если действительно нужно и хватает опыта.\n  - Включение: `cargo add magical_rs --features magical_async_dyn`\n  - Пример (фрагмент):\n    ```\n    use async_std::task;\n    use magical_rs::magical::async_dyn_magic::AsyncDynMagic;\n    use magical_rs::magical::async_dyn_magic::match_dyn_types_as;\n    use std::time::Duration;\n\n    async fn magic_async_detect() {\n        let func_detect = |bytes: &[u8]| {\n            let owned_bytes = bytes.to_vec();\n            Box::pin(async move {\n                println!(\"Rest for 1 second\");\n                task::sleep(Duration::from_millis(1000)).await;\n                owned_bytes.starts_with(b\"Magical\")\n            })\n        };\n    }\n    ```",
  "inputHash": "f625318ca06d2bc89bfeab604fddd2c0ad9ca7c046892034ff4f50c9c1682958",
  "model": "openrouter/horizon-beta",
  "createdISO": "2025-08-07T09:13:26.174Z"
}
{
  "id": 44889163,
  "lang": "ru",
  "summary": "**День 2: строим дерево Хаффмана**\n\nПереписал `bz2.adb` на чистые структуры:  \n`Bit_Writer`, `MTF`, `RLE`, `Burrows_Wheeler`, `Huffman`.  \nКаждая структура = пакет + скрытый тип + конструктор `Create`, методы `Encode`, `Flush`, `Reset`.\n\n**Huffman**  \n- Считаем частоты 256 байт + 2 служебных символа (`RUNA`, `RUNB`).  \n- Строим дерево: `Node` (частота, символ, левый, правый).  \n- Сортируем список узлов по частоте, склеиваем два минимальных, повторяем, пока не останется один корень.  \n- Коды длиной ≤ 20 бит (требование BZip2).  \n- Генерируем таблицу `Code_Length[0..257]` и `Code_Value[0..257]`.\n\n**Оптимизация**  \n- Если дерево выдаёт слишком длинные коды, увеличиваем частоты всех символов на 1 и перестраиваем — быстро сходится.  \n- Память: дерево живёт только во время построения, затем храним только таблицы.\n\n**Интеграция**  \n`Huffman.Encode` получает поток MTF/RLE-символов, пишет в `Bit_Writer`:  \n1. 16-битная маска `0x425A` (\"BZ\").  \n2. 8-битная версия `0x68`.  \n3. Таблица длин кодов (передаём как 4-битные значения).  \n4. Сами данные: коды Хаффмана + биты RLE-последовательностей.  \n\n**Итог за день**  \n- 400 строк Ada, 0 зависимостей.  \n- Код компилируется `gnatmake -O2 bz2.adb` за 0.3 с.  \n- Тест: `echo \"abracadabra\" | ./bz2 > out.bz2`, `bunzip2` принимает без ошибок.  \n\nЗавтра: многопоточность и буферизация.",
  "inputHash": "10945b71541e9f3492c744c8d828e61f01ce1442a031693aa7a76341e5d86884",
  "model": "moonshotai/kimi-k2:free",
  "createdISO": "2025-08-16T14:22:59.542Z"
}
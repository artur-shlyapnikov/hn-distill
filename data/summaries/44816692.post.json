{
  "id": 44816692,
  "lang": "ru",
  "summary": "- В 70‑х некоторые системы (например, PDP‑10) имели 9‑битовые байты, но стандарт закрепился за 8 битами. Если бы байт был 9‑битным, ряд исторических случайностей сыграли бы нам на руку.\n\n- IPv4: при 9‑битовых байтах адрес IPv4 был бы 36‑битным (~64 млрд адресов). Этого хватило бы до 2030‑х без массового NAT и тормозов с IPv6; позже проблему решили бы мягкими рыночными механизмами.\n\n- UNIX time: 32‑битные метки ломаются в 2038, а 36‑битные прожили бы до 3058. Отрицательные охватывали бы времена с 882 года — достаточно для исторических нужд.\n\n- Юникод: вместо 16‑битных 65 тыс. символов было бы 18‑битных 262 тыс. — хватило бы без болезненной унификации CJK; сейчас всех символов ~155 тыс. UTF‑9 стал бы скорее компрессией и уступил бы GZip; либо однобайтно‑двухбайтная схема при умеренной экономии на эмодзи.\n\n- Указатели и память: 36‑битные ОС дали бы до 32 ГБ на процесс (вместо 2 ГБ у 32‑битных). Серверы всё равно виртуализируют; меньшие указатели экономят память и ускоряют код, хотя строки стали бы длиннее — общий баланс близок к нулю.\n\n- Прочие выигрыши:\n  - 18‑битные AS‑номера не иссякли бы; порты/PID/UID просторнее.\n  - Кодирование инструкций x86/A64 чуть опрятнее; Thumb работал бы лучше.\n  - Полуточные 18‑битные числа прижились бы раньше; экзотика 4–5 бит не взлетела бы.\n  - Расширенный ASCII влез бы с греческим и стал бы «натовской» кодовой страницей; UTF‑9 привилегировал бы почти всю Западную Европу.\n  - Права Unix умещались бы в один байт (без «липких» битов). Оctal стал бы нормой вместо hex.\n  - 18‑битный цвет 6/6/6 даёт различия на грани восприятия; потеря альфа‑канала неприятна.\n\n- Издержки? Существенных нет: адресация по битам не используется; деления на девять не требуется; размеры страниц/блоков ОС могли бы остаться прежними, ядру не пришлось бы менять основы работы.",
  "inputHash": "afb02682e2da02d238d8f8b573ea3d0a0a271a251481fce600871b4ebc3ec2f0",
  "model": "openrouter/horizon-beta",
  "createdISO": "2025-08-07T09:11:42.285Z"
}
{
  "id": 44825175,
  "lang": "ru",
  "summary": "Еще немного о шеллах: списки как объекты первого класса, jq и es\n\nВступление\n\nВ большинстве шеллов нет полноценных списков. Передавать список можно через argv (\"$@\" или \"${list_variable[@]}\"), но как вернуть список?\n\nЕсть несколько подходов.\n\nЗадача\n\nСделаем split-by-double-dash, функцию/программу, возвращающую два списка: аргументы до -- и после него. Пример: split-by-double-dash a b c -- d e f → [a, b, c] и [d, e, f]. Полезно для оберток над утилитами с таким форматом.\n\nВариант с кавычками и jq\n\nНекоторые утилиты выводят текст, экранированный под shell: getopt, jq. Нас интересует jq.\n\nПример:\njq -nr '[\"foo\", \"baz\", \"baz quux\"] | @sh'\n'foo' 'baz' 'baz quux'\n\nМы просим jq выдать строку для eval. -n — без входа, -r — текст, не JSON.\n\nПрименение:\neval set -- \"$(jq -nr '[\"foo\", \"bar\", \"baz quux\"] | @sh')\"\nprintf 'arg: %s\\n' \"$@\"\n# arg: foo\n# arg: bar\n# arg: baz quux\n\nЭто безопасно: jq правильно экранирует. Для вложенных списков:\njq -nr '[[\"foo\", \"bar\"], [\"baz\", \"baz quux\"]] | map(@sh) | @sh'\n# ''\\''foo'\\'' '\\''bar'\\''' ''\\''baz'\\'' '\\''baz quux'\\'''\n\nmap(@sh) экранирует каждый список, затем @sh — общий.\n\nПередача аргументов в jq:\njq '$ARGS.positional' -n --args -- a b c\n# [\"a\",\"b\",\"c\"]\n\nГотовый скрипт (через shebang /usr/bin/env и -f):\n#!/usr/bin/env -S jq -nrf --args --\n# Usage: eval set -- \"$(split-by-double-dash ...)\"\n# Or, in Bash: eval array=(\"$(split-by-double-dash ...)\")\n$ARGS.positional |\nreduce .[] as $arg (\n  { before: [], after: [], found: false };\n  if .found then\n    .after += [$arg]\n  elif $arg == \"--\" then\n    .found = true\n  else\n    .before += [$arg]\n  end\n) |\n{ before, after } |\nmap(@sh) |\n@sh\n\nИспользование (bash/sh):\neval array=(\"$(./split-by-double-dash a b c -- d e f)\")\neval before=(\"${array[0]}\")\neval after=(\"${array[1]}\")\nprintf '%s\\n' \"${before[@]}\"\n# a\n# b\n# c\n\nВариант с замыканиями в es\n\nes — наследник rc, с влиянием Tcl/Scheme. Есть полноценные функции и структурированные возвраты, что позволяет возвращать несколько списков без экранирования.\n\nЭмуляция списка\n\nВ es нельзя хранить списки в списках, только строки. Эмулируем списки замыканием.\n\nfn list { return @ _ { return $* } }\n\nФункция list принимает произвольные аргументы ($*), возвращает функцию, игнорирующую свой аргумент (_), которая при вызове возвращает исходный список — замыкание.\n\nПроверим:\nlist a b c\n# ничего — return не печатает. Чтобы получить значение, используем <=\n\n<= { list a b c }\n# опять тишина; выведем через printf:\n\nprintf '%s\\n' <= { list a b c }\n# %closure(*=a b c)@ _{return $*}\n\nЧтобы получить элементы, вызываем еще раз:\nprintf '%s\\n' <= <= { list a b c }\n# a\n# b\n# c\n\nОстальная часть\n\nИмея “списки”, реализуем разделение по --: вместо накопления до -- находим разделитель и формируем два списка на месте.\n\nfn list { ... }",
  "inputHash": "d6120a7ea825079e905d7274c1d8e7409a98b15bc24a49eda3c03f8ac3634e7b",
  "model": "openrouter/horizon-beta",
  "createdISO": "2025-08-07T16:36:21.178Z"
}
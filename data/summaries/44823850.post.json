{
  "id": 44823850,
  "lang": "ru",
  "summary": "Model Context Protocol (MCP) стал стандартом для вызова инструментов при создании агентов, но сам LLM не обязан «понимать» MCP. При «инжиниринге контекста» вы даете модели нужные данные и доступ к инструментам; стандарт MCP лишь унифицирует подключение к ним. Для модели это просто список определений инструментов — она не знает о реализации, и это нормально.\n\nMCP дает доступ к тысячам инструментов без кастомных интеграций и упрощает агентный цикл: разработчик вызывает инструменты, а LLM лишь генерирует текстовый фрагмент с именем инструмента и параметрами. LLM не «умеет» вызывать функции — он предсказывает текст, который ваша система парсит, выполняет реальный вызов и возвращает результат как новое сообщение.\n\nПример: при наличии инструмента get_weather(location) на вопрос «Какая погода в Сан-Хосе?» модель может сгенерировать:\n{\n  \"name\": \"get_weather\",\n  \"input\": { \"location\": \"San Jose, CA\" }\n}\nАгент выполняет этот вызов и передает ответ обратно модели. Разделение обязанностей: LLM предсказывает, система исполняет.\n\nMCP стандартизирует подключение к источникам (инструменты, подсказки, ресурсы, примеры) через хост-приложение с MCP-клиентом и сервера MCP, которые экспонируют инструменты. Взаимодействие с LLM не меняется — меняется способ, как инструменты подаются и вызываются «под капотом». Для того же вопроса модель увидит тот же список инструментов; решение, как именно вызвать, остается за разработчиком (с MCP — через MCP).\n\nПреимущества MCP — для разработчика: управление ростом числа инструментов, переиспользование, единые форматы, быстрые подключения к новым системам без переписывания кода. LLM не узнает о MCP, если вы сами не укажете это в системном промпте; его роль — сгенерировать фрагмент вызова, а ваша — выполнить его.",
  "inputHash": "e29bf7a83a3f564020f47279f6cdbf4fabcf916de5300b04fc31eb42285754a3",
  "model": "openrouter/horizon-beta",
  "createdISO": "2025-08-07T13:43:59.503Z"
}
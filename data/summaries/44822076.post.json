{
  "id": 44822076,
  "lang": "ru",
  "summary": "**eBPF-трамплин: как ядро «подпрыгивает» для запуска программ**\n\neBPF-программы трассировки (kprobe, tracepoint, fentry/fexit и др.) позволяют мониторить ядро без изменения его кода. Например, чтобы отслеживать открытие файлов, достаточно 20 строк C:\n\n```c\nSEC(\"fentry/do_sys_openat2\")\nint BPF_PROG(trace_files, int dfd, const char *filename, void *how)\n{\n    bpf_trace_printk(\"Process %d tried to open file %s\",\n                     bpf_get_current_pid_tgid(), filename);\n    return 0;\n}\n```\n\nСкомпилировав и загрузив объект `trace_openat2.o`, мы мгновенно получаем поток событий в ftrace.\n\n**Проблема производительности**  \nПри сотнях подписок на высокочастотные события каждая лишняя инструкция дорого обходится. Классический способ вызова eBPF-программы через `kprobe` требует:\n\n1. Сохранения всех регистров.\n2. Подготовки `struct pt_regs`.\n3. Перехода в «толстый» обработчик kprobe.\n4. Вызова интерпретатора или JIT-кода eBPF.\n5. Восстановления регистров и возврата.\n\n**Трамплин: легковесный мост**  \nВместо этого ядро генерирует **трамплин** — крошечную подставную функцию, которая:\n\n*   сохраняет лишь нужные регистры;\n*   сразу передаёт управление скомпилированному JIT-коду eBPF;\n*   после выполнения возвращается к исходной функции.\n\nТакой «прыжок» сокращает оверхед до минимума и позволяет запускать тысячи eBPF-программ без заметного влияния на систему.",
  "inputHash": "3a424e0a47e07fe137bbed320353c17c90c22ed9f7f2cc316f45edaa6c065d97",
  "model": "moonshotai/kimi-k2:free",
  "createdISO": "2025-08-11T07:31:36.084Z"
}
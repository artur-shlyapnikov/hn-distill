{
  "id": 44871093,
  "lang": "ru",
  "summary": "`top` и `free` внутри контейнера показывают память хоста, потому что читают `/proc/meminfo`, который не «видит» cgroup-ограничений.  \nКонтейнер запускается с лимитом 10 МБ, но `free -h` и `top` выводят 1,9 ГБ — значения из глобального `/proc/meminfo`.\n\n**Почему так происходит**  \n- `free` и `top` открывают `/proc/meminfo` и считывают оттуда поля `MemTotal`, `MemFree` и т.д.  \n- `/proc/meminfo` формируется ядром без учёта cgroup, поэтому возвращает данные всей машины.  \n- cgroup-ограничения задаются через файлы вида `/sys/fs/cgroup/memory/...`, но в пространство имён контейнера они не проброшены, и обычные утилиты их не читают.\n\n**Как узнать реальный лимит**  \n- Читать `memory.limit_in_bytes` и `memory.usage_in_bytes` внутри контейнера:  \n  ```bash\n  cat /sys/fs/cgroup/memory/memory.limit_in_bytes\n  cat /sys/fs/cgroup/memory/memory.usage_in_bytes\n  ```  \n- Использовать `docker stats` или `crictl stats` снаружи.  \n- Приложения, работающие внутри контейнера, могут использовать библиотеки, которые сами парсят cgroup (например, `cadvisor`).\n\n**Итог**  \n`/proc/meminfo` не неймспейсится, поэтому классические утилиты показывают хостовые значения. Для мониторинга контейнеров нужно опираться на cgroup-интерфейс или специализированные инструменты.",
  "inputHash": "8b88af75e0b9edeb943f242e8031548b66d4f9f36de87f3ddc06c859e0a52d3e",
  "model": "moonshotai/kimi-k2:free",
  "createdISO": "2025-08-14T02:01:47.774Z"
}
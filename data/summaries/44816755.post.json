{
  "id": 44816755,
  "lang": "ru",
  "summary": "- Несколько лет назад мне выпал шанс выбрать async‑first, типизированный Python‑фреймворк для веба. Я взял Litestar — без хайпа и ракет в твитах — и не пожалел: уже около 18 месяцев все мои новые рабочие проекты на нём.\n\n- Даже если вы пишете асинхронные веб‑приложения на Python, вы могли пройти мимо Litestar. Хочу это исправить.\n\n- Вкус демо: простой файл\n  ```\n  from litestar import Litestar, get\n\n  @get(\"/greet\")\n  async def greet(name: str) -> str:\n      return f\"Hi, {name}!\"\n\n  app = Litestar([greet])\n  ```\n  Запускаете через litestar run или любой ASGI‑сервер. /greet?name=Bob вернёт «Hi, Bob!». Без name — HTTP 400: параметр обязателен. Да, похоже на FastAPI и на знакомые по Spring/ASP.NET MVC подходы с аннотациями — и FastAPI тоже так умеет. Но у Litestar есть свои сильные стороны.\n\n- Про название: раньше проект назывался Starlite, потому что изначально строился на Starlette (как и FastAPI). Позже зависимость убрали, а чтобы не путать со Starlette, в релизе 2.0 (2023) переименовали в Litestar.\n\n- Масштабирование кода, а не трафика:\n  - Django плохо «масштабируется вниз»: «правильный» старт быстро разрастается в десяток файлов и папок. Однофайловые трюки работают, но против шерсти.\n  - Микрофреймворки — наоборот: стартуют в одном файле, но по мере роста кода расползаются и начинают мешать.\n  - В FastAPI маршруты обычно вешаются декораторами на объект приложения. Это удобно в одном файле, но при разбиении на модули ведёт к циклическим импортам. Решение — «вторичные» реестры маршрутов (APIRouter, blueprint): нужны, потому что декораторы привязаны к app. Litestar же позволяет описывать обработчики отдельно и передавать их приложению списком, что естественно масштабируется от одного файла к структуре проекта без костылей.",
  "inputHash": "78ce17935d822f134e6fb5b189f55a270dc1d22d01635f5317792da79062c184",
  "model": "openrouter/horizon-beta",
  "createdISO": "2025-08-07T09:10:46.471Z"
}
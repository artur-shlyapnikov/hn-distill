{
  "id": 44855881,
  "lang": "ru",
  "summary": "Zig выглядит почти как Rust, но делает синтаксис ещё приятнее за счёт более простой семантики и ряда изящных решений.\n\n**Числа**  \nЛитералы `92` всегда имеют тип `comptime_int`; при присваивании они неявно приводятся к нужному типу. Суффиксов нет.\n\n**Строки**  \nМногострочные «сырые» строки пишутся через `\\\\` в начале каждой строки; `\\` не экранируется, отступы не портятся, а лексер работает построчно.\n\n**Структуры**  \n`.{ .x = 1, .y = 2 }` — запись поля через `.x =` совпадает с присваиванием, что позволяет грепом находить именно записи, а не чтения.\n\n**Типы**  \nВсе типы префиксные: `u32`, `[3]u32`, `?[3]u32`, `*const ?[3]u32`. Разыменование постфиксное: `ptr.*`.\n\n**Идентификаторы**  \nСинтаксис `@\"имя с пробелом\"` позволяет обходить ключевые слова и экспортировать любые имена.\n\n**Функции**  \n`fn add(x: i32, y: i32) i32` — без стрелки `->`, так как лямбд нет, а возвращаемый тип всегда обязателен. `pub fn main() void {}`.\n\n**Переменные**  \n`const` и `var`; часто используемое `const` короче, чем в Rust, но всё же длиннее Kotlin-овского `val`.",
  "inputHash": "c39c10a76518f33b38b7c1e5b945eac3bdc94edeacdf0dd7c95b55c1cfc1aba6",
  "model": "moonshotai/kimi-k2:free",
  "createdISO": "2025-08-10T16:29:21.655Z"
}
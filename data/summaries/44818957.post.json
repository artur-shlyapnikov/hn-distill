{
  "id": 44818957,
  "lang": "ru",
  "summary": "August 6th, 2025\n\nВ прошлой записи я рассказывал о Plush — игрушечном языке с акторным параллелизмом. Реализация ещё сырая, но уже можно писать забавные программы с 2D/3D‑графикой и распараллеливать задачи на несколько ядер. Хочу ради развлечения сделать софтварный рендер вращающегося куба, но сперва немного ускорю интерпретатор, чтобы не терять лишнюю производительность.\n\nМой научрук обожал рекурсивный микробенчмарк Fibonacci — «fib». При каждом разговоре о компиляторах он стремился запустить этот крошечный тест и сравнить скорости, нередко со своим Scheme‑компилятором — то ли в шутку, то ли всерьёз.\n\n```\nfun fib(n)\n{\n    if (n < 2)\n        return n;\n\n    return fib(n - 1) + fib(n - 2);\n}\n```\n\nМикробенчмарки не отражают общую производительность, но полезны: здесь «fib» резко подчёркивает стоимость вызовов функций — важного источника накладных расходов.\n\nВ Plush fib(38) занял 9.10 с в релизной сборке — это 126+ млн вызовов, около 14 млн/с. Python 3.13.5 сделал то же за 5.70 с, Plush на ~60% медленнее. Учитывая, что CPython тоже токен‑трединговый интерпретатор, сравнение честное. Я решил посмотреть, можно ли парой простых трюков обогнать CPython на «fib».\n\nБайт‑код для fib содержит 18 инструкций. Как и в CPython, VM стековая: get_arg кладёт аргумент, push — константу, lt — сравнение и т. п. Бросилось в глаза, что перед вызовом я кладу на стек константу‑функцию, а затем делаю call. В этом месте функция известна заранее, значит можно слить push+call в call_direct с зашитой целью. Это убрало две инструкции и ускорило с 9.10 с до 8.44 с.\n\nПочему быстрее? Главная потеря в интерпретаторах — диспетчеризация инструкций. Чем «толще» инструкция, тем реже диспетчеризация и тем больше шансов у компилятора оптимизировать блок кода целиком.\n\nДальше я профилировал Linux perf. В Plush функции лениво компилируются в байт‑код при первом вызове: парсим всё в AST, но компилируем по требованию — экономим время/память и получаем больше информации для оптимизаций. Инструкция call при вызове смотрит в хеш‑таблицу: скомпилирована ли функция и куда прыгать (PC). Этот поиск оказался ощутимой нагрузкой. Я добавил инструкцию call_pc — вызов функции, уже имеющей байт‑код, — и сделал так, чтобы call_direct инициировал компиляцию при первом обращении и затем переходил на call_pc, убирая последующие хеш‑поиски.",
  "inputHash": "c9c6afdadca6b685c5c36b229a4b3a01af9c735fdc1e503d3dc80328454ae8f5",
  "model": "openrouter/horizon-beta",
  "createdISO": "2025-08-07T09:15:48.147Z"
}